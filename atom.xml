<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yingzq&#39;s Blog</title>
  
  <subtitle>练习bug时长两年半的实习生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yingzq.com/"/>
  <updated>2020-04-04T09:33:16.059Z</updated>
  <id>http://www.yingzq.com/</id>
  
  <author>
    <name>应子强</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论动态规划常见的5种模式</title>
    <link href="http://www.yingzq.com/2020/03/28/dynamic-programming-patterns/"/>
    <id>http://www.yingzq.com/2020/03/28/dynamic-programming-patterns/</id>
    <published>2020-03-28T02:27:48.000Z</published>
    <updated>2020-04-04T09:33:16.059Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划（dynamic programming，简称DP）一直是算法面试中最难的话题之一。DP的本质在于如何完整的刻化状态而又使状态不包含冗余信息，这是比较难的一点；另外，不同的DP问题之间似乎并不能用统一的模式来表示，所以往往在做了一些DP题之后遇到新的DP问题还是束手无策（泛化能力差~）。</p><p>本文copy自一篇LeetCode Discuss区大佬对DP模式的总结，原文将DP问题大致分成5种模式，并给出了相应解决方案的思路，感觉让我获益匪浅，因此文本也将原文提到的题目列表基本实现了一遍（删掉了少量较复杂的题）。</p><p>原文作者对常见的DP问题分为5种模式（patterns）：</p><ul><li>Minimum (Maximum) Path to Reach a Target</li><li>Distinct Ways</li><li>Merging Intervals</li><li>DP on Strings</li><li>Decision Making</li></ul><p>下文分别对这5种模型进行讲解，说明一下，其中 “Statement” 代表 “此类模式问题的一般描述” ，”Approach” 代表 “此类问题的解题套路” ，”Similar Problems” 代表 “与此类模式相关的leetcode原题”，本文将给出相应的解答。</p><blockquote><p>注：原文链接 <a href="https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns" target="_blank" rel="noopener">Dynamic Programming Patterns</a> 。另外，原文的表达挺好的，所以原文大部分的英文表达做了保留，emmm，因此文章看起来可能是中英混杂的，但是不妨碍阅读。</p></blockquote><h2 id="Minimum-Maximum-Path-to-Reach-a-Target"><a href="#Minimum-Maximum-Path-to-Reach-a-Target" class="headerlink" title="Minimum (Maximum) Path to Reach a Target"></a>Minimum (Maximum) Path to Reach a Target</h2><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>Given a target find minimum (maximum) cost / path / sum to reach the target.</p><h3 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h3><p>Choose minimum (maximum) path among all possible paths before the current state, then add value for the current state.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">routes[i] &#x3D; min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]</span><br></pre></td></tr></table></figure><p>Generate optimal solutions for all values in the target and return the value for the target.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ways.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (ways[j] &lt;= i) &#123;</span><br><span class="line">           dp[i] = <span class="built_in">min</span>(dp[i], dp[i - ways[j]] + cost / path / sum) ;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p>列举如下：</p><ul><li><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a> <strong>Easy</strong></li><li><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">931. 下降路径最小和</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">983. 最低票价</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/2-keys-keyboard/" target="_blank" rel="noopener">650. 只有两个键的键盘</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/" target="_blank" rel="noopener">1049. 最后一块石头的重量 II</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">174. 地下城游戏</a> <strong>Hard</strong></li></ul><h4 id="使用最小花费爬楼梯-Easy"><a href="#使用最小花费爬楼梯-Easy" class="headerlink" title="使用最小花费爬楼梯 Easy"></a>使用最小花费爬楼梯 Easy</h4><p><strong>题目</strong></p><p>数组的每个索引做为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i] (索引从0开始)。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: cost &#x3D; [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br><span class="line"></span><br><span class="line">输入: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>cost 的长度将会在 [2, 1000]。</li><li>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</li></ul><p><strong>分析</strong></p><p>到达<code>dp[i]</code>位置的方式只有<code>dp[i-1]</code>和<code>dp[i-2]</code>，因此很容易得到状态转移方程：</p><p><code>dp[i] = min(dp[i-1], dp[i-2]) + cost[i]</code></p><p>另外在最后<code>i == n</code>的位置需要特殊处理，所以总体的状态转移方程如下：</p><p><code>dp[i] = min(dp[i-1], dp[i-2]) + (i == n ? 0 : cost[i])</code></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + (i == n ? <span class="number">0</span> : cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最小路径和-Medium"><a href="#最小路径和-Medium" class="headerlink" title="最小路径和 Medium"></a>最小路径和 Medium</h4><p><strong>题目</strong></p><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p><strong>分析</strong></p><p>直接得出状态转移方程<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code>。</p><p>从空间复杂度角度考虑，这题不需要开辟一个新的dp数组，直接把原数组当做dp数组用，即：</p><p><code>grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]</code> 。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            grid[i][j] += Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="零钱兑换-Medium"><a href="#零钱兑换-Medium" class="headerlink" title="零钱兑换 Medium"></a>零钱兑换 Medium</h4><p><strong>题目</strong></p><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3</span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br><span class="line"></span><br><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p>说明: 你可以认为每种硬币的数量是无限的。</p><p><strong>分析</strong></p><p>状态转移方程：<code>dp[i] = min(dp[i-coin_1], dp[i-coin_2], ... , dp[i-coin_k]) + 1</code>，另外要考虑不存在的情况。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[amount] == amount + <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下降路径最小和-Medium"><a href="#下降路径最小和-Medium" class="headerlink" title="下降路径最小和 Medium"></a>下降路径最小和 Medium</h4><p><strong>题目</strong></p><p>给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。</p><p>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：12</span><br><span class="line">解释：</span><br><span class="line">可能的下降路径有：</span><br><span class="line">[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]</span><br><span class="line">[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]</span><br><span class="line">[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]</span><br><span class="line">其中和最小的下降路径是 [1,4,7]，所以答案是 12。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>状态转移方程：<code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + A[i][j]</code>。</p><p>同样，我们可以在原数组A上进行修改，但是这样就会产生边界问题，需要小心处理。</p><blockquote><p>注：如果是自己生成dp数组，我们可以进行套壳处理，这样就不用处理那么多的边界了，但是这里为了省空间还是在原数组上进行修改。</p></blockquote><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span> || A[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = A.length, n = A[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = A[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) min = Math.min(min, A[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n - <span class="number">1</span>) min = Math.min(min, A[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">            A[i][j] = min + A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : A[m - <span class="number">1</span>]) &#123;</span><br><span class="line">        res = Math.min(res, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最低票价-Medium"><a href="#最低票价-Medium" class="headerlink" title="最低票价 Medium"></a>最低票价 Medium</h4><p><strong>题目</strong></p><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p><p>火车票有三种不同的销售方式：</p><ul><li>一张为期一天的通行证售价为 costs[0] 美元；</li><li>一张为期七天的通行证售价为 costs[1] 美元；</li><li>一张为期三十天的通行证售价为 costs[2] 美元。</li></ul><p>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p><p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：days &#x3D; [1,4,6,7,8,20], costs &#x3D; [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 1 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 1 天生效。</span><br><span class="line">在第 3 天，你花了 costs[1] &#x3D; $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。</span><br><span class="line">在第 20 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= days.length &lt;= 365</li><li>1 &lt;= days[i] &lt;= 365</li><li>days 按顺序严格递增</li><li>costs.length == 3</li><li>1 &lt;= costs[i] &lt;= 1000</li></ul><p><strong>分析</strong></p><p>状态转移方程：</p><ul><li>如果 i 不在 days中，<code>dp[i] = dp[i-1]</code></li><li>如果 i 在 days中，<code>dp[i] = min(dp[i-1]+costs[0], dp[i-7]+costs[1], dp[i-30]+costs[2])</code></li></ul><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastDay = days[days.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">boolean</span>[] dayIncluded = <span class="keyword">new</span> <span class="keyword">boolean</span>[lastDay + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> day : days) dayIncluded[day] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lastDay + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lastDay; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dayIncluded[i]) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = dp[i - <span class="number">1</span>] + costs[<span class="number">0</span>];</span><br><span class="line">        min = Math.min(min, dp[Math.max(<span class="number">0</span>, i - <span class="number">7</span>)] + costs[<span class="number">1</span>]);</span><br><span class="line">        min = Math.min(min, dp[Math.max(<span class="number">0</span>, i - <span class="number">30</span>)] + costs[<span class="number">2</span>]);</span><br><span class="line">        dp[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[lastDay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只有两个键的键盘-Medium"><a href="#只有两个键的键盘-Medium" class="headerlink" title="只有两个键的键盘 Medium"></a>只有两个键的键盘 Medium</h4><p><strong>题目</strong></p><p>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p><ol><li>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。</li><li>Paste (粘贴) : 你可以粘贴你上一次复制的字符。</li></ol><p>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">最初, 我们只有一个字符 &#39;A&#39;。</span><br><span class="line">第 1 步, 我们使用 Copy All 操作。</span><br><span class="line">第 2 步, 我们使用 Paste 操作来获得 &#39;AA&#39;。</span><br><span class="line">第 3 步, 我们使用 Paste 操作来获得 &#39;AAA&#39;。</span><br></pre></td></tr></table></figure><p>说明: n 的取值范围是 [1, 1000] 。</p><p><strong>分析</strong></p><p>令C=Copy All，P=Paste。</p><p>如果 n 是一个质数，那么只能通过 CPPP… 来获得，其中包括 1个C 与 n-1个P，一共 n 次操作。<br>如果 n 是 一个合数，例如 n=15=5*3，那么我们可以先得到一个5，然后再进行 CPP 获得 15；或者先得到一个 3，然后进行 CPPPP 获得 15。此时的状态转移方程是：</p><p>$$dp[i] = min(dp[j_1]+(i/j_1), dp[j_2]+(i/j_2), … , dp[j_k]+(i/j_k))$$</p><p>其中$j_1, j_2, … , j_k$均可以被$i$整除。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[j] + (i / j));</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i / j] + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上述代码并不是最优的，可以证明当$j$是合数$i$的最大因子时，<code>dp[i] = dp[j] + (i / j)</code>有最小结果，这部分不是重点，就不展开了，相关代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i / <span class="number">2</span>; j &gt; <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = dp[j] + (i / j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全平方数-Medium"><a href="#完全平方数-Medium" class="headerlink" title="完全平方数 Medium"></a>完全平方数 Medium</h4><p><strong>题目</strong></p><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3</span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>其实就是一个Coin Change问题，此时的coins就是小于i的所有完全平方数。</p><p>状态转移方程如下：<code>dp[i] = min(dp[i-1], dp[i-4], dp[i-9], ...) + 1</code></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最后一块石头的重量-II-Medium"><a href="#最后一块石头的重量-II-Medium" class="headerlink" title="最后一块石头的重量 II Medium"></a>最后一块石头的重量 II Medium</h4><p><strong>题目</strong></p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><ul><li>如果 x == y，那么两块石头都会被完全粉碎；</li><li>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</li></ul><p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000</li></ul><p><strong>分析</strong></p><p>这个问题等价于将所有石头分成两组，并且这两组重量的差异值diff是最小的。</p><p>(1) S1 + S2  = S<br>(2) S1 - S2 = diff</p><p>==&gt; diff = S - 2 * S2  ==&gt; 最小化diff等价于最大化S2。</p><p>因此我们需要最大化 S2，其中 S2 的范围在0至S/2之间。（其实就是<strong>0-1背包问题</strong>）</p><p>这里多写一点。首先我们使用一个二维数组<code>dp[i][j]</code>表示如下含义：使用前 i 种已经出现的石头，在背包容量为 j 的情况下，能得到的最大值。我们有如下状态转移方程：</p><ul><li>如果stones[i] &gt; j，证明石头 i 放不下，因此<code>dp[i][j] = dp[i-1][j]</code></li><li>如果stones[i] &lt;= j，此时既可以放石头 i，也可以不放，有<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-stones[i]] + stones[i])</code></li></ul><p>上述更新过程只和上一行有关，因此我们可以对空间更进一步的优化：只使用一行，也就是使用一维的dp数组在每轮迭代中复用。但是我们注意到更新<code>dp[j]</code>的时候会用到<code>dp[j-stones[i]]</code>，先更新左边的值会出现问题，因此我们可以从右向左更新！</p><p>此时我们有如下状态转移方程：</p><ul><li>如果stones[i] &gt; j，<code>dp[j]不变</code></li><li>如果stones[i] &lt;= j，<code>dp[j] = max(dp[j], dp[j-stones[i]] + stones[i])</code></li></ul><blockquote><p>对于背包问题，在崔添翼大佬的 <a href="https://github.com/tianyicui/pack" target="_blank" rel="noopener">背包九讲</a> 中讲的非常棒，非常值得一看。为了方便可以在 <a href="http://image.yingzq.com/files/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2V2.pdf" target="_blank" rel="noopener">这里</a> 在线阅读。</p></blockquote><p><strong>Java代码</strong></p><p>使用二维dp数组的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) sum += stone;</span><br><span class="line">    <span class="keyword">int</span> n = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[stones.length + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= stones.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - <span class="number">2</span> * dp[stones.length][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一维dp数组的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) sum += stone;</span><br><span class="line">    <span class="keyword">int</span> n = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= stone; j--) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - stone] + stone);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - <span class="number">2</span> * dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三角形最小路径和-Medium"><a href="#三角形最小路径和-Medium" class="headerlink" title="三角形最小路径和 Medium"></a>三角形最小路径和 Medium</h4><p><strong>题目</strong></p><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p><strong>示例</strong></p><p>例如，给定三角形：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p>说明：</p><p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p><p><strong>分析</strong></p><p>首先先不考虑任何优化，我们自上而下的考虑，建立<code>dp[i][j]</code>，代表到达第 i 行、第 j 列位置的最小路径和。有如下转移方程：</p><p><code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]</code></p><p>最后的结果是最后一行的最小值，即<code>result = min(dp[last_row][j]), j = 0, 1, 2 ...</code>。</p><p>因为<code>dp[i][j]</code>只用到了<code>dp[i-1][j-1], dp[i-1][j]</code>，很容易想到的就只使用一维的dp数组：</p><p><code>dp[j] = min(dp[j-1], dp[j]) + triangle[i][j], j = i, i-1, ... , 0</code>。</p><p>另外，这一题其实自下而上的考虑更加简单，此时的状态转移方程为：</p><p><code>dp[j] = min(dp[j], dp[j+1]) + triangle[i][j], j = 0, 1, 2, ... , i</code></p><p>最后的结果就是<code>dp[0]</code>，即<code>result = dp[0]</code>。</p><blockquote><p>注意体会将二维dp数组优化为一维dp数组的时候， j 什么时候升序遍历，什么时候降序遍历。</p></blockquote><p><strong>Java代码</strong></p><p>自上而下使用二维dp数组的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + triangle.get(i).get(j);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + triangle.get(i).get(j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        res = Math.min(res, dp[n - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自上而下使用一维dp数组的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] += triangle.get(i).get(j);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>] + triangle.get(i).get(j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res = Math.min(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自下而上使用一维dp数组的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>还有一点可以优化：并不用建立dp数组，直接借助triangle的最后一行原地修改。</p></blockquote><h4 id="一和零-Medium"><a href="#一和零-Medium" class="headerlink" title="一和零 Medium"></a>一和零 Medium</h4><p><strong>题目</strong></p><p>在计算机界中，我们总是追求用有限的资源获取最大的收益。</p><p>现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。</p><p>你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p><p>注意:</p><ul><li>给定 0 和 1 的数量都不会超过 100。</li><li>给定字符串数组的长度不会超过 600。</li></ul><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: Array &#x3D; &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 5, n &#x3D; 3</span><br><span class="line">输出: 4</span><br><span class="line">解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot; 。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>仔细想想，其实就是一个 <strong>二维费用的0-1背包问题</strong> 。</p><p>令<code>dp[k][i][j]</code>代表：利用前 k 个字符串，i 个 0，j 个 1 所能组合出的最大字符串数量。</p><p>假设第 k 个字符串有 c_0 个 0，c_1 个 1，得出状态转移方程如下：</p><p><code>dp[k][i][j] = max(dp[k-1][i][j], dp[k-1][i - c_0][j - c_1] + 1)</code></p><p>同样的，和0-1背包问题一样，我们可以将三维的dp数组优化为二维，需要注意的是 <strong>i 和 j 均需要逆序遍历</strong>。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cnt = count(str);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= cnt[<span class="number">0</span>] &amp;&amp; j &gt;= cnt[<span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = Math.max(dp[i][j], dp[i - cnt[<span class="number">0</span>]][j - cnt[<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] count(String str) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            cnt[c - <span class="string">'0'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大正方形-Medium"><a href="#最大正方形-Medium" class="headerlink" title="最大正方形 Medium"></a>最大正方形 Medium</h4><p><strong>题目</strong></p><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>令<code>dp[i][j]</code>表示以 (i, j) 为右下角的最大正方形的边长，得到状态转移方程：</p><p><code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>], Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">            maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="地下城游戏-Hard"><a href="#地下城游戏-Hard" class="headerlink" title="地下城游戏 Hard"></a>地下城游戏 Hard</h4><p><strong>题目</strong></p><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p><p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><div align=left><img src="http://image.yingzq.com/img/20200401110438.png" width="220" /></div><p>说明:</p><ul><li>骑士的健康点数没有上限。</li><li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li></ul><p><strong>分析</strong></p><p>如果从左上角迭代至右下角，在每个位置 (i, j) 需要记录：</p><ol><li>到达此位置的最小生命值</li><li>到达此位置还剩下的生命值（这里并不是取此时剩下的最大生命值，计算起来似乎还需要未来的状态）</li></ol><p>这似乎难以实现…</p><p>如果反向遍历，从右下角迭代至左上角，会发现只需要记录到达该位置的最小生命值。因为到达该位置还剩下的生命值一定是大于等于最小生命值的。</p><p>用<code>dp[i][j]</code>表示 (i, j) 所需要的最小生命值，可得到状态转移方程：</p><p><code>dp[i][j] = min(dp[i+1][j], dp[i][j+1]) + (-dungeon[i][j])</code></p><p>其中如果<code>dp[i][j] &lt;= 0</code>，令<code>dp[i][j] = 1</code>。</p><p>最后，可以原地进行修改降低空间复杂度。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dungeon == <span class="keyword">null</span> || dungeon.length == <span class="number">0</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = dungeon.length, n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">    dungeon[m - <span class="number">1</span>][n - <span class="number">1</span>] = dungeon[m - <span class="number">1</span>][n - <span class="number">1</span>] &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">1</span> - dungeon[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> need = dungeon[i + <span class="number">1</span>][n - <span class="number">1</span>] - dungeon[i][n - <span class="number">1</span>];</span><br><span class="line">        dungeon[i][n - <span class="number">1</span>] = need &lt;= <span class="number">0</span> ? <span class="number">1</span> : need;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> need = dungeon[m - <span class="number">1</span>][j + <span class="number">1</span>] - dungeon[m - <span class="number">1</span>][j];</span><br><span class="line">        dungeon[m - <span class="number">1</span>][j] = need &lt;= <span class="number">0</span> ? <span class="number">1</span> : need;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> need = Math.min(dungeon[i + <span class="number">1</span>][j], dungeon[i][j + <span class="number">1</span>]) - dungeon[i][j];</span><br><span class="line">            dungeon[i][j] = need &lt;= <span class="number">0</span> ? <span class="number">1</span> : need;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dungeon[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Distinct-Ways"><a href="#Distinct-Ways" class="headerlink" title="Distinct Ways"></a>Distinct Ways</h2><h3 id="Statement-1"><a href="#Statement-1" class="headerlink" title="Statement"></a>Statement</h3><p>Given a target find a number of distinct ways to reach the target.</p><h3 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach"></a>Approach</h3><p>Sum all possible ways to reach the current state.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">routes[i] &#x3D; routes[i-1] + routes[i-2], ... , + routes[i-k]</span><br></pre></td></tr></table></figure><p>Generate sum for all values in the target and return the value for the target.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ways.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (ways[j] &lt;= i) &#123;</span><br><span class="line">           dp[i] += dp[i - ways[j]];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note:</strong> Some questions point out the number of repetitions, in that case, add one more loop to simulate every repetition.</p></blockquote><h3 id="Similar-Problems-1"><a href="#Similar-Problems-1" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p>列举如下：</p><ul><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a> <strong>Easy</strong></li><li><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/" target="_blank" rel="noopener">1155. 掷骰子的N种方法</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/knight-probability-in-chessboard/" target="_blank" rel="noopener">688. “马”在棋盘上的概率</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494. 目标和</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. 组合总和 Ⅳ</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/knight-dialer/" target="_blank" rel="noopener">935. 骑士拨号器</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/domino-and-tromino-tiling/" target="_blank" rel="noopener">790. 多米诺和托米诺平铺</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/" target="_blank" rel="noopener">673. 最长递增子序列的个数</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/out-of-boundary-paths/" target="_blank" rel="noopener">576. 出界的路径数</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" target="_blank" rel="noopener">1269. 停在原地的方案数</a> <strong>Hard</strong></li><li><a href="https://leetcode-cn.com/problems/count-vowels-permutation/" target="_blank" rel="noopener">1220. 统计元音字母序列的数目</a> <strong>Hard</strong></li></ul><h4 id="爬楼梯-Easy"><a href="#爬楼梯-Easy" class="headerlink" title="爬楼梯 Easy"></a>爬楼梯 Easy</h4><p><strong>题目</strong></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p><strong>分析</strong></p><p>状态转移方程<code>dp[i] = dp[i-1] + dp[i-2]</code>。</p><p>其中空间可以优化为$O(1)$。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>, second = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = first;</span><br><span class="line">            first = second;</span><br><span class="line">            second = first + temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同路径-Medium"><a href="#不同路径-Medium" class="headerlink" title="不同路径 Medium"></a>不同路径 Medium</h4><p><strong>题目</strong></p><p>一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>问总共有多少条不同的路径？</p><p>提示：</p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10 ^ 9</li></ul><p><strong>分析</strong></p><p>首先考虑二维dp数组，有<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>。</p><p>很明显，可以优化为一维dp数组，有<code>dp[j] = dp[j] + dp[j-1], j = 1, 2, 3, ... , n</code>。</p><p>注意，这里 j 的遍历是升序，因为<code>dp[i][j]</code>用到的是<code>dp[i][j-1]</code>而不是<code>dp[i-1][j-1]</code>，类似于完全背包问题和0-1背包问题的区别。</p><blockquote><p>本题其实可以用排列组合来做，在这里就不探讨了。</p></blockquote><p><strong>Java代码</strong></p><p>使用二维dp数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一维dp数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同路径-II-Medium"><a href="#不同路径-II-Medium" class="headerlink" title="不同路径 II Medium"></a>不同路径 II Medium</h4><p><strong>题目</strong></p><p>一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>说明：</p><ul><li>网格中的障碍物和空位置分别用 1 和 0 来表示。</li><li>m 和 n 的值均不超过 100。</li></ul><p><strong>分析</strong></p><p>解法其实和上一题很像，就不解释了。</p><p>有个优化的地方是，现在的输入是一个二维数组，所以可以直接在输入数组上进行操作，空间复杂度为$O(1)$。</p><p><strong>Java代码</strong></p><p>利用一维dp数组相关代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] row : obstacleGrid) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[j] == <span class="number">1</span>) dp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里dp数组建立 n 大小以及 n+1 大小都是可以的。</p></blockquote><p>原地更新相关代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> - grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) grid[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> grid[i][<span class="number">0</span>] = grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>) grid[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> grid[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) grid[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="掷骰子的N种方法-Medium"><a href="#掷骰子的N种方法-Medium" class="headerlink" title="掷骰子的N种方法 Medium"></a>掷骰子的N种方法 Medium</h4><p><strong>题目</strong></p><p>这里有 d 个一样的骰子，每个骰子上都有 f 个面，分别标号为 1, 2, …, f。</p><p>我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。</p><p>如果需要掷出的总点数为 target，请你计算出有多少种不同的组合情况（所有的组合情况总共有 f^d 种），模 10^9 + 7 后返回。</p><p><strong>分析</strong></p><p>直接给出状态转移方程<code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + ... dp[i-1][j-k], k = min(f, j)</code></p><p>很明显，可以空间压缩，只需要使用一维dp数组即可。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= f &amp;&amp; j &lt;= target; j++) dp[j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; d; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            dp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f &amp;&amp; k &lt;= j; k++) &#123;</span><br><span class="line">                dp[j] = (dp[j] + dp[j - k]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="“马”在棋盘上的概率-Medium"><a href="#“马”在棋盘上的概率-Medium" class="headerlink" title="“马”在棋盘上的概率 Medium"></a>“马”在棋盘上的概率 Medium</h4><p><strong>题目</strong></p><p>已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。</p><p>现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。</p><p>如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。</p><div align=left><img src="http://image.yingzq.com/img/20200401172548.png" width="230" /></div><p>现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。</p><p>求移动结束后，“马” 仍留在棋盘上的概率。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3, 2, 0, 0</span><br><span class="line">输出: 0.0625</span><br><span class="line">解释:</span><br><span class="line">输入的数据依次为 N, K, r, c</span><br><span class="line">第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。</span><br><span class="line">对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。</span><br><span class="line">所以 “马” 在结束后仍在棋盘上的概率为 0.0625。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>假设<code>dp0[i][j]</code>表示 k - 1次移动后在 (i, j) 位置的路径数，<code>dp1[i][j]</code>则表示是 k 次移动后。</p><p>令<code>dirs = [[2,1], [2,-1], [-2,1], ...]</code>，有</p><p><code>dp1[i][j] = sum(dp0[i + dirs[k][0]][j + dirs[k][1]])</code></p><p>其中坐标必须都是有效的。另外，<code>dirs</code>数组有对称性，所以加号减号是等效的。</p><p>本题一共进行了 K 轮移动，使用<code>dp0</code>和<code>dp1</code>循环更新更加省空间。另外，为了防止值溢出的问题，这些数组都是<code>double类型</code>的。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">2</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">2</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">2</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">double</span>[][] dp0 = <span class="keyword">new</span> <span class="keyword">double</span>[N][N];</span><br><span class="line">        dp0[r][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> round = <span class="number">0</span>; round &lt; K; round++) &#123;</span><br><span class="line">            <span class="keyword">double</span>[][] dp1 = <span class="keyword">new</span> <span class="keyword">double</span>[N][N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                        <span class="keyword">int</span> oldRow = i + dir[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> oldCol = j + dir[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (!isValid(oldRow, oldCol, N)) <span class="keyword">continue</span>;</span><br><span class="line">                        dp1[i][j] += dp0[oldRow][oldCol];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp0 = dp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                cnt += dp0[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt / Math.pow(<span class="number">8</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; N &amp;&amp; j &lt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="目标和-Medium"><a href="#目标和-Medium" class="headerlink" title="目标和 Medium"></a>目标和 Medium</h4><p><strong>题目</strong></p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>数组非空，且长度不会超过20。</li><li>初始的数组的和不会超过1000。</li><li>保证返回的最终结果能被32位整数存下</li></ul><p><strong>分析</strong></p><p>这是一道非常经典的题！</p><p>方法1：DFS</p><p>每个数有两种情况：+num 和 -num。所以对所有的情况进行遍历，在终止时判断<code>sum == target</code>，如果为true则<code>cnt++</code>，返回最终的cnt。</p><p>方法2：不假思索的DP</p><p>直接对这个问题建立状态转移方程：<code>dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]</code></p><p>可以进行空间压缩，使用两个一维数组来代替该二维dp数组。</p><p>方法3：略加变换的DP</p><p>写代码时会发现，方法2的写起来没那么舒服，可以转为如下方程：</p><p><code>dp[i][j + nums[i]] += dp[i - 1][j]</code>，<code>dp[i][j - nums[i]] += dp[i - 1][j]</code></p><p>方法4：转为0-1背包问题</p><p>令P表示添加了+号的集合，N表示添加了-号的集合。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum(P) - sum(N) &#x3D; target, sum(nums) &#x3D; sum(P) + sum(N) &#x3D;&#x3D;&gt;</span><br><span class="line">2 * sum(P) &#x3D; target + sum(nums)</span><br></pre></td></tr></table></figure><p>可以看出右边是个常数，因此这就是一个<strong>0-1背包问题</strong>！遇到这种题，可以先简单的进行数学推导，寻找原问题的等价问题，也许就能柳暗花明又一村。</p><p><strong>Java代码</strong></p><p>方法2代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span> (S &lt; -sum || S &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line">    dp[sum] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = -sum; j &lt;= sum; j++) &#123;</span><br><span class="line">            next[j + sum] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (j - num &gt;= -sum) next[j + sum] += dp[j - num + sum];</span><br><span class="line">            <span class="keyword">if</span> (j + num &lt;= sum) next[j + sum] += dp[j + num + sum];</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[S + sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span> (S &lt; -sum || S &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line">    dp[sum] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span> * sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                next[j + num] += dp[j];</span><br><span class="line">                next[j - num] += dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[S + sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span> (S &lt; -sum || S &gt; sum || (S + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = (S + sum) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= num; j--) &#123;</span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合总和-Ⅳ-Medium"><a href="#组合总和-Ⅳ-Medium" class="headerlink" title="组合总和 Ⅳ Medium"></a>组合总和 Ⅳ Medium</h4><p><strong>题目</strong></p><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">target &#x3D; 4</span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line">因此输出为 7。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>完全背包问题。本题需要考虑顺序，即 (1,2) 和 (2,1) 属于两种情况，此时 nums 放外面，target 放里面进行循环。</p><p>延伸一下：如果是不考虑顺序，即 (1,2) 和(2,1) 属于一种情况，此时只需要把 target 放外面，nums 放里面进行循环即可。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= num) &#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="骑士拨号器-Medium"><a href="#骑士拨号器-Medium" class="headerlink" title="骑士拨号器 Medium"></a>骑士拨号器 Medium</h4><p><strong>题目</strong></p><p>国际象棋中的骑士可以按下图所示进行移动：</p><div align=left><img src="http://image.yingzq.com/img/20200402221334.png" width="380" /></div><p>这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。</p><p>每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。</p><p>你能用这种方式拨出多少个不同的号码？</p><p>因为答案可能很大，所以输出答案模 10^9 + 7。</p><p><strong>分析</strong></p><p>同样是一个重复K次的问题，可以循环使用两个一维dp数组来代替二维的dp数组。</p><p>这里需要明白<code>dp[i]</code>的含义：拨码 k 次后 “骑士” 落在 i 位置的路径数。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knightDialer</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] moves = &#123;&#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>&#125;, &#123;&#125;,</span><br><span class="line">                     &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> round = <span class="number">1</span>; round &lt; N; round++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> pos : moves[i]) &#123;</span><br><span class="line">                next[i] += dp[pos];</span><br><span class="line">                next[i] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : dp) &#123;</span><br><span class="line">        res += count;</span><br><span class="line">        res %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分割等和子集-Medium"><a href="#分割等和子集-Medium" class="headerlink" title="分割等和子集 Medium"></a>分割等和子集 Medium</h4><p><strong>题目</strong></p><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:</p><ul><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200</li></ul><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>经典的0-1背包问题。</p><p>建立一维 bool 类型 dp 数组，有状态转移方程：</p><p><code>dp[j] = dp[j] || dp[j - nums[i]]</code></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= num; j--) &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多米诺和托米诺平铺-Medium"><a href="#多米诺和托米诺平铺-Medium" class="headerlink" title="多米诺和托米诺平铺 Medium"></a>多米诺和托米诺平铺 Medium</h4><p><strong>题目</strong></p><p>有两种形状的瓷砖：一种是 2x1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XX  &lt;- 多米诺</span><br><span class="line"></span><br><span class="line">XX  &lt;- &quot;L&quot; 托米诺</span><br><span class="line">X</span><br></pre></td></tr></table></figure><p>给定 N 的值，有多少种方法可以平铺 2 x N 的面板？返回值 mod 10^9 + 7。</p><p>（平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。）</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">下面列出了五种不同的方法，不同字母代表不同瓷砖：</span><br><span class="line">XYZ XXZ XYY XXY XYY</span><br><span class="line">XYZ YYZ XZZ XYY XXY</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>N 的范围是 [1, 1000]</li></ul><p><strong>分析</strong></p><p>直接贴一个图进行解释，图的来源是 LeetCode Discuss 区的 <a href="https://leetcode.com/problems/domino-and-tromino-tiling/discuss/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1%2Bdpn-3" target="_blank" rel="noopener">高票答案</a> 。</p><div align=left><img src="http://image.yingzq.com/img/20200403105820.png" width="700" /></div><p>根据上图，得到状态转移方程：<code>dp[i] = 2 * dp[i-1] + dp[i-3]</code></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTilings</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">3</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">long</span> mod = (<span class="keyword">long</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i] = (<span class="number">2</span> * dp[i - <span class="number">1</span>] + dp[i - <span class="number">3</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于求<code>dp[i]</code>只需要<code>dp[i-1]</code>和<code>dp[i-3]</code>并且只使用一次，所以其实只需要$O(1)$的空间就可以了，具体代码就不贴了。</p></blockquote><h4 id="最长递增子序列的个数-Medium"><a href="#最长递增子序列的个数-Medium" class="headerlink" title="最长递增子序列的个数 Medium"></a>最长递增子序列的个数 Medium</h4><p><strong>题目</strong></p><p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</span><br></pre></td></tr></table></figure><p>注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。</p><p><strong>分析</strong></p><p>使用2个一维dp数组：<code>dp[i]</code>表示以 nums[i] 结尾的最大递增子序列的<code>长度</code>，<code>cnt[i]</code>表示以 nums[i] 结尾的最大递增子序列的<code>个数</code>。</p><p>其中<code>dp[i] = max(dp[j]) + 1, where 0 &lt;= j &lt; i &amp;&amp; nums[j] &lt; nums[i]</code>，是一个标准的 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">LIS问题</a> 。</p><p><code>cnt[i]</code>会随着<code>dp[i],dp[j]</code>情况的不同而变化，详情可以看代码。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    Arrays.fill(cnt, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] + <span class="number">1</span> == dp[i]) &#123;</span><br><span class="line">                    cnt[i] += cnt[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">                    cnt[i] = cnt[j];</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == maxLen) res += cnt[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = dp[i];</span><br><span class="line">            res = cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出界的路径数-Medium"><a href="#出界的路径数-Medium" class="headerlink" title="出界的路径数 Medium"></a>出界的路径数 Medium</h4><p><strong>题目</strong></p><p>给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动 N 次。找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 109 + 7 的值。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: m &#x3D; 2, n &#x3D; 2, N &#x3D; 2, i &#x3D; 0, j &#x3D; 0</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p>解释:</p><div align=left><img src="http://image.yingzq.com/img/20200403145410.png" width="500" /></div><p>说明:</p><ul><li>球一旦出界，就不能再被移动回网格内。</li><li>网格的长度和高度在 [1,50] 的范围内。</li><li>N 在 [0,50] 的范围内。</li></ul><p><strong>分析</strong></p><p>同样是一个重复进行 k 次试验的问题，可以循环使用两个二维的dp数组来降低空间复杂度。</p><p>每次移动后，如果出界则进行记录，否则<code>next[nr][nc] += dp[r][c]</code>。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> round = <span class="number">0</span>; round &lt; N; round++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] next = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[r][c] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nr = r + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> nc = c + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == m || nc == n) &#123;</span><br><span class="line">                        res = (res + dp[r][c]) % mod;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        next[nr][nc] = (next[nr][nc] + dp[r][c]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="停在原地的方案数-Hard"><a href="#停在原地的方案数-Hard" class="headerlink" title="停在原地的方案数 Hard"></a>停在原地的方案数 Hard</h4><p><strong>题目</strong></p><p>有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。</p><p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p><p>给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。</p><p>由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：steps &#x3D; 3, arrLen &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。</span><br><span class="line">向右，向左，不动</span><br><span class="line">不动，向右，向左</span><br><span class="line">向右，不动，向左</span><br><span class="line">不动，不动，不动</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= steps &lt;= 500</li><li>1 &lt;= arrLen &lt;= 10^6</li></ul><p><strong>分析</strong></p><p>同样是一个重复 k 次试验的问题，可以循环使用两个一维dp数组来节省空间。</p><p>有<code>next[i] = dp[i-1] + dp[i] + dp[i+1]</code>。</p><p>需要注意的是本题的 arrLen可能会很大，steps 却不是很大。最后要求的是停在索引 0 处的方案，如果指针移动的太远，最后就回不来了，因此可以做一定的剪枝，即每次无需循环到 arrLen-1，只需要循环到<code>min(arrLen-1, remainSteps)</code>。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arrLen];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; steps; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[arrLen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Math.min(steps - k, arrLen - <span class="number">1</span>); i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> temp = dp[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) temp += dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; arrLen - <span class="number">1</span>) temp += dp[i + <span class="number">1</span>];</span><br><span class="line">            temp %= mod;</span><br><span class="line">            next[i] = (<span class="keyword">int</span>) temp;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统计元音字母序列的数目-Hard"><a href="#统计元音字母序列的数目-Hard" class="headerlink" title="统计元音字母序列的数目 Hard"></a>统计元音字母序列的数目 Hard</h4><p><strong>题目</strong></p><p>给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：</p><p>字符串中的每个字符都应当是小写元音字母（’a’, ‘e’, ‘i’, ‘o’, ‘u’）<br>每个元音 ‘a’ 后面都只能跟着 ‘e’<br>每个元音 ‘e’ 后面只能跟着 ‘a’ 或者是 ‘i’<br>每个元音 ‘i’ 后面 不能 再跟着另一个 ‘i’<br>每个元音 ‘o’ 后面只能跟着 ‘i’ 或者是 ‘u’<br>每个元音 ‘u’ 后面只能跟着 ‘a’<br>由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：10</span><br><span class="line">解释：所有可能的字符串分别是：&quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; 和 &quot;ua&quot;。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>虽然是 Hard 题，但是还是很容易想到解法的：建立两个一维数组，不断的根据规则循环更新。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">5</span>];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> mod = <span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span>[] next = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">5</span>];</span><br><span class="line">        next[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">        next[<span class="number">1</span>] = (dp[<span class="number">0</span>] + dp[<span class="number">2</span>]) % mod;</span><br><span class="line">        next[<span class="number">2</span>] = (dp[<span class="number">0</span>] + dp[<span class="number">1</span>] + dp[<span class="number">3</span>] + dp[<span class="number">4</span>]) % mod;</span><br><span class="line">        next[<span class="number">3</span>] = (dp[<span class="number">2</span>] + dp[<span class="number">4</span>]) % mod;</span><br><span class="line">        next[<span class="number">4</span>] = dp[<span class="number">0</span>];</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> num : dp) res += num;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (res % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Merging-Intervals"><a href="#Merging-Intervals" class="headerlink" title="Merging Intervals"></a>Merging Intervals</h2><h3 id="Statement-2"><a href="#Statement-2" class="headerlink" title="Statement"></a>Statement</h3><p>Given a set of numbers find an optimal solution for a problem considering the current number and the best you can get from the left and right sides.</p><h3 id="Approach-2"><a href="#Approach-2" class="headerlink" title="Approach"></a>Approach</h3><p>Find all optimal solutions for every interval and return the best possible answer.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from i to j</span></span><br><span class="line">dp[i][j] = dp[i][k] + result[k] + dp[k+<span class="number">1</span>][j]</span><br></pre></td></tr></table></figure><p>Get the best from the left and right sides and add a solution for the current position.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; n; l++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - l; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + result[k] + dp[k+<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="Similar-Problems-2"><a href="#Similar-Problems-2" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p>列举如下：</p><ul><li><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/" target="_blank" rel="noopener">1039. 多边形三角剖分的最低得分</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/" target="_blank" rel="noopener">375. 猜数字大小 II</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/" target="_blank" rel="noopener">1000. 合并石头的最低成本</a> <strong>Hard</strong></li><li><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a> <strong>Hard</strong></li></ul><h4 id="不同的二叉搜索树-Medium"><a href="#不同的二叉搜索树-Medium" class="headerlink" title="不同的二叉搜索树 Medium"></a>不同的二叉搜索树 Medium</h4><p><strong>题目</strong></p><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>先定义两个函数：</p><p><code>G(n)</code>：长度为 n 的所有不同BST的总数。<br><code>F(i, n), 1 &lt;= i &lt;= n</code>：以 i 为根节点，长度为 n 的所有不同BST的总数。</p><p>可以得到<code>G(n) = sum(F(i, n)), 1 &lt;= i &lt;= n</code>，其中<code>F(i, n) = G(i-1) * G(n-i)</code>。</p><p>用一维dp数组来表示<code>G(n)</code>，便得到如下状态转移方程：</p><p><code>dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[0]</code></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多边形三角剖分的最低得分-Medium"><a href="#多边形三角剖分的最低得分-Medium" class="headerlink" title="多边形三角剖分的最低得分 Medium"></a>多边形三角剖分的最低得分 Medium</h4><p><strong>题目</strong></p><p>给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], …, A[N-1]。</p><p>假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。</p><p>返回多边形进行三角剖分后可以得到的最低分。</p><p><strong>示例</strong></p><div align=left><img src="http://image.yingzq.com/img/20200403205818.png" width="300" /></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,7,4,5]</span><br><span class="line">输出：144</span><br><span class="line">解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 &#x3D; 245，或 3*4*5 + 3*4*7 &#x3D; 144。最低分数为 144。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>3 &lt;= A.length &lt;= 50</li><li>1 &lt;= A[i] &lt;= 100</li></ul><p><strong>分析</strong></p><p>令<code>dp[i][j]</code>表示<code>A[i] ~ A[j]</code>所形成的三角形的最小面积，其中<code>A[i]</code>和<code>A[j]</code>之间一定是相连的。</p><p>得到状态转移方程：<code>dp[i][j] = min(dp[i][k] + dp[k][j] + A[i]*A[k]*A[j])</code></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">2</span>; d &lt; n; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - d; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + d;</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + A[i] * A[j] * A[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="猜数字大小-II-Medium"><a href="#猜数字大小-II-Medium" class="headerlink" title="猜数字大小 II Medium"></a>猜数字大小 II Medium</h4><p><strong>题目</strong></p><p>我们正在玩一个猜数游戏，游戏规则如下：</p><p>我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。</p><p>每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。</p><p>然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; 10, 我选择了8.</span><br><span class="line"></span><br><span class="line">第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。</span><br><span class="line">第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。</span><br><span class="line">第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。</span><br><span class="line"></span><br><span class="line">游戏结束。8 就是我选的数字。</span><br><span class="line"></span><br><span class="line">你最终要支付 5 + 7 + 9 &#x3D; 21 块钱。</span><br></pre></td></tr></table></figure><p>给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。</p><p><strong>分析</strong></p><p>首先，二分查找法并不是最优的选择，例如对于<code>[1,2,3,4,5], n = 5</code>，利用二分查找需要 <code>3 + 4 = 7</code>，但是其实第一次可以猜 4，这样最少只需要<code>4 + 2 = 6</code>。</p><p>令<code>dp[i][j]</code>代表在区间 (i, j) 中猜数字至少需要的现金。</p><p>状态转移方程：<code>dp[i][j] = min(k + max(dp[i][k-1], dp[k+1][j]))</code></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; n; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - d; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + d;</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], k + Math.max(dp[i][k - <span class="number">1</span>], dp[k + <span class="number">1</span>][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并石头的最低成本-Hard"><a href="#合并石头的最低成本-Hard" class="headerlink" title="合并石头的最低成本 Hard"></a>合并石头的最低成本 Hard</h4><p><strong>题目</strong></p><p>有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。</p><p>每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。</p><p>找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：stones &#x3D; [3,2,4,1], K &#x3D; 2</span><br><span class="line">输出：20</span><br><span class="line">解释：</span><br><span class="line">从 [3, 2, 4, 1] 开始。</span><br><span class="line">合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。</span><br><span class="line">合并 [4, 1]，成本为 5，剩下 [5, 5]。</span><br><span class="line">合并 [5, 5]，成本为 10，剩下 [10]。</span><br><span class="line">总成本 20，这是可能的最小值。</span><br><span class="line"></span><br><span class="line">输入：stones &#x3D; [3,2,4,1], K &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line">解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>首先该题贪婪算法是存在问题的，例如对于<code>[6,4,4,6]</code>，用贪婪算法的结果是42，其实最优是可以达到40的。</p><p>定义<code>dp[i][j]</code>代表将 <code>i ~ j</code> 位置的石头合并为最少堆的最低成本。</p><p>得出状态转移方程：<code>dp[i][j] = min(sum[i][j] + dp[i][k] + dp[k + 1][j]) (i &lt;= k &lt; j)</code></p><p><strong>总结下DP问题的4要素：</strong></p><ol><li>State：dp数组意味着什么</li><li>Function：状态转移方程</li><li>Init：初始值的设定</li><li>Answer：返回的答案是什么</li></ol><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mergeStones</span><span class="params">(<span class="keyword">int</span>[] stones, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = stones.length;</span><br><span class="line">    <span class="keyword">if</span> ((n - <span class="number">1</span>) % (K - <span class="number">1</span>) &gt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] prefix = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + stones[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = K; m &lt;= n; m++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + m - <span class="number">1</span>;</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid = i; mid &lt; j; mid += K - <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], dp[i][mid] + dp[mid + <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span> ((j - i) % (K - <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] += prefix[j + <span class="number">1</span>] - prefix[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TODO: 该题还是没能完全看懂，先留个坑。</p></blockquote><h4 id="戳气球-Hard"><a href="#戳气球-Hard" class="headerlink" title="戳气球 Hard"></a>戳气球 Hard</h4><p><strong>题目</strong></p><p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><ul><li>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</li></ul><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167</span><br><span class="line">解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins &#x3D;  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   &#x3D; 167</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>同样的，令<code>dp[i][j]</code>代表从<code>i ~ j</code>之间的气球戳破后能得到的最大硬币数量，这里不包括边界更好处理，即不包括 i 和 j 位置。</p><p>状态转移方程：<code>dp[i][j] = max(dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])</code></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] iNums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[iNums.length + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : iNums) <span class="keyword">if</span> (x &gt; <span class="number">0</span>) nums[n++] = x;</span><br><span class="line">    nums[<span class="number">0</span>] = nums[n++] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">2</span>; d &lt; n; d++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - d; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DP-on-Strings"><a href="#DP-on-Strings" class="headerlink" title="DP on Strings"></a>DP on Strings</h2><p>General problem statement for this pattern can vary but most of the time you are given two strings where lengths of those strings are not big.</p><h3 id="Statement-3"><a href="#Statement-3" class="headerlink" title="Statement"></a>Statement</h3><p>Given two strings <code>s1</code> and <code>s2</code>, return <code>some result</code>.</p><h3 id="Approach-3"><a href="#Approach-3" class="headerlink" title="Approach"></a>Approach</h3><p>Most of the problems on this pattern requires a solution that can be accepted in O(n^2) complexity.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i - indexing string s1</span></span><br><span class="line"><span class="comment">// j - indexing string s2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">       <span class="keyword">if</span> (s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">           dp[i][j] = <span class="comment">/*code*/</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           dp[i][j] = <span class="comment">/*code*/</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you are given one string s the approach may little vary.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; n; l++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - l; i++) &#123;</span><br><span class="line">       <span class="keyword">int</span> j = i + l;</span><br><span class="line">       <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">           dp[i][j] = <span class="comment">/*code*/</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           dp[i][j] = <span class="comment">/*code*/</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Similar-Problems-3"><a href="#Similar-Problems-3" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p>列举如下：</p><ul><li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/" target="_blank" rel="noopener">712. 两个字符串的最小ASCII删除和</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/shortest-common-supersequence/" target="_blank" rel="noopener">1092. 最短公共超序列</a> <strong>Hard</strong></li><li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a> <strong>Hard</strong></li><li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">115. 不同的子序列</a> <strong>Hard</strong></li></ul><h4 id="最长公共子序列-Medium"><a href="#最长公共子序列-Medium" class="headerlink" title="最长公共子序列 Medium"></a>最长公共子序列 Medium</h4><p><strong>题目</strong></p><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列（longest common subsequence, LCS）。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot;</span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure><p>提示:</p><ul><li>1 &lt;= text1.length &lt;= 1000</li><li>1 &lt;= text2.length &lt;= 1000</li><li>输入的字符串只含有小写英文字符</li></ul><p><strong>分析</strong></p><p><code>dp[i][j]</code>表示 text1 长度为 i，text2 长度为 j 时的最长公共子串。</p><p>状态转移方程：</p><ul><li>如果<code>text1[i] == text2[j]</code>，则<code>dp[i][j] = dp[i-1][j-1] + 1</code></li><li>如果<code>text1[i] != text2[j]</code>，则<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></li></ul><p>注意到<code>dp[i][j]</code>只用到<code>dp[i-1][j-1], dp[i][j-1], dp[i-1][j]</code>，因此可以仅使用两个一维dp数组代替原先的二维dp数组。但是如果题目中的字符串比较短，这一步也可以不做；如果在面试时问你空间是否可以继续优化，或者在笔试时提示使用内存过大，那么你可能就需要认真考虑这方面了，在 DP on Strings 问题上很多都可以类似考虑，后面不再提了。</p><p><strong>Java代码</strong></p><p>使用二维dp数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化为一维dp数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                next[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[j] = Math.max(dp[j], next[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个字符串的最小ASCII删除和-Medium"><a href="#两个字符串的最小ASCII删除和-Medium" class="headerlink" title="两个字符串的最小ASCII删除和 Medium"></a>两个字符串的最小ASCII删除和 Medium</h4><p><strong>题目</strong></p><p>给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;sea&quot;, s2 &#x3D; &quot;eat&quot;</span><br><span class="line">输出: 231</span><br><span class="line">解释: 在 &quot;sea&quot; 中删除 &quot;s&quot; 并将 &quot;s&quot; 的值(115)加入总和。</span><br><span class="line">在 &quot;eat&quot; 中删除 &quot;t&quot; 并将 116 加入总和。</span><br><span class="line">结束时，两个字符串相等，115 + 116 &#x3D; 231 就是符合条件的最小和。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>令<code>dp[i][j]</code>表示使 s1 的前 i 字符串和 s2 的前 j 字符串相等时所需删除字符的ASCII值的最小和。</p><p>当<code>s1[i] == s2[j]</code>时，有<code>dp[i][j] = dp[i-1][j-1]</code>；<br>当<code>s1[i] != s2[j]</code>时，有<code>dp[i][j] = min(dp[i-1][j] + s1[i], dp[i][j-1], s2[j])</code>。</p><p>另外，需要注意二维dp数组数组中的初始化问题：不仅要注意<code>dp[0][0]</code>，还要注意所有的<code>dp[i][0]</code>和<code>dp[0][j]</code>。</p><p>本题中，<code>dp[i][0] = s1[1] + s1[2] + ... + s1[i], dp[0][j] = s2[1] + s2[2] + ... + s2[j]</code>。</p><p><strong>Java代码</strong></p><p>写法1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + s1.charAt(i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + s2.charAt(j - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + s1.charAt(i - <span class="number">1</span>), dp[i][j - <span class="number">1</span>] + s2.charAt(j - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i + <span class="number">1</span>][<span class="number">0</span>] = dp[i][<span class="number">0</span>] + s1.charAt(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j + <span class="number">1</span>] = dp[<span class="number">0</span>][j] + s2.charAt(j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.min(dp[i][j + <span class="number">1</span>] + s1.charAt(i), dp[i + <span class="number">1</span>][j] + s2.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>当循环的范围是<code>i = 1 ~ len</code>时，需要用到的是<code>str[i-1]</code>，需要更新的是<code>dp[i]</code>；当循环的范围是<code>i = 0 ~ len-1</code>时，需要用到的是<code>str[i]</code>，需要更新的是<code>dp[i+1]</code>。因此一般有上述两种写法。</p></blockquote><h4 id="回文子串-Medium"><a href="#回文子串-Medium" class="headerlink" title="回文子串 Medium"></a>回文子串 Medium</h4><p><strong>题目</strong></p><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aaa&quot;</span><br><span class="line">输出: 6</span><br><span class="line">说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p><strong>DP解法</strong></p><p>令<code>dp[i][j]</code>代表 <code>i ~ j</code> 位置的子串是否能构成回文。</p><p>状态转移方程：<code>dp[i][j] = s[i] == s[j] &amp;&amp; (j - i &lt; 3 || dp[i+1][j-1])</code></p><p>其中<code>j - i &lt; 3</code>是表示子串长度小于等于3，因此内部不需要再判断。另外，注意到<code>dp[i][j]</code>需要用到<code>dp[i+1][j-1]</code>，所以<code>i需要逆序遍历</code>。</p><p><strong>中心扩展法</strong></p><p>处理回文子串问题还有一种经典的中心扩展法。观察到回文中心的两侧互为镜像，因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心（包括单中心和双中心），O(n^2)复杂度。</p><p><strong>Java代码</strong></p><p>DP解法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中心扩展法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            res += extend(s, i, i);</span><br><span class="line">            res += extend(s, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">extend</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) <span class="keyword">break</span>;</span><br><span class="line">            count++;</span><br><span class="line">            i--;j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长回文子串-Medium"><a href="#最长回文子串-Medium" class="headerlink" title="最长回文子串 Medium"></a>最长回文子串 Medium</h4><p><strong>题目</strong></p><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>同上题，可以使用 DP 和 中心扩展法。</p><p><strong>Java代码</strong></p><p>DP解法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (j - i &gt; end - start) &#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    end = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中心扩展法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            String s1 = extend(s, i, i);</span><br><span class="line">            String s2 = extend(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s1.length() &gt; res.length()) res = s1;</span><br><span class="line">            <span class="keyword">if</span> (s2.length() &gt; res.length()) res = s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">extend</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) <span class="keyword">break</span>;</span><br><span class="line">            i--;j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长回文子序列-Medium"><a href="#最长回文子序列-Medium" class="headerlink" title="最长回文子序列 Medium"></a>最长回文子序列 Medium</h4><p><strong>题目</strong></p><p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;bbbab&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 一个可能的最长回文子序列为 &quot;bbbb&quot;。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>是回文子串问题的升级版。</p><p>根据DP问题4要素来分析此题：</p><ul><li>状态</li></ul><p><code>dp[i][j]</code>表示 s 的第 i 个字符到第 j 个字符组成的子串中，最长的回文序列长度是多少。</p><ul><li>转移方程</li></ul><p>如果<code>s[i] == s[j]</code>，则<code>dp[i][j] = dp[i+1][j-1] + 2</code>；<br>如果<code>s[i] != s[j]</code>，则<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>。</p><p>然后注意遍历顺序，i 从最后一个字符开始往前遍历，j 从 i + 1 开始往后遍历，这样可以保证每个子问题都已经算好了。</p><ul><li>初始化</li></ul><p><code>dp[i][i] = 1</code></p><ul><li>结果</li></ul><p>返回<code>dp[0][n-1]</code></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最短公共超序列-Hard"><a href="#最短公共超序列-Hard" class="headerlink" title="最短公共超序列 Hard"></a>最短公共超序列 Hard</h4><p><strong>题目</strong></p><p>给出两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。</p><p>（如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 任意位置），可以得到字符串 S，那么 S 就是 T 的子序列）</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：str1 &#x3D; &quot;abac&quot;, str2 &#x3D; &quot;cab&quot;</span><br><span class="line">输出：&quot;cabac&quot;</span><br><span class="line">解释：</span><br><span class="line">str1 &#x3D; &quot;abac&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 的第一个 &quot;c&quot;得到 &quot;abac&quot;。</span><br><span class="line">str2 &#x3D; &quot;cab&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 末尾的 &quot;ac&quot; 得到 &quot;cab&quot;。</span><br><span class="line">最终我们给出的答案是满足上述属性的最短字符串。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= str1.length, str2.length &lt;= 1000</li><li>str1 和 str2 都由小写英文字母组成。</li></ul><p><strong>分析</strong></p><p>可以先找到最大公共子串（LCS），然后利用LCS的结果、str1、str2 共同生成最短公共超序列。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestCommonSupersequence</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        String lcs = longestCommonSubSeq(str1, str2);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : lcs.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (str1.charAt(i) != c) sb.append(str1.charAt(i++));</span><br><span class="line">            <span class="keyword">while</span> (str2.charAt(j) != c) sb.append(str2.charAt(j++));</span><br><span class="line">            sb.append(c);</span><br><span class="line">            i++;j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str1.length()) sb.append(str1.charAt(i++));</span><br><span class="line">        <span class="keyword">while</span> (j &lt; str2.length()) sb.append(str2.charAt(j++));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">longestCommonSubSeq</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = str1.length(), n = str2.length();</span><br><span class="line">        String[][] dp = <span class="keyword">new</span> String[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str1.charAt(i - <span class="number">1</span>) == str2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + str1.charAt(i - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j].length() &gt; dp[i][j - <span class="number">1</span>].length() ?</span><br><span class="line">                            dp[i - <span class="number">1</span>][j] : dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编辑距离-Hard"><a href="#编辑距离-Hard" class="headerlink" title="编辑距离 Hard"></a>编辑距离 Hard</h4><p><strong>题目</strong></p><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p><code>dp[i][j]</code>代表 word1 的前 i 个字符和 word2 的前 j 个字符之间的编辑距离。</p><p>当<code>word1[i] == word2[j]</code>时，<code>dp[i][j] = dp[i-1][j-1]</code>；<br>当<code>word1[i] != word2[j]</code>时，<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code>。</p><p>最后，本题要注意初始化问题：<code>dp[0][i] = i, dp[j][0] = j</code>。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = word1.charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c2 = word2.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.min(dp[i][j], Math.min(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同的子序列-Hard"><a href="#不同的子序列-Hard" class="headerlink" title="不同的子序列 Hard"></a>不同的子序列 Hard</h4><p><strong>题目</strong></p><p>给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。</p><p>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: S &#x3D; &quot;rabbbit&quot;, T &#x3D; &quot;rabbit&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">如下图所示, 有 3 种可以从 S 中得到 &quot;rabbit&quot; 的方案。</span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line"></span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>令<code>dp[i][j]</code>代表 S 的前 i 字符串的子序列中 T 的 前 j 字符串出现的个数。</p><p>当<code>S[i] == T[j]</code>时，<code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</code>；<br>当<code>S[i] != T[j]</code>时，<code>dp[i][j] = dp[i-1][j]</code>。</p><p>同样要注意初始化问题：<code>dp[i][0] = 1</code>，这是因为第一列是 T 为空的情况，空集是所有字符串子集, 所以我们第一列都是 1 。</p><p>因为<code>dp[i][j]</code>只用到了<code>dp[i-1][j-1], dp[i-1][j]</code>，类似于0-1背包问题，其实仅使用一个一维dp数组就足够了。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = t.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化为一维dp数组代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = t.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Decision-Making"><a href="#Decision-Making" class="headerlink" title="Decision Making"></a>Decision Making</h2><p>The general problem statement for this pattern is forgiven situation decide whether to use or not to use the current state. So, the problem requires you to make a decision at a current state.</p><h3 id="Statement-4"><a href="#Statement-4" class="headerlink" title="Statement"></a>Statement</h3><p>Given a set of values find an answer with an option to choose or ignore the current value.</p><h3 id="Approach-4"><a href="#Approach-4" class="headerlink" title="Approach"></a>Approach</h3><p>If you decide to choose the current value use the previous result where the value was ignored; vice-versa, if you decide to ignore the current value use previous result where value was used.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i - indexing a set of values</span></span><br><span class="line"><span class="comment">// j - options to ignore j values</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">       dp[i][j] = <span class="built_in">max</span>(&#123;dp[i][j], dp[i<span class="number">-1</span>][j] + arr[i], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;);</span><br><span class="line">       dp[i][j<span class="number">-1</span>] = <span class="built_in">max</span>(&#123;dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + arr[i], arr[i]&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Similar-Problems-4"><a href="#Similar-Problems-4" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p>列举如下：</p><ul><li><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a> <strong>Easy</strong></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a> <strong>Easy</strong></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a> <strong>Medium</strong></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a> <strong>Hard</strong></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a> <strong>Hard</strong></li></ul><h4 id="打家劫舍-Easy"><a href="#打家劫舍-Easy" class="headerlink" title="打家劫舍 Easy"></a>打家劫舍 Easy</h4><p><strong>题目</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>建立二维数组<code>dp[n+1][2]</code>，n 代表输入数组的长度，2 代表小偷的决策数量：偷/不偷。</p><p>令<code>dp[i][0]</code>表示在 i 个房间不偷，<code>dp[i][1]</code>表示在 i 个房间偷。</p><p>有状态转移方程：</p><ul><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1])</code></li><li><code>dp[i][1] = dp[i-1][0] + nums[i]</code></li></ul><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实空间复杂度可以进一步优化到$O(1)$。</p></blockquote><h4 id="买卖股票的最佳时机-II-Easy"><a href="#买卖股票的最佳时机-II-Easy" class="headerlink" title="买卖股票的最佳时机 II Easy"></a>买卖股票的最佳时机 II Easy</h4><p><strong>题目</strong></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>有很多方法可以解这道题，为了处理后续更进一步的股票的问题，这里使用DP来做。</p><p><strong>第 1 步：状态定义</strong></p><p>令<code>dp[i][j]</code> 表示从开始到第 i 天状态为 j 时的最大收益。</p><p>这里 j 取两个值：</p><ul><li>0 表示不持股；</li><li>1 表示持股。</li></ul><p><strong>第 2 步：状态转移方程</strong></p><p><code>dp[i][0]</code>代表当天不持股，可以由昨天不持股和昨天持股转换而来，<code>dp[i][1]</code>代表当天持股，也可以由昨天不持股和昨天持股转换而来：</p><ul><li><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code>：</li><li><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</code></li></ul><p><strong>第 3 步：思考初始化</strong></p><p>在第 0 天，不持股的初始化值为 0，持股的初始化值为 -prices[0]。</p><p><strong>第 4 步：思考输出</strong></p><p>每一天都由前面几天的状态转换而来，最优值在最后一天，并且是不持股的状态。</p><p><strong>第 5 步：思考状态压缩</strong></p><p>因为当前行总是参考上一行的值，可以使用滚动数组优化。本题dp数组第二维又只有 2 大小，因此空间复杂度可以优化为$O(1)$。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机含手续费-Medium"><a href="#买卖股票的最佳时机含手续费-Medium" class="headerlink" title="买卖股票的最佳时机含手续费 Medium"></a>买卖股票的最佳时机含手续费 Medium</h4><p><strong>题目</strong></p><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>和上题一样的思路。</p><p>状态转移方程：</p><ul><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code></li><li><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)</code></li></ul><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>] - fee;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最佳买卖股票时机含冷冻期-Medium"><a href="#最佳买卖股票时机含冷冻期-Medium" class="headerlink" title="最佳买卖股票时机含冷冻期 Medium"></a>最佳买卖股票时机含冷冻期 Medium</h4><p><strong>题目</strong></p><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>同样定义<code>dp[i][j]</code>，i 仍然表示进行到第几天了，但是此时 j 有 3 种取值：</p><ul><li>取 0 代表当天不持股且当天没卖出的最大收益</li><li>取 1 代表当天持股的最大收益</li><li>取 2 代表当天不持股且当天卖出的最大收益</li></ul><p>这样状态转移方程就很明显了，直接看代码即可。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机-III-IV-Hard"><a href="#买卖股票的最佳时机-III-IV-Hard" class="headerlink" title="买卖股票的最佳时机 III/IV Hard"></a>买卖股票的最佳时机 III/IV Hard</h4><p>这是两道 Hard 题，其实对于整个股票问题来说，是有着相应的 <strong>通用解法</strong> 的。想要深入了解股票买卖问题可以参考下面给出的链接，在这里就不详细介绍了。</p><ul><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">Most consistent ways of dealing with the series of stock problems</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/" target="_blank" rel="noopener">一个通用方法团灭 6 道股票问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划（dynamic programming，简称DP）一直是算法面试中最难的话题之一。DP的本质在于如何完整的刻化状态而又使状态不包含冗余信息，这是比较难的一点；另外，不同的DP问题之间似乎并不能用统一的模式来表示，所以往往在做了一些DP题之后遇到新的DP问题还是束手
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://www.yingzq.com/tags/Java/"/>
    
      <category term="算法设计技巧" scheme="http://www.yingzq.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/"/>
    
      <category term="LeetCode" scheme="http://www.yingzq.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>在Mac中安装并配置conda环境（简约版）</title>
    <link href="http://www.yingzq.com/2020/03/25/conda-env-config-in-mac/"/>
    <id>http://www.yingzq.com/2020/03/25/conda-env-config-in-mac/</id>
    <published>2020-03-25T04:35:32.000Z</published>
    <updated>2020-03-30T10:49:10.283Z</updated>
    
    <content type="html"><![CDATA[<p>conda环境莫名其妙的崩了，整了半天还是会各种报错，因此完全卸载了重装吧！本文主要记录Mac在安装、配置conda环境时的几个要点。</p><blockquote><p>注：其他系统的安装也差不多，但是可能需要在某些地方微调。</p></blockquote><a id="more"></a><h2 id="安装-Anaconda3"><a href="#安装-Anaconda3" class="headerlink" title="安装 Anaconda3"></a>安装 Anaconda3</h2><p>首先需要下载最新版本的 <code>Anaconda3</code>，可以在 <a href="https://www.anaconda.com/" target="_blank" rel="noopener">官网</a> 进行下载，但是往往慢的怀疑人生，所以国内用户可以移步 <a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">Anaconda 清华镜像</a> 下载，速度非常快。</p><p>另外，根据清华镜像的提示配置好Anaconda 仓库与第三方源（conda-forge、msys2、pytorch等）的镜像，也就是配置好<code>.condarc</code>文件。</p><p>运行 <code>conda clean -i</code> 清除索引缓存，保证用的是镜像站提供的索引。</p><h2 id="pip-配置国内镜像源"><a href="#pip-配置国内镜像源" class="headerlink" title="pip 配置国内镜像源"></a>pip 配置国内镜像源</h2><p>上一步只是配置好了<code>conda</code>的镜像源，但是有些包<code>conda</code>是没有的，需要用<code>pip</code>进行安装，这个时候就会发现<code>pip</code>下载安装包也贼慢。所以需要将<code>pip</code>也配置成国内的镜像。</p><p>国内常用的<code>pip</code>镜像源如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">清华大学：https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;</span><br><span class="line">阿里云 ：http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br><span class="line">中国科学技术大学：https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;</span><br><span class="line">豆瓣：http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure><h3 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h3><p>如果只是想要临时使用<code>pip</code>安装某些包，可以使用如下命令使用清华镜像下载安装包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install xxx -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure><h3 id="永久使用"><a href="#永久使用" class="headerlink" title="永久使用"></a>永久使用</h3><p>如果是你自己的个人电脑，你可能不想每次都输入那么长的<code>-i https://xxxx</code>后缀，所以可以设置为一劳永逸。</p><p>在Mac系统中，直接打开<code>~/.pip/pip.conf</code>文件（如果没有<code>.pip</code>文件夹或者<code>pip.conf</code>文件就创建），然后输入以下内容使用清华镜像源：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F;</span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>或者使用阿里云镜像也是极好的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure><p>然后保存退出即可。</p><h2 id="jupyter-notebook-增加-kernel"><a href="#jupyter-notebook-增加-kernel" class="headerlink" title="jupyter notebook 增加 kernel"></a>jupyter notebook 增加 kernel</h2><p>如果你经常使用<code>jupyter</code>，你会发现无论你<code>conda</code>环境中有多少虚拟环境，但是在<code>jupyter notebook</code>新建文件时只有一个<code>Python 3</code>的环境可以选，其实该环境也就是<code>base</code>环境。</p><p>但是很多时候在使用<code>jupyter notebook</code>时我们也希望有类似<code>conda</code>的环境管理功能。这可以通过为其增加<code>kernel</code>做到，具体操作如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda activate conda_env_name</span><br><span class="line">conda install jupyter notebook</span><br><span class="line">conda install ipykernel</span><br><span class="line">python -m ipykernel install --user --name conda_env_name --display-name jupyter_name</span><br></pre></td></tr></table></figure><p>上面最后一条命令中<code>conda_env_name</code>指的是conda虚拟环境的名字，<code>jupyter_name</code>则指的是在jupyter notebook中展示的名字，例如将名为<code>pytorch</code>的conda环境展示为<code>Python (pytorch)</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m ipykernel install --user --name pytorch --display-name &quot;Python (pytorch)&quot;</span><br></pre></td></tr></table></figure><p>最后罗列一些和<code>kernel</code>相关的常用指令。</p><p>查看已有的kernel：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter kernelspec list</span><br></pre></td></tr></table></figure><p>删除指定的kernel：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter kernelspec remove kernel_name</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;conda环境莫名其妙的崩了，整了半天还是会各种报错，因此完全卸载了重装吧！本文主要记录Mac在安装、配置conda环境时的几个要点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：其他系统的安装也差不多，但是可能需要在某些地方微调。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="环境安装与配置" scheme="http://www.yingzq.com/categories/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="conda" scheme="http://www.yingzq.com/tags/conda/"/>
    
      <category term="环境安装与配置" scheme="http://www.yingzq.com/tags/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>the-principle-of-xlnet</title>
    <link href="http://www.yingzq.com/2020/03/21/the-principle-of-xlnet/"/>
    <id>http://www.yingzq.com/2020/03/21/the-principle-of-xlnet/</id>
    <published>2020-03-21T02:53:37.000Z</published>
    <updated>2020-03-21T02:53:37.143Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>对 “旋转排序数组” 相关问题的解决方法</title>
    <link href="http://www.yingzq.com/2020/03/16/solution-for-rotated-sorted-array/"/>
    <id>http://www.yingzq.com/2020/03/16/solution-for-rotated-sorted-array/</id>
    <published>2020-03-16T12:39:25.000Z</published>
    <updated>2020-03-17T05:28:51.972Z</updated>
    
    <content type="html"><![CDATA[<p>在LeetCode以及各种笔试、面经中经常会看到这样的有序数组的定义：<strong>假设按照升序排序的数组在预先未知的某个点上进行了旋转</strong> ，我们暂且称之为 <code>旋转排序数组</code>。基于 <code>旋转排序数组</code>，可以考察许多看起来简单但是似乎又没那么简单的问题：求出其中最小值或者最大值的位置，给定一个 target 求出该数组中是否存在、若存在具体在哪个位置…</p><p>本文介绍一种解决 <code>旋转排序数组</code> 问题的思考方法，希望能够帮助大家理解这类问题。</p><a id="more"></a><h2 id="初步思考"><a href="#初步思考" class="headerlink" title="初步思考"></a>初步思考</h2><p>根据<code>旋转排序数组</code>的定义可以知道，数组在未旋转的是一个升序数组，例如<code>[0,1,2,4,5,6,7]</code>，但是在未知的某个位置发生了旋转，所以数组可能变成了<code>[6,7,0,1,2,4,5]</code>，也可能变成了<code>[2,4,5,6,7,0,1]</code>，也有可能不发生变化（极端情况）。</p><h3 id="数组中查找target问题"><a href="#数组中查找target问题" class="headerlink" title="数组中查找target问题"></a>数组中查找target问题</h3><p>在升序数组中查找 target 是否存在的问题我们往往使用二分搜索，二分搜索充分利用了数组的有序性，将时间复杂度缩减到$O(\log n)$。那么对于<code>旋转排序数组</code>呢？可以看出，在全局来看已经不是一个升序数组了，那么对于查找 target 的任务，我们可以将它当做一个无序数组，从头到尾遍历数组，这样的话便可以利用$O(n)$的时间复杂度完成该任务。</p><p>但是这样将<code>旋转排序数组</code>当做无序数组是一个不太好的近似，因为虽然<code>旋转排序数组</code>整体来看不是有序的，但是满足局部有序性：<code>[4,5,6,7,0,1,2]</code>中左边部分的<code>[4,5,6,7]</code>和右边部分的<code>[0,1,2]</code>分别都是有序的。我们知道有序性对于查找来说是致命的诱惑，所以我们能否利用这一点呢？</p><p>先来看一下在<code>旋转排序数组</code>进行一次二分查找的结果：</p><div align=center><img src="http://image.yingzq.com/img/20200219235223.png" width="500" alt="旋转排序数组的二分查找" /><p>旋转排序数组的二分查找</p></div><p>这里有且仅有三种情景，同样来升序数组<code>[0,1,2,4,5,6,7]</code>来举例。</p><p>第一种情景就是数组刚好不发生改变，可以看出经过<code>mid = lo + (hi - lo) / 2</code>的操作，数组会被<code>mid=4</code>分成了左右两个有序的数组，分别是<code>[0,1,2]</code>和<code>[5,6,7]</code>且两边范围不相交。</p><p>第二种情景是数组变成了<code>[2,4,5,6,7,0,1]</code>，此时<code>mid=6</code>将数组分成了<code>[2,4,5]</code>和<code>[7,0,1]</code>，此时<strong>只有左半部分是有序的，右半部分整体上看无序且范围与左半部分不相交</strong>。</p><p>第三种情景是数组变成了<code>[6,7,0,1,2,4,5]</code>，此时<code>mid=1</code>将数组分成了<code>6,7,0</code>和<code>[2,4,5]</code>，此时则<strong>只有右半部分是有序的，左半部分整体上看无序且范围与右半部分不相交</strong>。</p><p>通过这三种情景可以看出，<strong><code>旋转排序数组</code>进行二分查找的时候，至少有一边是有序的</strong>，并且我们可以通过<code>nums[lo], nums[mid], nums[hi]</code>的相对大小来判别当前是哪种情景，所以可以这样进行查找 target 的任务：</p><ol><li>如果<code>nums[mid] == target</code>，查找成功，直接返回。</li><li>如果<code>nums[lo] &lt;= nums[mid]</code>，此时是情景一或者情景二，<strong>两者的左半部分是有序的</strong>，所以可以：<ul><li>先查找target是否在左半部分，因为有序，直接使用<code>target &gt;= nums[lo] &amp;&amp; target &lt; nums[mid]</code>判断，如果为true，则无需搜索右半部分了（因为两部分范围不相交），令<code>hi = mid - 1</code>，将范围缩小至左半部分。</li><li>如果为false则排除了左半部分，但是此时并不能确定右半部分的情况（因为无序），因此我们令<code>lo = mid + 1</code>，将范围缩小至右半部分等待下一次查找。</li></ul></li><li>如果<code>nums[lo] &gt; nums[mid]</code>，此时是情景三，<strong>它的右半部分是有序的</strong>，所以可以：<ul><li>先利用<code>target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]</code>查找右半部分，若为true则令<code>lo = mid + 1</code>。</li><li>如果为false则接着在左半部分查找，因为左半部分无序，所以令<code>hi = mid - 1</code>等待下一次查找。</li></ul></li></ol><p>上面是用了<code>nums[lo]</code>和<code>nums[mid]</code>作比较，其实用<code>nums[mid]</code>和<code>nums[hi]</code>作比较也是同样的道理，都可以借助两者的相对大小将情况分为左半有序的情况和右半有序的情况，具体流程如下：</p><ol><li>如果<code>nums[mid] == target</code>，查找成功，直接返回。</li><li>如果<code>nums[mid] &lt; nums[hi]</code>，此时是情景一或者情景三，<strong>两者的右半部分是有序的</strong>，所以可以：<ul><li>先查找target是否在右半部分，因为有序，直接使用<code>target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]</code>判断，如果为true，则无需搜索左半部分了（因为两部分范围不相交），令<code>lo = mid + 1</code>，将范围缩小右半部分。</li><li>如果为false则排除了右半部分，但是此时并不能确定左半部分的情况（因为无序），因此我们令<code>hi = mid - 1</code>，将范围缩小至左半部分等待下一次查找。</li></ul></li><li>如果<code>nums[mid] &gt; nums[hi]</code>，此时是情景二，<strong>它的左半部分是有序的</strong>，所以可以：<ul><li>先利用<code>target &gt; nums[lo] &amp;&amp; target &lt;= nums[mid]</code>查找左半部分，若为true则令<code>hi = mid - 1</code>。</li><li>如果为false则接着在右半部分查找，因为右半部分无序，所以令<code>lo = mid + 1</code>等待下一次查找。</li></ul></li></ol><p>值得注意的是，<strong>这是不考虑数组中有重复元素的情况</strong>。那么如果存在重复元素元素应该如何处理呢，例如对于<code>[2,0,2,2,2], target=0</code>？</p><p>当利用<code>nums[lo], nums[mid]</code>相比较的时候，和上面唯一的区别是当<code>nums[lo] == nums[mid]</code>时并不能保证左半部分是有序的，所以需要额外处理，注意到此时<code>nums[mid] != target -&gt; nums[lo] != target</code>，所以我们可以知道此时<code>nums[lo]</code>肯定不是要找的结果，所以可以令<code>lo++</code>，然后等待下一次查找，但是如果每次都遇到这样的情况那么时间复杂度就退化成了$O(n)$。</p><p>当利用<code>nums[mid], nums[hi]</code>相比较的时候其实很类似，就是当<code>nums[mid] == nums[hi]</code>的时候进行<code>hi--</code>即可。</p><blockquote><p>其实重复元素的处理还有更好的方案，那就是利用双边进行比较，即同时利用<code>nums[lo]</code>和<code>nums[hi]</code>，这样可以尽可能的优化性能，但是提升并不大，代码复杂了许多，本文就不深入分析了。</p></blockquote><h3 id="数组中最小最大元素的问题"><a href="#数组中最小最大元素的问题" class="headerlink" title="数组中最小最大元素的问题"></a>数组中最小最大元素的问题</h3><p>针对<code>旋转排序数组</code>，还有一类问题是找出其中最小元素或者最大元素的位置。</p><p>就拿寻找最小元素来说，我们简单分析一下：当最小值索引在mid的左边时，对应的是情景一和情景三；当最小值索引在mid的右边时对应的是情景二。所以我们只需要把情景二和情景一、情景三区分开就可以判别需要继续搜寻的范围了。</p><p>如何区分呢？利用<code>nums[mid]</code>和<code>nums[hi]</code>的相对大小即可，思路如下：</p><ol><li>如果<code>nums[mid] &lt;= nums[hi]</code>，此时是情景一和情景三，最小值索引在mid左边（也可能就是mid），所以令<code>hi = mid</code></li><li>如果<code>nums[mid] &gt; nums[hi]</code>，此时是情景二，最小值索引在mid右边，所以令<code>lo = mid + 1</code></li><li>终止条件：<code>lo == hi</code>，返回lo或nums[lo]，看题目需求。</li></ol><p>如果有重复元素呢？其实也是当<code>nums[mid] == nums[hi]</code>的时候需要特殊处理，因为这个时候不能确定是哪种情景。但是由于终止条件是<code>lo == hi</code>，因此此时肯定有<code>mid &lt; hi &amp;&amp; nums[mid] == nums[hi]</code>，那我们此时进行<code>hi--</code>是不影响最终结果的。</p><blockquote><p>对于求最大元素，思路基本一致，具体差别可以看下面例题。</p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>接下来看几道LeetCode的例题，用代码实现上面的思想。</p><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h3><p><strong>题目链接</strong></p><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">LeetCode 33 搜索旋转排序数组</a></p><p><strong>题目</strong></p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><ul><li>你可以假设数组中不存在重复的元素。</li><li>你的算法时间复杂度必须是 O(log n) 级别。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><p>题中说明不含重复元素，所以直接写出代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[lo] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 左边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[lo] &amp;&amp; target &lt; nums[mid]) hi = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]) lo = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到也可以使用<code>nums[mid]</code>和<code>nums[hi]</code>的大小来解答，这里同样可以很轻易的写出代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= nums[hi]) &#123;</span><br><span class="line">                <span class="comment">// 右边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]) lo = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[lo] &amp;&amp; target &lt; nums[mid]) hi = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面的题目只写出一种代码，毕竟思路都是一样的。</p></blockquote><h3 id="搜索旋转排序数组（有重复元素）"><a href="#搜索旋转排序数组（有重复元素）" class="headerlink" title="搜索旋转排序数组（有重复元素）"></a>搜索旋转排序数组（有重复元素）</h3><p><strong>题目链接</strong></p><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">LeetCode 81 搜索旋转排序数组 II</a></p><p><strong>题目</strong></p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><ul><li>本题中的 nums 可能包含重复元素。</li><li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li></ul><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[lo] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 左边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[lo] &amp;&amp; target &lt; nums[mid]) hi = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] &gt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 右边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]) lo = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 重复情况</span></span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索旋转排序数组（终极版）"><a href="#搜索旋转排序数组（终极版）" class="headerlink" title="搜索旋转排序数组（终极版）"></a>搜索旋转排序数组（终极版）</h3><p><strong>题目链接</strong></p><p><a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/" target="_blank" rel="noopener">LeetCode 面试题 10.03. 搜索旋转数组</a></p><p><strong>题目</strong></p><p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p><p><strong>解答</strong></p><p>这一题最特别的地方在于<strong>若有多个相同元素，返回索引值最小的一个</strong>，其实只需要在终止条件稍作处理即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[lo] == target) <span class="keyword">return</span> lo;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="comment">// 这里不能直接返回，因为mid不一定是所求的最小索引值</span></span><br><span class="line">                hi = mid;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[lo] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 左边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[lo] &amp;&amp; target &lt; nums[mid]) hi = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] &gt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 右边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]) lo = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 重复情况</span></span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h3><p><strong>题目链接</strong></p><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">LeetCode 153 寻找旋转排序数组中的最小值</a></p><p><strong>题目</strong></p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><ul><li>你可以假设数组中不存在重复元素。</li></ul><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= nums[hi]) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找旋转排序数组中的最小值（有重复元素）"><a href="#寻找旋转排序数组中的最小值（有重复元素）" class="headerlink" title="寻找旋转排序数组中的最小值（有重复元素）"></a>寻找旋转排序数组中的最小值（有重复元素）</h3><p><strong>题目链接</strong></p><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">LeetCode 154 寻找旋转排序数组中的最小值 II</a></p><p><strong>题目</strong></p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><ul><li>注意数组中可能存在重复的元素。</li></ul><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[hi]) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[hi]) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi--;  <span class="comment">// 重复情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找旋转排序数组中的最大值（有重复元素）"><a href="#寻找旋转排序数组中的最大值（有重复元素）" class="headerlink" title="寻找旋转排序数组中的最大值（有重复元素）"></a>寻找旋转排序数组中的最大值（有重复元素）</h3><p>本题LeetCode没有对应的题，是我自己想的…</p><p><strong>题目</strong></p><p>求含有重复元素的旋转排序数组的最大值。</p><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[lo] &lt; nums[mid]) &#123;</span><br><span class="line">                lo = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] &gt; nums[mid]) &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一个需要注意的地方是求mid的时候要让mid偏右，否则当只有两个元素的时候会有<code>lo == mid</code>，从而进行<code>lo++</code>的时候可能去除了最大值，会发生错误，例如对于<code>[2,1]</code>，得到的最终结果就是1。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于旋转排序数组，进行二分查找的时候一共有三种情景，通过<code>nums[lo], nums[mid], nums[hi]</code>的相对大小可以区分出这三种情景，从而在旋转排序数组也可以使用二分查找缩小范围了，并且也只需要遍历一次。</p><p>对于数组中有重复元素的情况，遇到<code>nums[lo] == nums[mid]</code>或<code>nums[mid] == nums[hi]</code>时，往往可以通过简单的<code>lo++</code>或者<code>hi--</code>来更新，只不过此类情况过多的话会导致时间复杂度退化为$O(n)$。</p><p>最后，总结一个小trick：</p><ul><li>当进行查找target任务时，while循环的条件是<code>lo &lt;= hi</code>，并且可以只使用<code>nums[lo]</code>和<code>nums[mid]</code>即可。</li><li>当进行最小值查找时，while循环的条件是<code>lo &lt; hi</code>，并且使用<code>nums[mid]</code>和<code>nums[hi]</code>更方便些。</li><li>当进行最大值查找时，while循环的条件是<code>lo &lt; hi</code>，并且<code>mid = lo + (hi - lo + 1) / 2</code>，此时使用<code>nums[lo]</code>和<code>nums[mid]</code>更方便些。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在LeetCode以及各种笔试、面经中经常会看到这样的有序数组的定义：&lt;strong&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转&lt;/strong&gt; ，我们暂且称之为 &lt;code&gt;旋转排序数组&lt;/code&gt;。基于 &lt;code&gt;旋转排序数组&lt;/code&gt;，可以考察许多看起来简单但是似乎又没那么简单的问题：求出其中最小值或者最大值的位置，给定一个 target 求出该数组中是否存在、若存在具体在哪个位置…&lt;/p&gt;
&lt;p&gt;本文介绍一种解决 &lt;code&gt;旋转排序数组&lt;/code&gt; 问题的思考方法，希望能够帮助大家理解这类问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://www.yingzq.com/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://www.yingzq.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>一种处理回溯问题的通用方法</title>
    <link href="http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/"/>
    <id>http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/</id>
    <published>2020-03-14T08:51:58.000Z</published>
    <updated>2020-03-29T06:25:12.021Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode中很多问题是和回溯相关的，例如Subsets, Permutations, Combination Sum, Palindrome Partitioning, N-Queens等等，所以本文借助这些题目提取了一种较为通用的思考模式，或者说代码结构来帮助处理这些回溯的问题。</p><a id="more"></a><blockquote><p>文章主要copy自LeetCode Discuss区的 <a href="https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)" target="_blank" rel="noopener">这篇文章</a> 。另外代码是用 <strong>Java</strong> 写的，但是个人认为语言并不是关键。</p></blockquote><h2 id="Subsets（子集）"><a href="#Subsets（子集）" class="headerlink" title="Subsets（子集）"></a>Subsets（子集）</h2><p><strong>链接</strong></p><p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">leetcode 78题</a></p><p><strong>题目</strong></p><p>给定一组<code>不含重复元素</code>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Arrays.sort(nums);  // 不需要排序</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res , List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, i + <span class="number">1</span>);  <span class="comment">// 不能重复使用元素，所以需要i+1</span></span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入的<code>nums</code>是<code>[1, 2, 3]</code>，那么该解法输出的结果顺序是：</p><p><code>[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]</code></p><h2 id="Subsets-II（子集-II）"><a href="#Subsets-II（子集-II）" class="headerlink" title="Subsets II（子集 II）"></a>Subsets II（子集 II）</h2><p><strong>链接</strong></p><p><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">LeetCode 90题</a></p><p><strong>题目</strong></p><p>给定一个可能<code>包含重复元素</code>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">// 为了方便剔除重复元素，需要排序</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 剔除重复元素</span></span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入的<code>nums</code>是<code>[1, 2, 2]</code>，那么该解法输出的结果顺序是：</p><p><code>[[],[1],[1,2],[1,2,2],[2],[2,2]]</code></p><h2 id="Permutations（全排列）"><a href="#Permutations（全排列）" class="headerlink" title="Permutations（全排列）"></a>Permutations（全排列）</h2><p><strong>链接</strong></p><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">LeetCode 46题</a></p><p><strong>题目</strong></p><p>给定一个<code>没有重复数字</code>的序列，返回其所有可能的全排列。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Arrays.sort(nums); // 不含重复元素，不需要排序</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tempList.size() == nums.length) &#123;  <span class="comment">// 判断是否达到终止条件</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>; <span class="comment">// 判断是否访问过该元素</span></span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, visited);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题和Subsets不同的地方在于：本题的每个结果的长度都是<code>nums.length</code>，因此两者的终止条件有差异；另外，Subsets中是使用了<code>start</code>指针来表示目前可以访问元素的范围，也就是<code>start ~ nums.length-1</code>，但是Permutations无法这样做，因为元素访问顺序不同时是能够产生不同结果的，因此使用了<code>visited</code>数组来记录已访问的位置（用HashSet也是可以的）。</p><p>如果输入的<code>nums</code>是<code>[1, 2, 3]</code>，那么该解法输出的结果顺序是：</p><p><code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></p><h2 id="Permutations-II（全排列-II）"><a href="#Permutations-II（全排列-II）" class="headerlink" title="Permutations II（全排列 II）"></a>Permutations II（全排列 II）</h2><p><strong>链接</strong></p><p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">LeetCode 47题</a></p><p><strong>题目</strong></p><p>给定一个<code>可包含重复数字</code>的序列，返回所有不重复的全排列。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">// 需要排序，方便后续处理重复元素</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">boolean</span> [] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) <span class="keyword">continue</span>;  <span class="comment">// 剔除重复元素</span></span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, visited);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中最关键的部分在于<code>剔除重复元素</code>的步骤，当<code>i &gt; 0 &amp;&amp; nums[i] == nums[i-1]</code>时需要进行处理，其实在这里有两种方式都可以处理：</p><ol><li>当<code>i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !visited[i - 1]</code>时跳过，最终会只保留顺序生成的那一种情况，其余的全部剔除。</li><li>当<code>i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; visited[i - 1]</code>时跳过，最终会只保留逆序生成的那一种情况，其余的全部剔除。</li></ol><p>以第一种处理为例，当输入是<code>[1, 1, 2]</code>时，对应的输出顺序是：</p><p><code>[[1,1,2],[1,2,1],[2,1,1]]</code></p><h2 id="Combination-Sum（组合总和）"><a href="#Combination-Sum（组合总和）" class="headerlink" title="Combination Sum（组合总和）"></a>Combination Sum（组合总和）</h2><p><strong>链接</strong></p><p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">LeetCode 39题</a></p><p><strong>题目</strong></p><p>给定一个<code>无重复元素</code>的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以<code>无限制重复</code>被选取。</p><p>说明：</p><ul><li>所有数字（包括 target）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Arrays.sort(nums);  // 无需排序</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, remain - nums[i], i); <span class="comment">// 因为可以重复使用元素，所以这里不是i+1</span></span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Combination-Sum-II（组合总和-II）"><a href="#Combination-Sum-II（组合总和-II）" class="headerlink" title="Combination Sum II（组合总和 II）"></a>Combination Sum II（组合总和 II）</h2><p><strong>链接</strong></p><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">LeetCode 40题</a></p><p><strong>题目</strong></p><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中<code>只能使用一次</code>。</p><p>说明：</p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 剔除重复元素</span></span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, remain - nums[i], i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Palindrome-Partitioning（分割回文串）"><a href="#Palindrome-Partitioning（分割回文串）" class="headerlink" title="Palindrome Partitioning（分割回文串）"></a>Palindrome Partitioning（分割回文串）</h2><p><strong>链接</strong></p><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">LeetCode 131题</a></p><p><strong>题目</strong></p><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] valid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        valid = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; (j-i &lt; <span class="number">3</span> || valid[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    valid[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; tempList, String s, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!valid[idx][i]) <span class="keyword">continue</span>;</span><br><span class="line">            String sub = s.substring(idx, i+<span class="number">1</span>);</span><br><span class="line">            tempList.add(sub);</span><br><span class="line">            backtrack(res, tempList, s, i+<span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：这段代码中前面关于构建<code>valid数组</code>的部分使用了动态规划，但是并不是本文的重点，只需要知道<code>valid[i][j]</code>表示<strong>字符串中 i 到 j 位置的元素能否构成回文</strong>即可。</p></blockquote><h2 id="Generate-Parentheses（括号生成）"><a href="#Generate-Parentheses（括号生成）" class="headerlink" title="Generate Parentheses（括号生成）"></a>Generate Parentheses（括号生成）</h2><p><strong>链接</strong></p><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">LeetCode 22题</a></p><p><strong>题目</strong></p><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(res, <span class="keyword">new</span> StringBuilder(), n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; res, StringBuilder sb, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span>;  <span class="comment">// 右括号使用比左括号多，舍去</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">'('</span>);</span><br><span class="line">            backtrack(res, sb, left - <span class="number">1</span>, right);</span><br><span class="line">            sb.setLength(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">')'</span>);</span><br><span class="line">            backtrack(res, sb, left, right - <span class="number">1</span>);</span><br><span class="line">            sb.setLength(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面几题不同的是，这一题似乎没有<code>for循环</code>，这是因为在某个位置<code>k</code>，括号只有两种状态：<code>(</code>或者<code>)</code>，不需要循环，但是本质是一样的。</p><h2 id="N-Queens（N皇后）"><a href="#N-Queens（N皇后）" class="headerlink" title="N-Queens（N皇后）"></a>N-Queens（N皇后）</h2><p><strong>链接</strong></p><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">LeetCode 51题</a></p><p><strong>题目</strong></p><p>设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入：4</span><br><span class="line"> 输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line"> 解释: 4 皇后问题存在如下两个不同的解法。</span><br><span class="line">[</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] cols, diag1, diag2;  <span class="comment">// 用于判断某位置的列以及两条对角线是否冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        cols = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];  <span class="comment">// 判断列是否冲突</span></span><br><span class="line">        diag1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n];  <span class="comment">// 判断 左上-&gt;右下 的对角线是否冲突，利用 x-y+n 是定值</span></span><br><span class="line">        diag2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n];  <span class="comment">// 判断 右上-&gt;左下 的对角线是否冲突，利用 x+y 是定值</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; tempList, <span class="keyword">int</span> n, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;  <span class="comment">// 终止条件</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id1 = row - j + n, id2 = row + j;</span><br><span class="line">            <span class="keyword">if</span> (cols[j] || diag1[id1] || diag2[id2]) <span class="keyword">continue</span>;  <span class="comment">// 此位置有冲突，跳过</span></span><br><span class="line">            cols[j] = <span class="keyword">true</span>;</span><br><span class="line">            diag1[id1] = <span class="keyword">true</span>;</span><br><span class="line">            diag2[id2] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">            Arrays.fill(chars, <span class="string">'.'</span>);</span><br><span class="line">            chars[j] = <span class="string">'Q'</span>;</span><br><span class="line">            tempList.add(<span class="keyword">new</span> String(chars));</span><br><span class="line"></span><br><span class="line">            backtrack(res, tempList, n, row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            cols[j] = <span class="keyword">false</span>;</span><br><span class="line">            diag1[id1] = <span class="keyword">false</span>;</span><br><span class="line">            diag2[id2] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然代码长了很多，但是整体的思路是一样的，解决N皇后问题有两个地方值得注意：</p><ol><li>如何判断二维数组中两个元素是否在<code>同一对角线</code>，这一点在代码中已经解释。</li><li>因为每一行只能有一个皇后，所以回溯函数中的 <code>for循环</code> 是针对当前行的所有可能。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode中很多问题是和回溯相关的，例如Subsets, Permutations, Combination Sum, Palindrome Partitioning, N-Queens等等，所以本文借助这些题目提取了一种较为通用的思考模式，或者说代码结构来帮助处理这些回溯的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://www.yingzq.com/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://www.yingzq.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer第二版》阅读笔记（三）</title>
    <link href="http://www.yingzq.com/2020/02/21/sword-finger-offer-notes-part-three/"/>
    <id>http://www.yingzq.com/2020/02/21/sword-finger-offer-notes-part-three/</id>
    <published>2020-02-21T05:02:22.000Z</published>
    <updated>2020-03-23T09:19:53.784Z</updated>
    
    <content type="html"><![CDATA[<p>《剑指offer第二版》阅读笔记最后一个部分，记录了书中面试题51到最后的部分。</p><a id="more"></a><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="/2020/02/19/sword-finger-offer-notes/" title="《剑指offer第二版》阅读笔记（一）">《剑指offer第二版》阅读笔记（一）</a></li><li><a href="/2020/02/20/sword-finger-offer-notes-part-two/" title="《剑指offer第二版》阅读笔记（二）">《剑指offer第二版》阅读笔记（二）</a></li><li><a href="/2020/02/21/sword-finger-offer-notes-part-three/" title="《剑指offer第二版》阅读笔记（三）">《剑指offer第二版》阅读笔记（三）</a></li></ul><h2 id="面试题51：数组中的逆序对"><a href="#面试题51：数组中的逆序对" class="headerlink" title="面试题51：数组中的逆序对"></a>面试题51：数组中的逆序对</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>暴力法的时间复杂度为$O(n^2)$，不可取。这里我们用到了一个重要的知识点：<strong>逆序对是归并排序的副产物。</strong> 在归并排序的一次<code>merge</code>操作中，如果右边的某元素大于左边，那么该元素便会产生一定数量的逆序对，不断的递归统计，便能够得到最终结果。因此我们直接复用归并排序的代码，只是在条件<code>aux[j] &lt; aux[i]</code>时添加了一句更新逆序对的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] aux;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数组arr[lo..hi]排序</span></span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(arr, lo, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, hi);</span><br><span class="line">        merge(arr, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将arr[lo..mid]和arr[mid+1..hi]归并</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将arr[lo..hi]复制到aux[lo..hi]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">            aux[k] = arr[k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) arr[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) arr[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (aux[j] &lt; aux[i]) &#123;</span><br><span class="line">                count += mid - i + <span class="number">1</span>;  <span class="comment">// aux[i] &gt; aux[j]，说明 arr[i...mid] 都大于 arr[j]</span></span><br><span class="line">                arr[k] = aux[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> arr[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>归并排序在<code>merge</code>方法中要时刻注意<code>arr</code>数组和<code>aux</code>数组所代表的意义，不要用混了。</p></blockquote><h2 id="面试题52：两个链表的第一个公共节点"><a href="#面试题52：两个链表的第一个公共节点" class="headerlink" title="面试题52：两个链表的第一个公共节点"></a>面试题52：两个链表的第一个公共节点</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>输入两个链表，找出它们的第一个公共节点。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>很容易想到的一种思路是先求出两个链表的长度<code>n1, n2</code>，假设<code>n1 &gt;= n2</code>，然后求出长度差<code>n1-n2</code>，最后利用快慢指针，让快指针在较长的链表先移动<code>n1-n2</code>步，然后快慢指针一起移动，如果两个链表有公共部分，两个指针会在同一时刻达到相同位置，因此可以找到第一个公共节点。</p><p>还有一种想法不需要求链表长度差值：当两个链表<code>l1, l2</code>有公共节点时，可以证明对于拼接后的链表<code>l1-&gt;l2</code>以及<code>l2-&gt;l1</code>会在同一时间达到第一个公共节点，相关代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA, b = headB;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a == <span class="keyword">null</span> ? headB : a.next;</span><br><span class="line">            b = b == <span class="keyword">null</span> ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题53-1：数字在排序数组中出现的次数"><a href="#面试题53-1：数字在排序数组中出现的次数" class="headerlink" title="面试题53-1：数字在排序数组中出现的次数"></a>面试题53-1：数字在排序数组中出现的次数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>统计一个数字在排序数组中出现的次数。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>需要注意的是数组已经<strong>排序</strong>，所以我们可以使用两次<code>二分查找</code>，第一次查找<code>target</code>起始位置，第二次查找<code>target</code>结束位置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 查找target起始位置</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[lo] != target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startIdx = lo;</span><br><span class="line">        <span class="comment">// 查找target结束位置</span></span><br><span class="line">        hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo - startIdx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中有几个要注意的点，一是循环条件是<code>lo &lt; hi</code>，其中没有等号，这样循环结束的时候一定有<code>lo == hi</code>，二是<code>lo+(hi-lo)/2</code>会偏向于取左边，<code>lo+(hi-lo+1)/2</code>则偏向于取右边，最后边界更新时是哪一边等于<code>mid</code>，哪一边等于<code>mid-1</code>或<code>mid+1</code>需要考虑清楚，如果觉得麻烦可以拆成3个部分进行处理，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    lo = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hi = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    lo = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">    hi = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hi = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题53-2：0～n-1中缺失的数字"><a href="#面试题53-2：0～n-1中缺失的数字" class="headerlink" title="面试题53-2：0～n-1中缺失的数字"></a>面试题53-2：0～n-1中缺失的数字</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>直接<code>二分查找</code>最后一个满足<code>nums[i] = i</code>的位置，然后处理一些小细节即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid) &#123;</span><br><span class="line">                lo = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[lo] == lo ? lo + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题54：二叉搜索树的第k大节点"><a href="#面试题54：二叉搜索树的第k大节点" class="headerlink" title="面试题54：二叉搜索树的第k大节点"></a>面试题54：二叉搜索树的第k大节点</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>这是一棵<strong>二叉搜索树</strong>，我们有如下结论：按照<code>left-&gt;root-&gt;right</code>进行遍历时（即中序遍历）可以得到<code>递增序列</code>，按照<code>right-&gt;root-&gt;left</code>进行遍历时（即逆中序遍历）可以得到<code>递减序列</code>。</p><p>这一题需要返回第<code>k</code>大的节点，那么我们可以选择遍历<code>right-&gt;root-&gt;left</code>，直到得到第<code>k</code>个元素即为所求，相关代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (++count == k) <span class="keyword">return</span> cur.val;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题55-1：二叉树的深度"><a href="#面试题55-1：二叉树的深度" class="headerlink" title="面试题55-1：二叉树的深度"></a>面试题55-1：二叉树的深度</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>这种树的问题直接递归，当前节点为空时返回深度 0，否则当前节点的深度为左子树和右子树中的较大值加上 1。代码非常简洁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题55-2：平衡二叉树"><a href="#面试题55-2：平衡二叉树" class="headerlink" title="面试题55-2：平衡二叉树"></a>面试题55-2：平衡二叉树</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>递归进行判断即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> depth(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span> || right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left - right &gt; <span class="number">1</span> || right - left &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的思想不需要再说，上面代码值得注意的是巧用了<code>-1</code>来当做布朗值使用，其实也可以使用一个新的成员变量<code>isBalanced</code>的常规解法，代码贴出来可以进行比较：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isBalanced;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        isBalanced = <span class="keyword">true</span>;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || !isBalanced) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>)</span><br><span class="line">            isBalanced = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题56-1：数组中只出现一次的两个数字"><a href="#面试题56-1：数组中只出现一次的两个数字" class="headerlink" title="面试题56-1：数组中只出现一次的两个数字"></a>面试题56-1：数组中只出现一次的两个数字</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>我们进行一次全员<code>异或</code>操作，得到的结果就是那两个只出现一次的不同的数字的异或结果了。所以我们现在要做的是能不能将这两个不同的数字分成两组 A 和 B，分组需要满足两个条件：</p><ol><li>两个独特的的数字分成不同组</li><li>相同的数字分成相同组</li></ol><p>这样每一组的数据进行异或即可得到那两个数字。问题的关键点是我们怎么进行分组呢？由于异或的性质是，同一位相同则为 0，不同则为 1，我们将所有数字异或的结果一定不是 0，也就是说至少有一位是 1。</p><p>我们随便取一位，分组的依据就来了，也就是所取的那一位是 0 分成 1 组，那一位是 1 的分成一组。可以证明这样分组是可以满足上述两个条件的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            xor ^= num;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((xor &amp; h) == <span class="number">0</span>) &#123;</span><br><span class="line">            h = h &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; h) == <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题56-2：数组中唯一只出现一次的数字"><a href="#面试题56-2：数组中唯一只出现一次的数字" class="headerlink" title="面试题56-2：数组中唯一只出现一次的数字"></a>面试题56-2：数组中唯一只出现一次的数字</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p>限制：</p><ul><li>1 &lt;= nums.length &lt;= 10000</li><li>1 &lt;= nums[i] &lt; 2^31</li></ul><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>如果将题目改为<strong>只有一个数字出现一次，其他都出现两次</strong>，那就非常简单了：我们将整个数组的元素进行异或，由于两个相同的数的异或结果是 0，所以对所有元素进行异或的结果便是那个只出现一次的元素。</p><p>但是现在是<strong>其他数字都出现了三次</strong>，异或操作是抵消不掉的，但是我们还是可以沿用位运算的思路。如果一个数字出现三次，那么它的二进制表示的每一位（0 或 1）也会出现三次，如果把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被 3 整除。我们把数组中所有的数字的二进制加起来，如果某一位的和能够被 3 整除，那么那个只出现一次的数字的二进制表示中对应的那一位是 0，否则就是 1。对应的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num &amp; mask) &gt; <span class="number">0</span>) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">3</span> &gt; <span class="number">0</span>) res += mask;</span><br><span class="line">            mask = mask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题57-1：和为s的两个数字"><a href="#面试题57-1：和为s的两个数字" class="headerlink" title="面试题57-1：和为s的两个数字"></a>面试题57-1：和为s的两个数字</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>注意是递增序列，所以直接使用首尾指针法即可。</p><h2 id="面试题57-2：和为s的连续正数序列"><a href="#面试题57-2：和为s的连续正数序列" class="headerlink" title="面试题57-2：和为s的连续正数序列"></a>面试题57-2：和为s的连续正数序列</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p>使用<code>滑动窗口</code>的思想，初始化两个指针<code>slow = 0， fast = 1</code>，当窗口内的数据和小于<code>target</code>时，向右不断的移动<code>fast</code>直到维护的窗口内的数据和大于<code>target</code>，然后再不断的向右移动<code>slow</code>指针，直到窗口内的数据和不大于<code>target</code>，其中遇到数据和等于<code>target</code>时写入数据到结果中即可。</p><h2 id="面试题58-1：翻转单词顺序"><a href="#面试题58-1：翻转单词顺序" class="headerlink" title="面试题58-1：翻转单词顺序"></a>面试题58-1：翻转单词顺序</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>第一种方法是使用<code>s.trim().split(&quot;\\s+&quot;)</code>方法进行切分，然后将得到的字符串数组逆序写入到结果中即可。</p><p>第二种方法是先翻转整个字符串，再对字符串里的每个单词进行翻转，最后清理多余的空格，如果要求原地排序可以考虑此方法。</p><p>第二种方法的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] a = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step 1. reverse the whole string</span></span><br><span class="line">        reverse(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// step 2. reverse each word</span></span><br><span class="line">        reverseWords(a, n);</span><br><span class="line">        <span class="comment">// step 3. clean up spaces</span></span><br><span class="line">        <span class="keyword">return</span> cleanSpaces(a, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j || i &lt; n &amp;&amp; a[i] == <span class="string">' '</span>) i++; <span class="comment">// skip spaces</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; i || j &lt; n &amp;&amp; a[j] != <span class="string">' '</span>) j++; <span class="comment">// skip non spaces</span></span><br><span class="line">            reverse(a, i, j - <span class="number">1</span>);                      <span class="comment">// reverse the word</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trim leading, trailing and multiple spaces</span></span><br><span class="line">    <span class="function">String <span class="title">cleanSpaces</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="string">' '</span>) j++;             <span class="comment">// skip spaces</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; a[j] != <span class="string">' '</span>) a[i++] = a[j++]; <span class="comment">// keep non spaces</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; a[j] == <span class="string">' '</span>) j++;             <span class="comment">// skip spaces</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; n) a[i++] = <span class="string">' '</span>;                      <span class="comment">// keep only one space</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(a).substring(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse a[] from a[i] to a[j]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">char</span> t = a[i];</span><br><span class="line">            a[i++] = a[j];</span><br><span class="line">            a[j--] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题58-2：左旋转字符串"><a href="#面试题58-2：左旋转字符串" class="headerlink" title="面试题58-2：左旋转字符串"></a>面试题58-2：左旋转字符串</h2><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><p>第一种方法是找到切分点，得到<code>str1</code>和<code>str2</code>，然后将它们反着拼接起来，即<code>str2 + str1</code>。</p><p>第二种方法是进行3次翻转：先根据切分点翻转<code>str1</code>和<code>str2</code>，然后对整个字符串进行翻转，例如<code>abcdefg -&gt; bagfedc -&gt; cdefgab</code>。</p><p>当然也可以交换一下翻转的顺序：先翻转整个字符串，然后找到切分点，对<code>str1</code>和<code>str2</code>再进行翻转，例如<code>abcdefg -&gt; gfedcba -&gt; cdefgab</code>。</p><h2 id="面试题59-1：滑动窗口的最大值"><a href="#面试题59-1：滑动窗口的最大值" class="headerlink" title="面试题59-1：滑动窗口的最大值"></a>面试题59-1：滑动窗口的最大值</h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><p>直接使用暴力法的时间复杂度为$O(k(n-k))$，其实还是可以接受的。但是当<code>k</code>约为<code>n/2</code>时时间复杂度退化到$O(n^2)$。</p><p>其中主要的性能浪费在查找范围为<code>k</code>的数据的最大值，我们可以使用一个容量为<code>k</code>的<code>优先队列</code>，也就是<code>大顶堆</code>来进行优化。这样时间复杂度可以优化到$O(n \log k)$。</p><p>最后，我们可以用双向队列设计一个能够在$O(1)$的时间实现查找最大值的容器，其实也就是下一题“队列的最大值”中实现的<code>MaxQueue</code>。<code>MaxQueue</code>的插入、删除以及寻找最大值的操作时间复杂度均为$O(1)$，但是我们这里只需要寻找最大值的操作，因此有所简化，这样整体的时间复杂度便只有$O(n)$了，具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!q.isEmpty() &amp;&amp; q.peek() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">                q.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; nums[q.peekLast()] &lt;= nums[i]) &#123;</span><br><span class="line">                q.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            q.offer(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                res[idx++] = nums[q.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题59-2：队列的最大值"><a href="#面试题59-2：队列的最大值" class="headerlink" title="面试题59-2：队列的最大值"></a>面试题59-2：队列的最大值</h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1。</p><h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><p>思路：用两个队列来完成任务：一个队列保存正常元素，<strong>另一个双向队列保存单调递减的元素。</strong></p><p>入栈时，第一个队列正常入栈；<strong>第二个队列是递减队列</strong>，所以需要与之前的比较，从尾部把小于当前value的全部删除（因为用不到了）。出栈时，第一个队列正常出栈；第二个队列的头部与出栈的值作比较，如果相同，那么一起出栈。具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; data;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; maxQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        maxQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> maxQueue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        data.offer(value);</span><br><span class="line">        <span class="keyword">while</span> (!maxQueue.isEmpty() &amp;&amp; value &gt; maxQueue.peekLast()) &#123;</span><br><span class="line">            maxQueue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        maxQueue.offer(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = data.poll();</span><br><span class="line">        <span class="keyword">if</span> (ans == maxQueue.peek()) maxQueue.poll();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题60：n个骰子的点数"><a href="#面试题60：n个骰子的点数" class="headerlink" title="面试题60：n个骰子的点数"></a>面试题60：n个骰子的点数</h2><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br></pre></td></tr></table></figure><h3 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h3><p>动态规划题。假设<code>f(i, j)</code>代表<code>i</code>个骰子的点数之和为<code>j</code>的个数，有递推公式<code>f(i, j) = f(i-1, j-1) + f(i-1, j-2) + ... + f(i-1, j-6)</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] twoSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">6</span> * n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = <span class="number">6</span> * i + <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt;= right; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j &amp;&amp; k &lt;= <span class="number">6</span>; k++) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> count = Math.pow(<span class="number">6</span>, n);</span><br><span class="line">        <span class="keyword">int</span> left = n, right = <span class="number">6</span> * n;</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= right; i++) &#123;</span><br><span class="line">            res[i - left] = dp[n - <span class="number">1</span>][i] / count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题61：扑克牌中的顺子"><a href="#面试题61：扑克牌中的顺子" class="headerlink" title="面试题61：扑克牌中的顺子"></a>面试题61：扑克牌中的顺子</h2><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><h3 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h3><p>先对数组进行排序，利用每一张大小王可以填补一个空缺，遍历数组统计<code>0</code>的数目，最后，在剩余的牌中检测是否可以借助一定数量的大小王（即任意牌）凑成顺子，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            count -= nums[i + <span class="number">1</span>] - nums[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题62：圆圈中最后剩下的数字"><a href="#面试题62：圆圈中最后剩下的数字" class="headerlink" title="面试题62：圆圈中最后剩下的数字"></a>面试题62：圆圈中最后剩下的数字</h2><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><h3 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h3><p>此题就是有名的<code>约瑟夫环</code>问题。通常有两种解法，第一种方法是用环装链表链表模拟模拟圆圈的经典解法，第二种方法是分析每次被删除的数字的规律并直接计算出圆圈中最后剩下的数字。</p><p>对于第一种方法，在java中可以使用<code>数组</code>来模拟，当某个位置被删除时将其置为<code>-1</code>，这样时间复杂度为$O(mn)$；当然也可以使用<code>链表</code>或者<code>队列</code>，经过计算很容易得出时间复杂度仍然是$O(mn)$</p><p>对于第二种的数学方法，我们定义一个关于<code>n</code>和<code>m</code>的方程<code>f(n, m)</code>，表示每次在<code>n</code>个数字<code>0, 1, 2, ..., n-1</code>中删除第<code>m</code>个数字最后剩下的数字，需要费点力气来找规律，这里直接给出答案：</p><ul><li><code>f(n, m) = 0, n = 1</code></li><li><code>f(n, m) = [f(n - 1, m) + m] % n, n &gt; 1</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (lastRemaining(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题63：股票的最大利润"><a href="#面试题63：股票的最大利润" class="headerlink" title="面试题63：股票的最大利润"></a>面试题63：股票的最大利润</h2><h3 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><h3 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h3><p>股票的利润来源于买入和卖出的价格差，当我们在第<code>i</code>天想要卖出时，那么应该在第<code>1~i-1</code>天中最低的价格买入，因此利用一个变量来表示到目前元素前的最小值，便可以得到在第<code>i</code>天卖出时的最大利润，进而便知道了全局最大利润：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastMin = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, prices[i] - lastMin);</span><br><span class="line">            lastMin = Math.min(lastMin, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题64：求1-2-…-n"><a href="#面试题64：求1-2-…-n" class="headerlink" title="面试题64：求1+2+…+n"></a>面试题64：求1+2+…+n</h2><h3 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h3><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h3 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h3><p>使用递归解法最重要的是指定返回条件，但是本题无法直接使用<code>if</code>语句来指定返回条件。</p><p><strong>条件与&amp;&amp;具有短路原则，即在第一个条件语句为false的情况下不会去执行第二个条件语句。</strong> 利用这一特性，将递归的返回条件取非然后作为<code>&amp;&amp;</code>的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为true的情况下就不会执行递归的主体部分，递归返回。</p><p>本题的递归返回条件为 <code>n &lt;= 0</code>，取非后就是 <code>n &gt; 0</code>；递归的主体部分为<code>n += sumNums(n - 1)</code>，转换为条件语句后就是<code>(n += sumNums(n-1)) &gt; 0</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题65：不用加减乘除做加法"><a href="#面试题65：不用加减乘除做加法" class="headerlink" title="面试题65：不用加减乘除做加法"></a>面试题65：不用加减乘除做加法</h2><h3 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><h3 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h3><p>四则运算不能使用了，我们还有<code>位运算</code>。<strong>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</strong> 所以<code>a + b = (a ^ b) + ((a &amp; b) &lt;&lt; 1)</code>，不断进行该步骤，直到进位为 0，相关代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a ^ b;</span><br><span class="line">            a = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题66：构建乘积数组"><a href="#面试题66：构建乘积数组" class="headerlink" title="面试题66：构建乘积数组"></a>面试题66：构建乘积数组</h2><h3 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组<code>A[0,1,…,n-1]</code>，请构建一个数组<code>B[0,1,…,n-1]</code>，其中<code>B</code>中的元素<code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。不能使用除法。</p><h3 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h3><p>题目中说明不能使用除法，可以简单思考一下如果能使用除法应该怎么做？我们可以先将所有的数组<code>A</code>的所有乘积求出来：<code>C = A[0] * A[1] * ... * A[n-1]</code>，此时可以得到<code>B[i] = C / A[i]</code>，但是需要注意的是数组<code>A</code>中可能会有元素为 0，需要额外处理。</p><p>现在不能使用除法，应该如何思考呢？我们可以将<code>B[i]</code>分成<code>A[0]*A[1]*...*A[i-1]</code>和<code>A[i+1]*A[i+2]*...*A[n-1]</code>两部分，所以可以：</p><ol><li>从左往右遍历累乘，结果保存在数组<code>res</code>中，此时<code>res[i]</code>表示<code>A[i]</code>左边所有元素的乘积</li><li>然后从右往左遍历累乘，获取<code>A[i]</code>右边所有元素的乘积</li><li>两边遍历之后得到的<code>res</code>，就是最终结果</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            res[i] = left;</span><br><span class="line">            left *= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] *= right;</span><br><span class="line">            right *= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题67：把字符串转换成整数"><a href="#面试题67：把字符串转换成整数" class="headerlink" title="面试题67：把字符串转换成整数"></a>面试题67：把字符串转换成整数</h2><h3 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h3><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><h3 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h3><p>这类题主要是处理一些特殊问题，锻炼处理异常情况的能力，在这里就不贴代码了。</p><h2 id="面试题68-1：二叉搜索树的最近公共祖先"><a href="#面试题68-1：二叉搜索树的最近公共祖先" class="headerlink" title="面试题68-1：二叉搜索树的最近公共祖先"></a>面试题68-1：二叉搜索树的最近公共祖先</h2><h3 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><div align=center><img src="http://image.yingzq.com/img/20200222000234.png" width="300" /></div><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6</span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h3 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h3><p>看清题目到底是<code>二叉树</code>还是<code>二叉搜索树</code>，虽然都是递归的结构，但是<code>二叉搜索树</code>的要求更严格些，所以在很多情况下两者的思路不太一样。</p><p>对于二叉搜索树：</p><ol><li>当根节点为空时直接返回</li><li>当<code>p</code>和<code>q</code>的值均小于根节点值时，应该递归的去左子树寻找</li><li>当<code>p</code>和<code>q</code>的值均大于根节点值时，应该递归的去右子树寻找</li><li>当根节点的值在<code>p</code>和<code>p</code>之间时，证明此时根节点即为最近公共祖先。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题68-2：二叉树的最近公共祖先"><a href="#面试题68-2：二叉树的最近公共祖先" class="headerlink" title="面试题68-2：二叉树的最近公共祖先"></a>面试题68-2：二叉树的最近公共祖先</h2><h3 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><div align=center><img src="http://image.yingzq.com/img/20200222000524.png" width="300" /></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><h3 id="分析-24"><a href="#分析-24" class="headerlink" title="分析"></a>分析</h3><p>对于二叉树，节点值的相对大小便没有意义了，我们需要在左右子树中查找是否存在<code>p</code>或者<code>p</code>，如果<code>p</code>和<code>q</code>分别在两个子树中，那么就说明根节点就是最低公共祖先。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《剑指offer第二版》阅读笔记最后一个部分，记录了书中面试题51到最后的部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://www.yingzq.com/tags/Java/"/>
    
      <category term="阅读笔记" scheme="http://www.yingzq.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer第二版》阅读笔记（二）</title>
    <link href="http://www.yingzq.com/2020/02/20/sword-finger-offer-notes-part-two/"/>
    <id>http://www.yingzq.com/2020/02/20/sword-finger-offer-notes-part-two/</id>
    <published>2020-02-20T12:06:52.000Z</published>
    <updated>2020-03-29T05:29:45.396Z</updated>
    
    <content type="html"><![CDATA[<p>《剑指offer第二版》阅读笔记第二部分，记录了书中面试题26~50的部分。</p><a id="more"></a><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="/2020/02/19/sword-finger-offer-notes/" title="《剑指offer第二版》阅读笔记（一）">《剑指offer第二版》阅读笔记（一）</a></li><li><a href="/2020/02/20/sword-finger-offer-notes-part-two/" title="《剑指offer第二版》阅读笔记（二）">《剑指offer第二版》阅读笔记（二）</a></li><li><a href="/2020/02/21/sword-finger-offer-notes-part-three/" title="《剑指offer第二版》阅读笔记（三）">《剑指offer第二版》阅读笔记（三）</a></li></ul><h2 id="面试题26：树的子结构"><a href="#面试题26：树的子结构" class="headerlink" title="面试题26：树的子结构"></a>面试题26：树的子结构</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的树 A:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line"></span><br><span class="line">给定的树 B：</span><br><span class="line">   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line"></span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>首先树的这类问题，没有特殊要求一般使用递归更简洁，更利于理解。</strong></p><p>此题可以递归进行对比，前序遍历树<code>A</code>，不妨假设当前遍历的子树根节点为<code>rootA</code>，只存在三种情况：</p><ol><li>以<code>rootA</code>为根节点的子树结构与树<code>B</code>相同</li><li>与<code>B</code>相同的子树结构存在于<code>rootA</code>的左子树</li><li>与<code>B</code>相同的子树结构存在于<code>rootA</code>的右子树</li></ol><p>不满足以上三种情况，则<code>B</code>不是<code>A</code>的子树结构。</p><p>按照这种思想，有如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isMatch(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(TreeNode rootA, TreeNode rootB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rootB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (rootA == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (rootA.val != rootB.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isMatch(rootA.left, rootB.left) &amp;&amp; isMatch(rootA.right, rootB.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题27：二叉树的镜像"><a href="#面试题27：二叉树的镜像" class="headerlink" title="面试题27：二叉树的镜像"></a>面试题27：二叉树的镜像</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br><span class="line"></span><br><span class="line">镜像输出：</span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><strong>还是那句话：时刻要想到二叉树的子树仍然是二叉树。</strong></p><p>对于当前根节点<code>root</code>，它的左子树和右子树也都是二叉树，将<code>root</code>的左节点和右节点进行交换，如果它的左子树和右子树不为空，则接着递归进行处理，非常简单，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode left = mirrorTree(root.left);</span><br><span class="line">        TreeNode right = mirrorTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题28：对称的二叉树"><a href="#面试题28：对称的二叉树" class="headerlink" title="面试题28：对称的二叉树"></a>面试题28：对称的二叉树</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>和上面几题是一样的思考方式，对于当前根节点<code>root</code>，需要保证<code>root.left.val == root.right.val</code>，但是这是不够的，我们需要接着将<code>root</code>的左右子节点当做根节点递归的进行判断，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> left == right;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有个小trick是<code>if (left == null || right == null) return left == right;</code>，可以一句话判断<code>left和right有且仅有一个是空</code>。</p><h2 id="面试题29：顺时针打印矩阵"><a href="#面试题29：顺时针打印矩阵" class="headerlink" title="面试题29：顺时针打印矩阵"></a>面试题29：顺时针打印矩阵</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>对于这样一个复杂的操作，我们可以画图辅助进行分析，同时寻找规律。在画图的过程中我们可以发现矩阵在一圈一圈的变小，直到没有数据可以继续顺时针转圈。对于顺时针转圈这个动作来说，其实分为4个步骤：向右移动、向下移动、向左移动、向上移动，移动的时候范围会逐渐缩小，执行完这4个步骤后会回到新的起点，然后重复的进行这样的动作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rowBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rowEnd = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> colBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> colEnd = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd) &#123;</span><br><span class="line">            <span class="comment">// Traverse Right</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = colBegin; j &lt;= colEnd; j++) &#123;</span><br><span class="line">                res.add(matrix[rowBegin][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            rowBegin++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Traverse Down</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowBegin; j &lt;= rowEnd; j++) &#123;</span><br><span class="line">                res.add(matrix[j][colEnd]);</span><br><span class="line">            &#125;</span><br><span class="line">            colEnd--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rowBegin &lt;= rowEnd) &#123;</span><br><span class="line">                <span class="comment">// Traverse Left</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = colEnd; j &gt;= colBegin; j--) &#123;</span><br><span class="line">                    res.add(matrix[rowEnd][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rowEnd--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colBegin &lt;= colEnd) &#123;</span><br><span class="line">                <span class="comment">// Traver Up</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = rowEnd; j &gt;= rowBegin; j--) &#123;</span><br><span class="line">                    res.add(matrix[j][colBegin]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            colBegin++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题30：包含min函数的栈"><a href="#面试题30：包含min函数的栈" class="headerlink" title="面试题30：包含min函数的栈"></a>面试题30：包含min函数的栈</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>这是一个很经典也很实用的结构，一般来说，查找当前栈中的最小值是需要遍历整个栈，花费$O(n)$的时间复杂度才能够完成的。</p><p>一开始能想到的方法便是利用空间换时间，我们可以增加一个额外的辅助栈，辅助栈大小与原数据栈保持一致，记录着相应位置的最小值，空间复杂度为$O(n)$，具体操作如下：</p><ul><li>进行<code>push</code>时，数据栈直接进行<code>push</code>新元素，辅助栈则需要判断新数据是否大于栈顶元素，如果是则接着<code>push</code>栈顶元素，否则便<code>push</code>新元素，因为可以证明这个时候的新元素是已有数据里最小的。</li><li>进行<code>pop</code>时，两个栈均直接进行<code>pop</code>即可</li><li><code>min</code>操作则对辅助栈进行<code>peek</code>操作即可，具有$O(1)$的时间复杂度</li></ul><p>有没有方法可以不需要开辟额外栈呢？其实也是可以的，我们只需要一个数据栈，只不过进行<code>push</code>操作时，如果当前压入的值不大于当前最小值，则压入一个当前最小值，再压入当前的值！这样我们在<code>pop</code>的时候，便可以知道在某个时刻，最小值被弹出了，但是它的下一个弹出元素是第二小的元素！此方法具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= min) &#123;</span><br><span class="line">            stack.push(min);</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pop = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pop == min) &#123;</span><br><span class="line">            min = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题31：栈的压入、弹出序列"><a href="#面试题31：栈的压入、弹出序列" class="headerlink" title="面试题31：栈的压入、弹出序列"></a>面试题31：栈的压入、弹出序列</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>这一题经常出现在数据结构与算法课程的选择题中，给出4个选项判断选项的弹出序列是否可能，我们会根据选项的弹出序列来模拟可能的压栈、出栈顺序，最终判断该选项的弹出序列是否可能。</p><p>其实将这个过程用代码写出的时候是一样的思路，把<code>pushed</code>序列模拟入栈，当遇到栈顶元素等于<code>poped[idx]</code>，模拟出栈过程，如果能匹配（idx能指向序列末尾），那么<code>poped</code>是压栈序列的弹出序列，具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : pushed) &#123;</span><br><span class="line">            stack.push(x);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[idx]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx == pushed.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题32-1：从上到下打印二叉树"><a href="#面试题32-1：从上到下打印二叉树" class="headerlink" title="面试题32-1：从上到下打印二叉树"></a>面试题32-1：从上到下打印二叉树</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>很明显直接使用BFS即可。</p><h2 id="面试题32-2：从上到下打印二叉树-II"><a href="#面试题32-2：从上到下打印二叉树-II" class="headerlink" title="面试题32-2：从上到下打印二叉树 II"></a>面试题32-2：从上到下打印二叉树 II</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>这一题虽然很简单，但是很经典，所以会贴一下具体代码。这种遍历方式其实是有名字的，叫做二叉树的<code>层序遍历</code>，首先明显可以使用BFS进行处理；另外使用DFS也是可以处理的，两种思路很容易理解，主要可以学习一下此类问题代码的写法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// BFS</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = q.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) q.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// DFS</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (depth == res.size()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(depth).add(root.val);</span><br><span class="line">        dfs(root.left, res, depth + <span class="number">1</span>);</span><br><span class="line">        dfs(root.right, res, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题32-3：从上到下打印二叉树-III"><a href="#面试题32-3：从上到下打印二叉树-III" class="headerlink" title="面试题32-3：从上到下打印二叉树 III"></a>面试题32-3：从上到下打印二叉树 III</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>和上一题非常类似，只不过其中奇数层（从0开始算）需要倒着打印，所以同样我们可以和上一题使用相同的BFS和DFS这两种方法，但是在特定行需要反着打印该如何处理呢？这里有两个问题需要解决：</p><ol><li>哪些行需要反着打印？我们可以根据<code>当前的行数的奇偶性</code>来确定，也可以通过每迭代一行就反转一次的<code>boolean变量</code>来控制。</li><li>如何反着打印？我们可以使用<code>LinkedList</code>，也就是链表来进行插入数据，当需要正着打印时可以<code>addLast</code>，需要反着打印时可以<code>addFirst</code>，均为$O(1)$的时间复杂度。</li></ol><p>其他的细节和上一题一模一样，不再敖述。</p><h2 id="面试题33：二叉搜索树的后序遍历序列"><a href="#面试题33：二叉搜索树的后序遍历序列" class="headerlink" title="面试题33：二叉搜索树的后序遍历序列"></a>面试题33：二叉搜索树的后序遍历序列</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>首先注意是<strong>二叉搜索树</strong>而不是二叉树，这是很重要的一点，对于二叉搜索树有<strong>左子树元素均比根节点小，右子树均比根节点大</strong>，其次，要深刻的认识后序遍历的特点：<code>左子树 -&gt; 右子树 -&gt; 根节点</code>，因此<strong>后序遍历数组的最后一个元素是根节点</strong>。</p><p>利用上面提到的知识点，每次先找到根节点（也就是最后一个元素），然后确定左右子树，并判断左右子树是否合法，然后找到左右子树的根节点，和一般处理二叉树的问题一样，递归进行判断，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder == <span class="keyword">null</span> || postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">        <span class="keyword">for</span> (idx = start; idx &lt; end; idx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[idx] &gt; postorder[end]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &lt; postorder[end]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(postorder, start, idx - <span class="number">1</span>) &amp;&amp; helper(postorder, idx, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题34：二叉树中和为某一值的路径"><a href="#面试题34：二叉树中和为某一值的路径" class="headerlink" title="面试题34：二叉树中和为某一值的路径"></a>面试题34：二叉树中和为某一值的路径</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定如下二叉树，以及目标和 sum &#x3D; 22，</span><br><span class="line"></span><br><span class="line">              5</span><br><span class="line">             &#x2F; \</span><br><span class="line">            4   8</span><br><span class="line">           &#x2F;   &#x2F; \</span><br><span class="line">          11  13  4</span><br><span class="line">         &#x2F;  \    &#x2F; \</span><br><span class="line">        7    2  5   1</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p>很明显使用回溯法即可，需要注意的是<code>叶子节点</code>的定义：<strong>一棵树中没有子结点（即度为0）的结点称为叶子结点。</strong> 另外，在回溯法中使用tempList不断的进行改变时，在方法结束的时候需要删除对应元素再返回。</p><p>对应的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(root, sum, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode root, <span class="keyword">int</span> remain, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        remain -= root.val;</span><br><span class="line">        tempList.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (remain == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        backtrack(root.left, remain, res, tempList);</span><br><span class="line">        backtrack(root.right, remain, res, tempList);</span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于要判断叶子节点，所以递归的终止条件是<code>root.left == null &amp;&amp; root.right == null</code>而不是一般的<code>root == null</code>，这是需要注意的。</p></blockquote><h2 id="面试题35：复杂链表的复制"><a href="#面试题35：复杂链表的复制" class="headerlink" title="面试题35：复杂链表的复制"></a>面试题35：复杂链表的复制</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p><strong>示例</strong></p><div align=center><img src="http://image.yingzq.com/img/20200220231538.png" width="650" /></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>在复制复杂链表的时候，最麻烦的地方在于<code>random</code>指针的处理，例如在复制位置为 3 的复杂链表时，<code>random</code>却指向了位置为 100 的复杂链表，如果强行去找，那么整体的复杂度可能达到$O(n^2)$。</p><p>首先想到的方法是借助一个<code>HashMap</code>，想到使用哈希表的原因是在链表中的查找是$O(n)$的但是在哈希表中的查找却是非常廉价的$O(1)$，虽然使用了$O(n)$的空间复杂度，但是解法思路很清晰，还是值得借鉴的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么有没有不使用辅助空间的方法呢？前面讲到复制复杂链表的难处在于<code>random</code>指针的复制，但是其实原复杂链表的<code>random</code>指针是已经建立完毕的，可以随时达到指定的位置，我们可以利用这一点，建立以下无需额外空间，并且时间复杂度为$O(n)$的算法：</p><ol><li>在每个节点的后面插入复制的节点</li><li>对复制节点的<code>random</code>链接进行赋值，每一次赋值只需要$O(1)$的时间复杂度</li><li>将复制节点拆分出来，生成结果</li></ol><p>相应的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 第一步：插入新节点</span></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            cur.next.next = next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二步：复制random指针</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第三步：拆分</span></span><br><span class="line">        cur = head;</span><br><span class="line">        Node copyHead = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = cur.next;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            <span class="keyword">if</span> (next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                next.next = next.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copyHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在链表进行<code>while</code>循环的时候，不要忘记更新链表状态，也就是<code>cur = cur.next</code>这些语句。</p></blockquote><h2 id="面试题36：二叉搜索树与双向链表"><a href="#面试题36：二叉搜索树与双向链表" class="headerlink" title="面试题36：二叉搜索树与双向链表"></a>面试题36：二叉搜索树与双向链表</h2><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>以下面的二叉搜索树为例：</p><div align=center><img src="http://image.yingzq.com/img/20200220235751.png" width="400" /></div><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><div align=center><img src="http://image.yingzq.com/img/20200220235953.png" width="600" /></div><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><p>这一题看起来比较复杂，但是其实题目中已经暗含了解决方法：<code>二叉搜索树</code>以及<code>排序的xx</code>，所以肯定是会用到中序遍历的，因为<strong>二叉搜索树的中序遍历是一个递增序列</strong>。实现中序遍历既可以使用迭代，也可以使用递归，使用递归的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        inorder(root);</span><br><span class="line">        Node head = root;</span><br><span class="line">        <span class="keyword">while</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = head.left;</span><br><span class="line">        &#125;</span><br><span class="line">        Node tail = root;</span><br><span class="line">        <span class="keyword">while</span> (tail.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = tail.right;</span><br><span class="line">        &#125;</span><br><span class="line">        head.left = tail;</span><br><span class="line">        tail.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        root.left = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) prev.right = root;</span><br><span class="line">        prev = root;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题37：序列化二叉树"><a href="#面试题37：序列化二叉树" class="headerlink" title="面试题37：序列化二叉树"></a>面试题37：序列化二叉树</h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure><h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><p>可以使用<code>前序遍历</code>来进行序列化，但是普通的前序遍历在遍历到<code>null</code>时便跳过了，所以上面二叉树的前序遍历结果应该为<code>[1,2,3,4,5]</code>，但是前序遍历是<code>[1,2,3,4,5]</code>的二叉树并不是唯一的，因此在遇到<code>null</code>时不能简单的跳过，我们可以将<code>null</code>映射成为一个特殊字符放入到前序遍历的结果中，进而使得通过前序遍历的结果便可以确定相应的二叉树。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String splitter = <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NN = <span class="string">"$"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        buildString(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildString</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            sb.append(NN).append(splitter);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(root.val).append(splitter);</span><br><span class="line">            buildString(root.left, sb);</span><br><span class="line">            buildString(root.right, sb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.addAll(Arrays.asList(data.split(splitter)));</span><br><span class="line">        <span class="keyword">return</span> buildTree(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(Queue&lt;String&gt; q)</span> </span>&#123;</span><br><span class="line">        String s = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (s.equals(NN)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(s));</span><br><span class="line">        root.left = buildTree(q);</span><br><span class="line">        root.right = buildTree(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题38：字符串的排列"><a href="#面试题38：字符串的排列" class="headerlink" title="面试题38：字符串的排列"></a>面试题38：字符串的排列</h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><p>将字符串看做字符数组，其实就是<code>回溯问题</code>，额外添加一个<code>visited</code>数组来判断某位置的字符是否已经使用就可以了。唯一需要注意的是字符可能有相同的，例如<code>s = &quot;aba&quot;</code>，这样直接回溯的话会产生非常多的重复解，处理此类问题的方法是在最开始对字符数组<code>排序</code>，这样重复的元素会在相邻的位置，此时便可以利用<code>i &gt; 0 &amp;&amp; chars[i-1] == chars[i] &amp;&amp; !visited[i-1]</code>来舍弃掉重复情况了。</p><blockquote><p>注：处理回溯问题其实是有一定技巧的，在 <a href="/2020/03/14/a-general-approach-to-backtracking-questions/" title="这里">这里</a> 总结了一种通用的处理方法。</p></blockquote><h2 id="面试题39：数组中出现次数超过一半的数字"><a href="#面试题39：数组中出现次数超过一半的数字" class="headerlink" title="面试题39：数组中出现次数超过一半的数字"></a>面试题39：数组中出现次数超过一半的数字</h2><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h3 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h3><p>对于排序、使用哈希表在这个题目中很显然是不可取的，不再考虑。</p><p>首先可以使用快排中<code>partition</code>的思想，如果选中的数字经过<code>partition</code>操作后<strong>下标刚好是n/2</strong>，证明这个数字是数组的中位数，也就是需要返回的<code>多数元素</code>；如果下标小于n/2，则接着搜索右半分区，如果下标大于n/2，则接着搜索左半分区。该算法的时间复杂度是$O(n)$，<strong>但是需要注意的是基于<code>partition</code>的方法会修改原数组，因此如果原数组不能修改则不能使用此方法。</strong></p><p>除了<code>partition</code>的方法，其实最简单快捷的方法是使用<code>摩尔投票算法（Boyer-Moore Majority Vote Algorithm）</code>，摩尔投票算法便是要解决本题目所描述的问题，摩尔投票算法基于这个事实：<strong>每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个</strong>，下面直接给出代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> major = nums[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                major = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (major == nums[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题40：最小的k个数"><a href="#面试题40：最小的k个数" class="headerlink" title="面试题40：最小的k个数"></a>面试题40：最小的k个数</h2><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><h3 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h3><p>这一题虽然很简单，但是比较经典，所以写的详细点。</p><p><strong>解法1 快排的partition思想</strong></p><p>首先需要强调，<strong>使用<code>partition</code>来解决问题时会改变原数组，所以只有原数组可以修改时才可以使用<code>partition</code>来解题。</strong></p><p>快速排序的<code>partition</code>方法，会返回一个整数<code>j</code>使得<code>a[lo..j-1]</code>小于等于<code>a[j]</code>，且<code>a[j+1..hi]</code>大于等于<code>a[j]</code>，此时<code>a[j]</code>就是数组的第<code>j</code>大元素。可以利用这个特性找出数组的第<code>k</code>个元素，算法时间复杂度为$O(n)$，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = partition(arr, lo, hi);</span><br><span class="line">            <span class="keyword">if</span> (pos == k) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; k) lo = pos + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = pos - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数组切分为arr[lo..i-1], arr[i], arr[i+1..hi]</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;  <span class="comment">// 左右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> v = arr[lo];  <span class="comment">// 切分元素，即pivot</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 扫描左右，检查扫描是否结束并交换元素</span></span><br><span class="line">            <span class="keyword">while</span> (arr[++i] &lt; v) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (arr[--j] &gt; v) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, lo, j);  <span class="comment">// 将切分元素v放入正确的位置</span></span><br><span class="line">        <span class="keyword">return</span> j;  <span class="comment">// arr[lo..j-1] &lt;= arr[j] &lt;= arr[j+1..hi]达成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的<code>partition</code>方法代码摘抄自《算法4》，值得注意的是需要保证传入的参数满足<code>lo &lt; hi</code>时方法才能正常运行。其实也有很多其他版本的写法，例如下面一种，个人认为理解起来很容易：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">    <span class="keyword">int</span> pivotIdx = lo;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="comment">// 两个内循环的顺序是不能颠倒的</span></span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; arr[hi] &gt;= pivot) hi--;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; arr[lo] &lt;= pivot) lo++;</span><br><span class="line">        swap(arr, lo, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivotIdx, hi);</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法2 使用大顶堆</strong></p><p>我们可以创建一个大小为<code>k</code>的<code>大顶堆</code>，接下来不断的读入数据，当<code>大顶堆</code>的数据数量小于<code>k</code>时直接将新数据放入其中，当<code>大顶堆</code>中已经有<code>k</code>个数据时，此时一共有<code>k+1</code>个数据，我们需要舍去一个不可能是最小的k个最小元素之一的数据，这个数据只能是新数据或者是堆顶元素，我们比较这两个元素，当新数据更大时舍弃新数据，反正舍弃堆顶元素并把新数据插入<code>大顶堆</code>中，时间复杂度为$O(n\log k)$，相应代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pq.peek() &gt; num) &#123;</span><br><span class="line">                    pq.poll();</span><br><span class="line">                    pq.offer(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : pq) &#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题41：数据流中的中位数"><a href="#面试题41：数据流中的中位数" class="headerlink" title="面试题41：数据流中的中位数"></a>面试题41：数据流中的中位数</h2><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，[2,3,4] 的中位数是 3；[2,3] 的中位数是 (2 + 3) / 2 = 2.5。</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><h3 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h3><p>我们需要选择一种(或多种)容器来存放已有数据，最简单的容器是<code>动态数组</code>或者是<code>链表</code>，但是这两种容器在该问题下的性能并不理想：每次插入数据后需要排序，两种容器的时间复杂度均为$O(n)$。<code>二叉搜索树</code>可以把插入数据的的平均时间复杂度降低为$O(\log n)$级别，但是最差仍然是$O(n)$级别，因此可以使用<code>平衡二叉树（如AVL树）</code>来进行改进，通常AVL树的平衡因子是左右子树的高度差，可以稍作修改，把AVL树的平衡因子改为左右子树节点数目之差，这样便可以用$O(\log n)$的时间复杂度插入数据，而只需要$O(1)$的时间复杂度求出中位数。</p><p>但是调用AVL树略显麻烦，有更好的方法吗？中位数其实将数据分成了两部分：左半部分小于中位数、右半部分大于中位数，且这两部分的数量相等或者仅差一，且<strong>中位数只和左边数据的最大值以及右边数据的最小值有关</strong>。因此，可以使用<code>大小堆</code>来解决问题：用一个<code>大顶堆</code>实现左边的数据容器，用一个<code>小顶堆</code>实现右边的数据容器，这样插入新数据时时间复杂度为$O(\log n)$，当求中位数时其实只和两个堆顶元素有关，因此时间复杂度为$O(1)$，具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap, minHeap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b - a);  <span class="comment">// 大顶堆</span></span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();  <span class="comment">// 小顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的处理流程需要仔细考虑</span></span><br><span class="line">        maxHeap.offer(num);</span><br><span class="line">        minHeap.offer(maxHeap.poll());</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() &lt; minHeap.size()) &#123;</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == minHeap.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span> * (maxHeap.peek() + minHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题42：连续子数组的最大和"><a href="#面试题42：连续子数组的最大和" class="headerlink" title="面试题42：连续子数组的最大和"></a>面试题42：连续子数组的最大和</h2><h3 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><h3 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h3><p>很明显使用<code>动态规划</code>来做，假设<code>f(i)</code>代表以<code>i</code>位置结尾的所有子数组中的和最大值，我们有如下递推公式：</p><ul><li>当<code>f(i-1) &lt;= 0</code>时，<code>f(i) = nums[i]</code></li><li>当<code>f(i-1) &gt; 0</code>时，<code>f(i) = f(i-1) + nums[i]</code></li></ul><p>最后，自底向上的写出相应代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>] + nums[i] : nums[i];</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：上面的代码很直观，很简洁，但是这里可以对空间再优化。由于<code>dp[i]</code>只用到了<code>dp[i-1]</code>，所以其实只需要用一个变量来保存上一次的状态就可以了。</p></blockquote><h2 id="面试题43：1～n整数中1出现的次数"><a href="#面试题43：1～n整数中1出现的次数" class="headerlink" title="面试题43：1～n整数中1出现的次数"></a>面试题43：1～n整数中1出现的次数</h2><h3 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次</p><h3 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h3><p>一个比较直观的方法是从1到n进行遍历，对于其中的每一个数字，求出其中1的个数，最后累加所有数字的结果便得到最终结果，时间复杂度为$O(n \log n)$，但是这样运行程序时会超时。</p><p>所以我们不能一个数一个数的处理，需要将很多个数放在一起看，也就是<strong>找规律</strong>。</p><p>对于整数<code>234</code>来说，假设<code>f(n)</code>表示从 1 到 n 的所有数中 1 出现的次数。我们可以首先考虑最高位的情况，对于这个例子最高位为<code>2</code>，因此最高位等于 1 的情况为<code>100~199</code>，一共 <code>100</code> 个，对于个位和十位，由于最该位是<code>2</code>，所以这两位可以取<code>1~99</code>以及<code>100~199</code>，也就是有<code>2*f(99)</code>种情况，还有剩余的情况是<code>200~234</code>的时候个位和十位的情况，也就是相当于<code>f(34)</code>。因此总结如下：<code>f(234) = 100 + 2*f(99) + f(34)</code>。对于最高位为<code>1</code>的情况，稍微有点不同，例如对于<code>123</code>来说，最高位为 1 的情况只有 <code>24</code> 个，但是思路是一样的，整体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// x表示最高位，y表示10^(h-1)，h代表n的位数</span></span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">1</span>, x = n;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            y *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n - y + <span class="number">1</span> + countDigitOne(y - <span class="number">1</span>) + countDigitOne(n % y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> y + x * countDigitOne(y - <span class="number">1</span>) + countDigitOne(n % y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还有一些更数学的方法，将更多的精力花在了寻找更深层次的规律上，这里就不介绍了。</p><h2 id="面试题44：数字序列中某一位的数字"><a href="#面试题44：数字序列中某一位的数字" class="headerlink" title="面试题44：数字序列中某一位的数字"></a>面试题44：数字序列中某一位的数字</h2><h3 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><h3 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h3><p>首先能想到的方法便是按照顺序不断的生成数字<code>0, 1, 2, ...</code>，并记录已有数字的位数和，直到位数之和大于等于第 n 位，证明第 n 位数字一定在目前这个数字里，我们再从该数字中找到对应的那一位即可。</p><p>我们可以加快这个过程，例如求第<code>n = 1001</code>位对应的数字，只有一位的数字有<code>0~9</code>一共 10 个，所以这 10 个可以直接跳过，还需要向后寻找<code>1001-10=991</code>个， 同理，二位数范围是<code>10~99</code>，一共有 90 个，<code>90*2 &lt; 991</code>，因此这 90 个数也可以跳过，还需要寻找<code>991-90*2=811</code>个，接下来是 900 个 三位数，由于<code>900*3 &gt; 811</code>，因此第 811 位是某个三位数，由于<code>811=270*3+1</code>，说明 811 位是从 100 开始的第 270 个数即 370 的中间一位，也就是 7。</p><p>相应的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> digits = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = count(digits);</span><br><span class="line">            <span class="keyword">if</span> (n &lt; cnt) <span class="keyword">break</span>;</span><br><span class="line">            n -= cnt;</span><br><span class="line">            digits++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> resNum = (<span class="keyword">int</span>) (Math.pow(<span class="number">10</span>, digits - <span class="number">1</span>) + n / digits);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(resNum).charAt(n % digits) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="number">9</span> * digits * Math.pow(<span class="number">10</span>, digits - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题45：把数组排成最小的数"><a href="#面试题45：把数组排成最小的数" class="headerlink" title="面试题45：把数组排成最小的数"></a>面试题45：把数组排成最小的数</h2><h3 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line"></span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li><li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li></ul><h3 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h3><p>这道题最直接的方法是先求出这个数组所有数字的全排列，然后把每个排列拼接起来比较大小，但是 n 个数字共有 n! 个排列，复杂度太高。</p><p>这道题其实希望我们能找到一个排序规则，数组根据这个排序规则排序后能排列成一个最小的数字，根据题目的要求，两个数字<code>m</code>和<code>n</code>能够拼接成<code>mn</code>或者<code>nm</code>，如果<code>mn &lt; nm</code>应该定义<code>m</code>小于<code>n</code>，反之应该定义<code>m</code>大于<code>n</code>。</p><p>由于<code>m</code>和<code>n</code>的长度不一致，比较起来有些麻烦，我们可以转而比较字符串<code>mn</code>与字符串<code>nm</code>的相对大小。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        Arrays.sort(strs, (s1, s2) -&gt; (s1 + s2).compareTo(s2 + s1));</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs)</span><br><span class="line">            sb.append(str);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题46：把数字翻译成字符串"><a href="#面试题46：把数字翻译成字符串" class="headerlink" title="面试题46：把数字翻译成字符串"></a>面试题46：把数字翻译成字符串</h2><h3 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure><h3 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h3><p>首先可以使用递归，但是会计算很多重复情况，另外题目只要求输出翻译方法的个数，因此在这里选用<code>动态规划</code>。</p><p>假设<code>f(n)</code>表示翻译长度为<code>n</code>的字符串<code>s</code>有多少种方法，有如下递推公式：</p><ul><li><code>f(n) = f(n-1)</code></li><li>如果满足<code>s.charAt(n-1) == &#39;1&#39; || (s.charAt(n-1) == &#39;2&#39; &amp;&amp; s.charAt(n) &lt; &#39;6&#39;)</code>，则有<code>f(n) = f(n) + f(n-2)</code>。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>] = dp[i];</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'1'</span> || (s.charAt(i - <span class="number">1</span>) == <span class="string">'2'</span> &amp;&amp; s.charAt(i) &lt; <span class="string">'6'</span>)) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] += dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果题目是将 1 翻译成 “a” ，2 翻译成 “b”，……，12 翻译成 “l”，……，26 翻译成 “z”；这个时候情况会有所不同，<code>f(n) = f(n-1)</code>在当前字符是“0”时是不成立的。该题也是 <a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">LeetCode 91 解码方法</a> 的原题。</p><h2 id="面试题47：礼物的最大价值"><a href="#面试题47：礼物的最大价值" class="headerlink" title="面试题47：礼物的最大价值"></a>面试题47：礼物的最大价值</h2><h3 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><h3 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h3><p>同样使用<code>动态规划</code>来解决此类问题，假设<code>f(i, j)</code>表示到达位置<code>(i, j)</code>时能拿到的最大礼物价值，我们有递推公式<code>f(i, j) = max{f(i-1, j), f(i, j-1)} + gift[i, j]</code>。</p><p>在这里我们可以不开辟新的空间，直接在原棋盘上进行操作，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                grid[i][j] += Math.max(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题48：最长不含重复字符的子字符串"><a href="#面试题48：最长不含重复字符的子字符串" class="headerlink" title="面试题48：最长不含重复字符的子字符串"></a>面试题48：最长不含重复字符的子字符串</h2><h3 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><h3 id="分析-24"><a href="#分析-24" class="headerlink" title="分析"></a>分析</h3><p>是一道<code>滑动窗口</code>的题，使用<code>HashSet</code>或者<code>HashMap</code>可以很轻松的解决，在这一题中使用<code>HashSet</code>会有两层循环，但是整体的时间复杂度仍然是$O(n)$，下面给出使用<code>HashMap</code>的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                slow = Math.max(slow, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, i - slow + <span class="number">1</span>);</span><br><span class="line">            map.put(c, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，当确定字符串中只有小写字母时可以使用大小为 26 的数组起到哈希表的作用，当字符串中只有ASCII码字符时可以使用大小为 256 的数组起到哈希表的作用。</p><h2 id="面试题49：丑数"><a href="#面试题49：丑数" class="headerlink" title="面试题49：丑数"></a>面试题49：丑数</h2><h3 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h3><p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>1 是丑数。</li><li>n 不超过1690。</li></ol><h3 id="分析-25"><a href="#分析-25" class="headerlink" title="分析"></a>分析</h3><p>由于丑数的因子只有2、3和5，因此新丑数的生成是根据在旧丑数的基础上乘上2、3或5得到的。我们采用<code>动态规划+三个指针</code>来解决该问题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ugly = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(<span class="number">2</span> * ugly[p2], Math.min(<span class="number">3</span> * ugly[p3], <span class="number">5</span> * ugly[p5]));</span><br><span class="line">            ugly[i] = min;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">2</span> * ugly[p2]) p2++;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">3</span> * ugly[p3]) p3++;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">5</span> * ugly[p5]) p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题50-1：字符串中第一个只出现一次的字符"><a href="#面试题50-1：字符串中第一个只出现一次的字符" class="headerlink" title="面试题50-1：字符串中第一个只出现一次的字符"></a>面试题50-1：字符串中第一个只出现一次的字符</h2><h3 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。</p><h3 id="分析-26"><a href="#分析-26" class="headerlink" title="分析"></a>分析</h3><p>非常简单，利用<code>HashMap</code>遍历两次，第一次记录每个字符出现的次数，第二次找到第一个只出现一次的字符。</p><h2 id="面试题50-2：字符流中第一个只出现一次的字符"><a href="#面试题50-2：字符流中第一个只出现一次的字符" class="headerlink" title="面试题50-2：字符流中第一个只出现一次的字符"></a>面试题50-2：字符流中第一个只出现一次的字符</h2><h3 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，用来找出字符流中第一个只出现一次的字符。</p><p>注：字符属于ASCII码字符集</p><h3 id="分析-27"><a href="#分析-27" class="headerlink" title="分析"></a>分析</h3><p>字符流的意思是字符只能一个一个的出来并且是动态的，其实解法和上题类似，<strong>由于题目告诉我们字符是属于ASCII码字符集的，所以我们可以使用大小为 256 的数组来表示哈希表，以字符的ASCII码作为哈希表的key，字符对应的位置作为哈希表的value</strong>。然后将数组元素全部初始化为 <code>-1</code>，当读取到某个字符时将<code>字符位置</code>存入<code>value</code>中，如果之前读取过该字符（即<code>value &gt;= 0</code>），将<code>value</code>赋值为<code>-2</code>，代表重复出现过。最后对哈希表遍历，在<code>value &gt;= 0</code>的键值对中找到最小的<code>value</code>，该<code>value</code>所对应的<code>key</code>即为字符流中第一个只出现一次的字符。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《剑指offer第二版》阅读笔记第二部分，记录了书中面试题26~50的部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://www.yingzq.com/tags/Java/"/>
    
      <category term="阅读笔记" scheme="http://www.yingzq.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer第二版》阅读笔记（一）</title>
    <link href="http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/"/>
    <id>http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/</id>
    <published>2020-02-19T07:10:52.000Z</published>
    <updated>2020-03-29T05:13:47.522Z</updated>
    
    <content type="html"><![CDATA[<p>面试季来临，于是最近两天阅读了《剑指offer第二版》这本程序员面试必备书籍，全书题目不多，但是涵盖了许多重要的知识点，通过自己的阅读也收获良多，所以写下这个阅读笔记。该笔记对书中的面试题进行了自己的分析，相比于原书有的放矢，因此精简了很多，这样做一是加深自己对每个题的印象，二是可以方便今后复习时无需再次看原书，简单的过一下笔记就好。</p><a id="more"></a><blockquote><p>注：使用的《剑指offer第二版》是2017年出版的。另外，原书代码是C++，本文侧重于使用Java，但是其实编程语言并不是重点，主要是学习思想以及与编程语言无关的代码风格。</p></blockquote><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="/2020/02/19/sword-finger-offer-notes/" title="《剑指offer第二版》阅读笔记（一）">《剑指offer第二版》阅读笔记（一）</a></li><li><a href="/2020/02/20/sword-finger-offer-notes-part-two/" title="《剑指offer第二版》阅读笔记（二）">《剑指offer第二版》阅读笔记（二）</a></li><li><a href="/2020/02/21/sword-finger-offer-notes-part-three/" title="《剑指offer第二版》阅读笔记（三）">《剑指offer第二版》阅读笔记（三）</a></li></ul><h2 id="面试题3-1：找出数组中重复的数字"><a href="#面试题3-1：找出数组中重复的数字" class="headerlink" title="面试题3-1：找出数组中重复的数字"></a>面试题3-1：找出数组中重复的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个长度为 n 的数组 nums 里的所有数字都在 0~n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>有两个很容易想到的方案：</p><ol><li><code>排序</code>，然后遍历数组，判断nums[i] == nums[i-1]，时间复杂度$O(n\log n)$，空间复杂度$O(1)$</li><li><code>使用HashSet</code>，时间复杂度$O(n)$，空间复杂度$O(n)$</li></ol><p>但是这样题目中“所有数字都在 0~n-1 之间”的条件根本没有用到，这也提示我们需要认真阅读题中每一句话，而不能惯性思维，题目看到一半或者大致一看就开始码代码了。</p><p>那这个条件怎么用呢？由于所有的数字都在 0~n-1 之间，和数组的下标范围刚好一致，如果数组中没有重复数字，那么排序后数组的索引和数值会一一对应，即<code>nums[i] = i</code>，而真实情况是有一些数字是重复的，所以<strong>会有多个数字来竞争某个特定索引</strong>，这样便可以判断该索引对应的数字是有重复的。</p><p>那如何排序无重复数字的数组呢？我们可以遍历数组，每次遇到索引<code>i</code>，如果有<code>nums[i] == i</code>，说明此数字已在正确位置；否则需要将数字<code>nums[i]</code>放到正确的位置，即放在索引为<code>nums[i]</code>的位置，此时可以将索引为<code>i</code>和<code>nums[i]</code>的元素进行交换，这样索引为<code>nums[i]</code>的数字<code>nums[nums[i]]</code>便处于正确位置了。这样完成遍历后，所有的数字都会和自己的索引一一对应。</p><p>对于有重复数字的数组而言，会遇到<code>nums[i] != i</code>但是<code>nums[nums[i]] == nums[i]</code>，这说明在索引<code>nums[i]</code>的位置有两个数字竞争，也就是数字<code>nums[i]</code>肯定是重复的。</p><p>相应的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// nums[i]应该放到索引i的位置</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[nums[i]] == nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                swap(nums, i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然是双重循环，但是每一个数到达相应正确的位置后便不会变化了，总体时间复杂度为$O(n)$，空间复杂度$O(1)$。</p><p>这一题借助数组的下标作为key来寻找重复元素，其实本质上还是哈希表，只不过使用HashSet、HashMap明面上开辟了空间，而借助数组下标巧妙的节省了空间。因此对于元素在0~n-1、1~n甚至k~n+k-1之间的数组的相关问题，可以考虑这种思路。</p><h2 id="面试题3-2：不修改数组找出重复元素"><a href="#面试题3-2：不修改数组找出重复元素" class="headerlink" title="面试题3-2：不修改数组找出重复元素"></a>面试题3-2：不修改数组找出重复元素</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。请找出数组中任意一个重复的数字，但不能修改输入的数组。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>和上题一样，不修改原数组可以使用HashSet轻松完成，那么如何使用数字在1到n之间的条件来降低时间或空间复杂度呢？我们在这里还可以使用二分查找的思想，我们把1~n的数字从中间的数字m分成两部分，前一半为1~m，后一半为m+1~n，如果1~m之间的数字的数量大于m，则证明这一半的区间一定包含重复数字；否则，另一半m+1~n的区间里一定包含重复的数字，我们可以继续把包含重复数字的区间一分为二，直到找到一个重复数字，具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的时间复杂度为$O(n\log n)$，空间复杂度为$O(1)$。需要注意的是，这个算法并不能找出所有的重复数字，算法能work的重要点是数组长度是n+1而数字范围是1~n。</p><h2 id="面试题4：二维数组中的查找"><a href="#面试题4：二维数组中的查找" class="headerlink" title="面试题4：二维数组中的查找"></a>面试题4：二维数组中的查找</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br></pre></td></tr></table></figure><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>乍一看可以使用二分查找，但是会有点问题，对于任意<code>matrix[row][col]</code>，比它小的元素、比它大的元素都是一个不规则形状，而且是存在重叠的，所以是不好处理的。</p><p>注意到右上角元素的特殊性：是同一行的最大值，是同一列的最小值。如果target大于当前位置的值，则target肯定不处于当前行中，因为行已经排序，所以考虑下一行；反之如果target小于当前位置的值，则target肯定不处于当前列中，因为列同样已经排序，所以考虑前一列。每一次我们可以排除一行或者一列，总体的时间复杂度为$O(m+n)$，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; matrix[row][col]) &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：其实选取左下角的元素也是可以的，同样可以每次排除一行或者一列。</p></blockquote><h2 id="面试题5：替换空格"><a href="#面试题5：替换空格" class="headerlink" title="面试题5：替换空格"></a>面试题5：替换空格</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>非常简单，遍历字符串，当遇到空格时进行替换即可，值得注意的是java中String是不可变的，循环中不能使用String不断拼接而需要用StringBuilder代替。时间复杂度和空间复杂度均为$O(n)$。</p><p>但是这种解法并不是题目的本意，题目的本意是希望将字符串当做字符数组，然后实现原地更新，但是由于Java中String类型不可变导致该题目被简化。在这里为了不投机取巧，我们将输入改为可变的StringBuilder类型，然后在上面进行原地更新。</p><p>由于从前向后更新字符串时，我们会发现当 i 位置的元素被替代时，需要将 i 位置后面的所有元素向右移动 2 个位置来保证不会被覆盖。也就是说<strong>当从前向后更新元素时，前面的元素的更新会影响到所有后面的元素</strong>，所以我们可以换种思路：<strong>从后向前更新，因为后面元素的更新并不会影响到前面的元素</strong>。</p><p>再结合双指针的技巧，我们有如下思路：</p><ol><li>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。</li><li><strong>令 p1 指向字符串原来的末尾位置，p2 指向字符串现在的末尾位置</strong>。p1 和 p2 从后向前遍历，当 p1 遍历到一个空格时，就需要令 p2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 p1 指向字符的值。<strong>从后向前遍是为了在改变 p2 所指向的内容时，不会影响到 p1 遍历原来字符串的内容。</strong></li><li>当 p2 遇到 p1 时（p1 &gt;= p2），或者遍历结束（p1 &lt; 0），退出。</li></ol><p>具体的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuilder str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= p1; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>) str.append(<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p2 = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> &amp;&amp; p1 &lt; p2) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(p1);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">                str.setCharAt(p2--, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(p2--, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(p2--, <span class="string">'%'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                str.setCharAt(p2--, c);</span><br><span class="line">            &#125;</span><br><span class="line">            p1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的题目还有很多，比如：有两个排序数组A1和A2，A1的末尾有足够多的空余空间容纳A2，请将A2的所有数字合并到A1中并且所有的数字是排序的。最好的选择也是从后向前更新，使得移动的次数是最少的。</p><p><strong>这类题目共同的特点是从前向后进行移动、更新时，前面元素的移动迫使后面的元素也要随之移动，从而重复移动了很多次。这个时候我们就可以考虑从后向前进行更新，这样就能减少移动次数，从而提升效率。</strong></p><h2 id="面试题6：从尾到头打印链表"><a href="#面试题6：从尾到头打印链表" class="headerlink" title="面试题6：从尾到头打印链表"></a>面试题6：从尾到头打印链表</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值。</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>链表只能顺序访问，但是却需要后面的先打印， 所以主要有两种常见方法：</p><ol><li>先进后出（FIFO）的需要，因此可以使用<strong>栈</strong></li><li>从后向前打印，可以使用<strong>递归</strong>，先走至链表末端，回溯时依次将节点值加入列表</li></ol><p>这两种方法的时间复杂度均为$O(n)$，空间复杂度均为$O(n)$。</p><h2 id="面试题7：重建二叉树"><a href="#面试题7：重建二叉树" class="headerlink" title="面试题7：重建二叉树"></a>面试题7：重建二叉树</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line"></span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p><strong>经验总结：二叉树的问题一般都是分治思想，递归去做。因为二叉树本身就是递归定义的。</strong></p><p>首先需要明白前序遍历、中序遍历、后序遍历的意义：</p><ul><li>前序遍历：父节点 -&gt; 左子节点 -&gt; 右子节点</li><li>中序遍历：左子节点 -&gt; 父节点 -&gt; 右子节点</li><li>后序遍历：左子节点 -&gt; 右子节点 -&gt; 父节点</li></ul><blockquote><p>注： 需要掌握这三种遍历的递归以及迭代的实现！LeetCode有相应原题。</p></blockquote><p>我们可以发现<strong>前序遍历的第一个结点一定是根节点，在中序遍历中，根结点把中序遍历序列分成了两个部分，左边部分构成了二叉树的根结点的左子树，右边部分构成了二叉树的根结点的右子树</strong>。我们可以找到根节点在中序遍历中的位置，然后可以进一步得出左子树和右子数的大小，从而可以在前序遍历序列中找到根节点的左子节点和右子节点，最后递归的进行便能够构建二叉树。</p><div align=center><img src="http://image.yingzq.com/img/20200219194729.png" width="600" alt="重建二叉树示意图" /><p>重建二叉树示意图</p></div><p>具体的代码如下，很容易看懂：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, inorder, <span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt;= preorder.length || inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        <span class="comment">// index代表目前的根节点在中序遍历中的位置</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">for</span> (index = inStart; index &lt;= inEnd; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[index] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归的构建子树</span></span><br><span class="line">        root.left = helper(preorder, inorder, preStart + <span class="number">1</span>, inStart, index - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(preorder, inorder, preStart + index - inStart + <span class="number">1</span>, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，根据中序遍历和后序遍历也使用类似的方法构建出二叉树，因为<strong>后序遍历的最后一个节点一定是根节点</strong>，然后不断的根据中序遍历找到根节点的左子节点、右子节点即可。</p><h2 id="面试题8：二叉树的下一个节点"><a href="#面试题8：二叉树的下一个节点" class="headerlink" title="面试题8：二叉树的下一个节点"></a>面试题8：二叉树的下一个节点</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>主要考察中序遍历的知识，中序遍历求当前节点的下一个节点有以下几种情况：</p><ol><li>当前节点为空，则直接返回空。</li><li>当前节点存在右子树，则下一个节点为右子树最左子节点。</li><li>若该节点不存在右子树，这时又分为两种情况：<ul><li>该节点为父节点的左子节点，则下一个节点为其父节点；</li><li>该节点为父节点的右子节点，则沿着父节点向上遍历，直到找到<strong>一个节点的父节点的左子节点为该节点</strong>，此时该节点的父节点便是下一个节点。</li></ul></li></ol><p>相应代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;  // 指向父节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (pNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pNode.next.left == pNode) <span class="keyword">return</span> pNode.next;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题9：用两个栈实现队列"><a href="#面试题9：用两个栈实现队列" class="headerlink" title="面试题9：用两个栈实现队列"></a>面试题9：用两个栈实现队列</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>队列是先进先出，栈是先进后出，所以利用两个栈，先将数据压入stack1，再将stack1的数据压入stack2，此时stack2中的数据进行弹出时便相当于队列。</p><p>由于过程中 appendTail 和 deleteHead 是交叉进行的，我们可以做如下约定：</p><ul><li>进行 appendTail 时，直接向stack1中压入数据即可。</li><li>进行 deleteHead 时，如果stack2不为空，直接输出stack2弹出的结果；否则将stack1中所有数据弹出并压入stack2中，然后再输出stack2中弹出的结果。</li></ul><p>此时利用均摊的思想，appendTail 和 deleteHead 函数的时间复杂度为$O(1)$。</p><p>与之相关的问题还有<code>用两个队列实现一个栈</code>，假如有两个队列q1和q2，当模拟栈压入数据时，只需要向q1中压入数据，当模拟栈弹出数据时，由于队列只能弹出队首的数据，所以有如下思路：假设n是目前q1中的数据总数，对于前n-1个数据，将q1中的数据依次弹出并同时插入到q2中，q1中的最后一个数据则是我们需要的结果，弹出并返回即可。这样实现的系统插入数据的时间复杂度为$O(1)$，弹出数据则为$O(n)$。</p><blockquote><p>注：其实仅用一个队列便可以实现栈，只需要将队列q1前n-1个弹出的元素重新插回到q1中即可，根本不需要用到q2。</p></blockquote><h2 id="面试题10-1：斐波那契数列"><a href="#面试题10-1：斐波那契数列" class="headerlink" title="面试题10-1：斐波那契数列"></a>面试题10-1：斐波那契数列</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><ol><li>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</li><li>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</li></ol><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>很多C语言教科书在讲述递归函数时，都会用斐波拉契数列作为例子，其实那种递归的写法效率是非常非常低的，时间复杂度是指数级的，千万不要用！</p><p>使用递归方法之所以低效是因为有着大量的重复计算，例如计算F(10)和F(9)向下递归时都会计算F(8)的值。因此我们可以将中间状态保存起来，减少计算量，自底向上的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">long</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> sec = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> nval = first + sec;</span><br><span class="line">            first = sec;</span><br><span class="line">            sec = nval % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) sec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的时间复杂度为$O(n)$，其实还有复杂度更低的基于数学的方法，将斐波拉契数列推导成为一个较为生僻的公式，一般不常用，在这里就略过了。</p><h2 id="面试题10-2：青蛙跳台阶问题"><a href="#面试题10-2：青蛙跳台阶问题" class="headerlink" title="面试题10-2：青蛙跳台阶问题"></a>面试题10-2：青蛙跳台阶问题</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>设跳上n级台阶有 <code>f(n)</code> 种跳法，在所有跳法中，青蛙的最后一步只有两种情况：<strong>跳上 1 级或 2 级台阶</strong>：</p><ol><li>当为 1 级台阶： 剩 n-1 个台阶，此情况共有 <code>f(n-1)</code> 种跳法；</li><li>当为 2 级台阶： 剩 n-2 个台阶，此情况共有 <code>f(n-2)</code> 种跳法。</li></ol><p>可以得出<code>f(n) = f(n-1) + f(n-2)</code>，因此本题可转化为求斐波那契数列第 n 项的值。</p><h2 id="面试题11：旋转数组的最小数字"><a href="#面试题11：旋转数组的最小数字" class="headerlink" title="面试题11：旋转数组的最小数字"></a>面试题11：旋转数组的最小数字</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p>最简单的一个解法是遍历数组，时间复杂度$O(n)$。但是没有用到“旋转数组”的性质，很明显，对于在经过旋转的递增数组的查找，是需要用二分查找来实现$O(\log n)$时间复杂度算法。</p><p>对于经过旋转的有序数组，当数组内没有相等元素时，一共有如下3种情景：</p><div align=center><img src="http://image.yingzq.com/img/20200219235223.png" width="600" alt="旋转的有序数组" /><p>旋转的有序数组</p></div><p>可以看出<code>nums[lo], nums[mid], nums[hi]</code>的相对大小决定了最小值所在的区间，这里我们只使用<code>nums[mid], nums[hi]</code>进行分析：</p><ul><li>当<code>nums[mid] &gt; nums[hi]</code>时，说明是情景二，此时最小值在右半区，因此<code>lo = mid + 1</code>即可。</li><li>当<code>nums[mid] &lt; nums[hi]</code>时，说明是情景一或情景三，此时两种情景的最小值均在左半区，但是有可能就是<code>nums[mid]</code>，因此<code>hi = mid</code>即可。</li><li>当<code>lo == hi</code>时，循环停止，<code>nums[lo]</code>即为最小值。</li></ul><p>但是这一题是可能会有重复元素的，当出现<code>nums[mid] == nums[hi]</code>时最小元素在哪个半区呢？其实是都有可能的，是无法确定的，例如 对于 [2,1,2,2,2] 最小值在左半区，对于 [2,2,2,1,2] 则是在右半区。在这里我们直接舍弃<code>nums[hi]</code>，也就是将<code>hi--</code>即可，这是因为此时循环未停止，说明<code>mid &lt; hi</code>，但是此时<code>nums[mid] == nums[hi]</code>，所以<code>lo~hi-1</code>之间的最小值是一定和<code>lo~hi</code>之间的最小值相等的，因此直接舍弃最后一个元素是不影响结果的。</p><p>最终代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[hi]) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[hi]) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题12：矩阵中的路径"><a href="#面试题12：矩阵中的路径" class="headerlink" title="面试题12：矩阵中的路径"></a>面试题12：矩阵中的路径</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>很明显直接使用回溯法（或者说DFS）即可，直接上代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exist(board, word, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> idx, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == m || y == n || word.charAt(idx) != board[x][y]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[x][y] ^= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist(board, word, idx + <span class="number">1</span>, x + dir[<span class="number">0</span>], y + dir[<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] ^= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面有几个点可以学习：</p><ul><li>首先是边界条件、结束条件的判断放到了最前面，使得代码非常清晰。</li><li>其次，对于该问题的回溯法来说，需要一个与<code>board</code>相同大小的<code>visited</code>数组来记录某个位置是否已经访问，但是这样便需要额外的开辟$O(n^2)$的空间，这里一个更巧妙的办法是修改原数组的值，这里使用了<code>board[x][y] ^= 256</code>修改原数组，然后在方法调用结束时再次异或将数组还原，其实这里不一定要使用异或，只需要将该位置的字符先变成一个有区分度的字符，最后再修改回来即可。</li><li>最后，使用<code>dirs</code>的方向数组可以任意控制方向，而且使得代码清晰而简洁。</li></ul><h2 id="面试题13：机器人的运动范围"><a href="#面试题13：机器人的运动范围" class="headerlink" title="面试题13：机器人的运动范围"></a>面试题13：机器人的运动范围</h2><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><p>同样使用回溯法（或者说DFS），只需要写一个判断当前方格是否有效的方法即可；另外可以使用成员变量<code>count</code>来进行记录，每次调用方法前记得进行初始化。</p><p>由于并不需要返回运行的完整路径，所以这一题使用BFS也是很好的选择。</p><h2 id="面试题14：剪绳子"><a href="#面试题14：剪绳子" class="headerlink" title="面试题14：剪绳子"></a>面试题14：剪绳子</h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 <code>k[0]*k[1]*...*k[m]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><p>首先可以使用自底向上的<strong>动态规划</strong>。设f(n)为长度为n的绳子可以得到的最大乘积，我们可以将f(n)的问题分解成求更小规模f(n-k)的问题，可以得出递推公式为<code>f(n) = max{f(1)*f(n-1), f(2)*f(n-2), ... , f(n-1)*f(1)}</code>，但是这个公式中还存在一些问题，例如求长度为3的绳子时可以分为长度为1、2的两段绳子，这时是可以不需要将长度为2的绳子再次进行裁剪的，因此当绳子长为2时函数返回1，但是当绳子长度大于2时需要<code>f(2) = 2</code>。可以证明，当<code>n &lt; 4</code>时<code>n &gt; i*(n - i)</code>，即此时绳子不裁剪时反而有最大值，所以这部分值做特殊处理即可。算法有双重循环，时间复杂度为$O(n^2)$，空间复杂度为$O(n)$，具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123; <span class="comment">// 另一半情况是对称的，因此搜索一半即可</span></span><br><span class="line">                max = Math.max(max, dp[j] * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解法利用到了一点数学知识：<strong>n个数和一定的情况下，数字越均匀，积越大。</strong> 但是并不知道具体需要分成多少段（即题目中的m不确定），因此m需要遍历2~n，在每一次循环中，尽可能的均分绳子得到局部最大值，最后得到全局最大值。</p><p>最后一种解法可以说是找规律，也可以说是贪婪算法：<strong>当 n &gt; 4 时尽可能的分解出更多的3，当 n = 4 时分解出两个2</strong>。简单证明下：当n &lt; 4时直接返回特定结果，当n = 4时最大值为2*2=4，当n &gt; 4时<code>任何整数都可以使用3和2来合成</code>，且有<code>2*(n-2) &gt; n, 3*(n-3) &gt; n</code>，也就是当绳子剩下的长度大于4时，应该将它剪成长度为3或者长度为2的绳子，另外当n &gt; 4时<code>2*(n-2) &lt;= 3*(n-3)</code>，因此应该尽可能剪出更多的长度为3的绳子段，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;  <span class="comment">// 全部分解为3</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, n / <span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) &#123;  <span class="comment">// 分解到最后剩一个4</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, n / <span class="number">3</span> - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 分解到最后剩一个2</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, n / <span class="number">3</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以不借助<code>Math.pow()</code>，使用迭代的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题15：二进制中1的个数"><a href="#面试题15：二进制中1的个数" class="headerlink" title="面试题15：二进制中1的个数"></a>面试题15：二进制中1的个数</h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><p>很显然直接使用位运算即可。值得注意的是，在java中<code>&gt;&gt;</code>是带符号右移，正数右移高位补0，负数右移高位补1；<code>&gt;&gt;&gt;</code>是无符号右移，无论是正数还是负数，高位通通补0。另外java中有<code>Integer.bitCount()</code>方法，可以直接统计输入整数对应二进制中1的个数。</p><p>还有一种令人眼前一亮的方案：<strong><code>n &amp; (n - 1)</code>会把<code>n</code>最右边的 1 变成 0</strong>。那么一个整数的二进制表示中有多少个 1，就可以进行多少次这样的操作，该方法对于的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实<code>n &amp; (n - 1)</code>还是有很多妙用的，例如可以直接判断出一个整数是不是2的整数次方。</p></blockquote><h2 id="面试题16：数值的整数次方"><a href="#面试题16：数值的整数次方" class="headerlink" title="面试题16：数值的整数次方"></a>面试题16：数值的整数次方</h2><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数。</p><h3 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h3><p>最开始想到的就是循环<code>exponent</code>次，但是其实不用，比如我们求某个数的32次方，我们只需要知道这个数的16次方，然后两个16次方进行相乘即可，求16次方又只需要知道8次方的值，以此类推，时间复杂度为$O(\log n)$。</p><p>这样这一题基本解决了，但是需要注意细节！如果<code>exponent</code>是负数怎么办？<code>exponent</code>奇数偶数情况是否一样？除以2的操作可以使用位运算代替？代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">            x = x * x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span> ? myPow(x * x, n &gt;&gt;&gt; <span class="number">1</span>) : x * myPow(x * x, n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有个边界问题需要处理：当一个负数 <code>n</code> 加上负号变为正数时，如果 <code>n</code> 有可能等于 <code>Integer.MIN_VALUE</code>，可能会发生错误。</p><p>最后再提一点位运算：</p><ol><li><code>n / 2</code>的操作可以替换为<code>n &gt;&gt; 1</code>，注意这里是 <code>1</code>，只需要移动 1 位即可，不要弄错了。另外要注意<code>&gt;&gt;</code>和<code>&gt;&gt;&gt;</code>的区别。</li><li>判断奇偶性的<code>n % 2</code>其实也可以用位运算<code>n &amp; 1</code>代替：当<code>(n &amp; 1) == 0</code>时为偶数，当<code>(n &amp; 1) == 1</code>时为奇数。</li></ol><h2 id="面试题17：打印从1到最大的n位数"><a href="#面试题17：打印从1到最大的n位数" class="headerlink" title="面试题17：打印从1到最大的n位数"></a>面试题17：打印从1到最大的n位数</h2><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><h3 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h3><p>不考虑大数问题此题非常简单，先求出最大的n位十进制数，然后循环打印即可。此题没有规定n的大小，所以n有可能非常大，所代表的十进制数可能超出int，甚至是long的上界，此时应该如何处理呢？数组是可以很长的，因此我们可以利用长度为n的数组来代表长度为n的十进制数，然后在数组上模拟整数加法即可。</p><h2 id="面试题18：删除链表的节点"><a href="#面试题18：删除链表的节点" class="headerlink" title="面试题18：删除链表的节点"></a>面试题18：删除链表的节点</h2><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><h3 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h3><p>非常简单，有一个要点是使用一个<strong>虚拟节点</strong>，这样当要删除的节点刚好是头结点时也不需要额外处理。</p><h2 id="面试题19：正则表达式匹配"><a href="#面试题19：正则表达式匹配" class="headerlink" title="面试题19：正则表达式匹配"></a>面试题19：正则表达式匹配</h2><h3 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数用来匹配包含<code>&#39;.&#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li></ul><h3 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h3><p>如果没有<code>*</code>，问题会很简单：我们只需要从左到右检查匹配串<code>s</code>是否能匹配模式串<code>p</code>的每一个字符，遇到<code>.</code>也只需要简单处理下就可以了。</p><p>当模式中有<code>*</code>时，情况就比较麻烦了，在这里使用动态规划来做。</p><p><strong>状态</strong><br>定义二维数组<code>dp</code>，<code>dp[i][j]</code>表示<code>s</code>的前<code>i</code>个是否能被<code>p</code>的前<code>j</code>个匹配。</p><p><strong>转移方程</strong><br>怎么想转移方程？首先想的时候从已经求出了<code>dp[i-1][j-1]</code>入手，再加上已知<code>s[i]</code>、<code>p[j]</code>，要想的问题就是怎么去求<code>dp[i][j]</code>。</p><ol><li>先考虑最简单的，如果<code>s[i] == p[j]</code>，那么有<code>dp[i][j] = dp[i-1][j-1]</code>。</li><li>如果<code>p[j] == &#39;.&#39;</code>，那么有<code>dp[i][j] = dp[i-1][j-1]</code>。</li><li>如果<code>p[j] == &#39;*&#39;</code>，情况比较复杂，下文主要探讨这种情况。</li></ol><p><code>*</code>的含义是<strong>匹配零个或多个前面的那一个元素</strong>，所以要考虑它前面的元素<code>p[j-1]</code>。<code>*</code>跟着它前一个字符走，前一个能匹配上<code>s[i]</code>，<code>*</code>才能有用，前一个都不能匹配上<code>s[i]</code>，<code>*</code>也无能为力，只能让前一个字符消失，也就是匹配0次前一个字符。</p><p>所以按照<code>p[j-1]</code>和<code>s[i]</code>是否相等，我们分为两种情况：</p><ul><li>如果<code>p[j-1] != s[i]</code>，这就是刚才说的那种前一个字符匹配不上的情况，那么就将<code>*</code>和它前面的字符全部舍弃，因此有<code>dp[i][j] = dp[i][j-2]</code>。</li><li>如果<code>p[j-1] == s[i] || p[j-1] == &#39;.&#39;</code>，这说明最后一个字符是可以匹配的，现在关键是要看前面的部分是否匹配，这里可以有3种情况，只需要满足其一即可：<ol><li><code>dp[i][j] = dp[i-1][j]</code>，多个字符匹配的情况，例如<code>a* -&gt; aa</code></li><li><code>dp[i][j] = dp[i][j-1]</code>，单个字符匹配的情况，例如<code>a* -&gt; a</code></li><li><code>dp[i][j] = dp[i][j-2]</code>，不进行匹配的情况，即舍弃<code>a*</code></li></ol></li></ul><p>最终代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i+<span class="number">1</span>] = dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j) == s.charAt(i) || p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j-<span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = (dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用动态规划解决问题的时候，除了找出状态转移方程，还有一些细节也是需要处理的：</p><ul><li>初始长度的问题，dp数组的长度初始化为 n 还是 n+1。<strong>如果你需要用到 <code>dp[i-1]</code> 但是 i 又有可能为 0，那可能初始化为 n+1 长度更方便。</strong></li><li>初始值的问题，对于一维数组 <code>dp[n+1]</code>，需要注意 <code>dp[0]</code> 的初始取值；对于二维数组 <code>dp[m+1][n+1]</code>，不仅要注意 <code>dp[0][0]</code> 的取值，还要注意第 0 行以及第 0 列，即<code>dp[0][j]</code>以及<code>dp[i][0]</code>的初始取值。</li></ul><h2 id="面试题20：表示数值的字符串"><a href="#面试题20：表示数值的字符串" class="headerlink" title="面试题20：表示数值的字符串"></a>面试题20：表示数值的字符串</h2><h3 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”及”-1E-16”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p><h3 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h3><p>表示数值的字符串遵循模式<code>A[.[B]][e|EC]</code>或者<code>.B[e|EC]</code>，其中<code>A</code>为数值的整数部分，<code>B</code>紧跟着小数点为数值的小数部分，<code>C</code>紧跟着<code>e</code>或<code>E</code>为数值的指数部分。上述<code>A</code>和<code>C</code>都是整数（可以有正负号，也可以没有），而<code>B</code>是一个无符号整数。</p><p>这题可以按部就班的用<code>if-else</code>慢慢调试、优化，直到 <code>bug free</code>，这里就不贴相应的代码了。</p><p>换种思路，我们的目的是要匹配一些特定模式，这正是<code>正则表达式</code>的用武之地，所以这里投机取巧的用正则表达式完成此题。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]  ： 字符集合</span><br><span class="line">()  ： 分组</span><br><span class="line">?   ： 重复 0 ~ 1 次</span><br><span class="line">+   ： 重复 1 ~ n 次</span><br><span class="line">*   ： 重复 0 ~ n 次</span><br><span class="line">.   ： 任意字符</span><br><span class="line">\\. ： 转义后的 .</span><br><span class="line">\\d ： 数字</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> s.trim().matches(<span class="string">"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题21：调整数组顺序使奇数位于偶数前面"><a href="#面试题21：调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题21：调整数组顺序使奇数位于偶数前面"></a>面试题21：调整数组顺序使奇数位于偶数前面</h2><h3 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p><em>**示例</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4]</span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure><p>提示：</p><ol><li>1 &lt;= nums.length &lt;= 50000</li><li>1 &lt;= nums[i] &lt;= 10000</li></ol><h3 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h3><p>可以使用双指针法，具体有两种：</p><ol><li>首尾双指针法：<ul><li>定义双指针<code>lo = 0, hi = nums.length-1</code>，一个在首部，一个在尾部</li><li><code>lo</code>一直往右移，直到<code>nums[lo]</code>为偶数；<code>hi</code>一直往左移，直到<code>nums[hi]</code>为奇数</li><li>交换<code>nums[lo]</code>和<code>nums[hi]</code>，然后需要<code>lo++, hi--</code></li><li>重复上述操作，直到<code>lo == hi</code></li></ul></li><li>快慢双指针法：<ul><li>定义双指针<code>slow = 0, fast = 0</code>，一个会运动的快，一个会运动的慢</li><li><code>fast</code>的作用是向前搜索奇数位置，<code>slow</code>的作用是指向下一个奇数应当存放的位置</li><li><code>fast</code>向前移动，当它搜索到奇数时，将<code>nums[fast]</code>和<code>nums[low]</code>交换，然后将<code>low</code>向前移动一个位置</li><li>重复上述操作，直到<code>fast</code>指向数组末尾</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 首尾双指针法</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] % <span class="number">2</span> == <span class="number">1</span>) lo++;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] % <span class="number">2</span> == <span class="number">0</span>) hi--;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[lo];</span><br><span class="line">            nums[lo] = nums[hi];</span><br><span class="line">            nums[hi] = tmp;</span><br><span class="line">            lo++;hi--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 快慢双指针法</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[fast] &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;  <span class="comment">// 这种判断奇偶数的方法也可以学习</span></span><br><span class="line">                <span class="keyword">int</span> temp = nums[fast];</span><br><span class="line">                nums[fast] = nums[slow];</span><br><span class="line">                nums[slow] = temp;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题22：链表中倒数第k个节点"><a href="#面试题22：链表中倒数第k个节点" class="headerlink" title="面试题22：链表中倒数第k个节点"></a>面试题22：链表中倒数第k个节点</h2><h3 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><h3 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h3><p>经典题目，直接快慢双指针法即可，需要注意的是一些小问题：输入的链表为空、输入的k值不合理等情况，总体来说在可能出现空指针的地方需要仔细思考。</p><h2 id="面试题23：链表中环的入口节点"><a href="#面试题23：链表中环的入口节点" class="headerlink" title="面试题23：链表中环的入口节点"></a>面试题23：链表中环的入口节点</h2><h3 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>说明：不允许修改给定的链表。</p><h3 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h3><p>最简单的方法是使用<code>HashSet</code>，用一个集合保存已经访问过的节点，我们可以遍历整个链表并返回第一个出现重复的节点。算法的时间复杂度、空间复杂度均为$O(n)$。</p><p>第二种方法是<code>Floyd 算法</code>，它的出发点是<strong>一个跑得快的人和一个跑得慢的人在一个圆形的赛道上赛跑，会发生什么？在某一个时刻，跑得快的人一定会从后面赶上跑得慢的人</strong>。<code>Floyd算法</code>被划分成两个不同的阶段 。在第一阶段，找出列表中是否有环，如果没有环，可以直接返回null并退出。否则，用<strong>相遇节点</strong>来找到环的入口。</p><p><strong>阶段一</strong><br>初始化两个指针：快指针和慢指针。快指针每次移动两步，慢指针每次移动一步，如果能够相遇，证明链表存在环，进入阶段二；否则fast指针会迭代到null，证明不存在环，直接返回null即可。</p><p><strong>阶段二</strong><br>给定阶段一找到的<strong>相遇点</strong>，阶段二将找到环的入口。首先我们初始化两个指针： ptr1 ，指向链表的头， ptr2 指向相遇点。然后，我们每次将它们往前移动一步，直到它们相遇，它们相遇的点就是环的入口，返回这个节点。</p><p>这里简单的说明下原因：假设环的周长为<code>R</code>，阶段一在慢指针迭代了<code>k</code>步之后相遇，则有<code>2k-k=nR -&gt; k=nR</code>，其中n为某个正整数。假设链表的头结点与环入口的距离为<code>s</code>，环入口与阶段一的相遇点的距离为<code>m</code>，可以得到<code>k=s+m+lR -&gt; s=k-m-lR=(n-l)R-m</code>，其中l为某个小于n的正整数，而相遇点到环入口的距离刚好是<code>R-m</code>，因此ptr1和ptr2下一次相遇的地方刚好是环的入口。</p><p><code>Floyd算法</code>相应代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还有一个不错的方法，分为3个步骤：</p><ol><li>利用快慢指针法找到相遇点</li><li>根据相遇点再次遍历节点得到环的大小C</li><li>重新初始化两个快慢指针指向链表的头，其中快指针先移动C步，然后快慢指针每次同时向前移动一步，直到相遇，相遇点即为环的入口</li></ol><h2 id="面试题24：反转链表"><a href="#面试题24：反转链表" class="headerlink" title="面试题24：反转链表"></a>面试题24：反转链表</h2><h3 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><h3 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h3><p>使用3个变量<code>prev, cur, next</code>，然后迭代一轮便可以完成，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种解法是使用头插法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = dummy.next;</span><br><span class="line">            dummy.next = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题25：合并两个排序的链表"><a href="#面试题25：合并两个排序的链表" class="headerlink" title="面试题25：合并两个排序的链表"></a>面试题25：合并两个排序的链表</h2><h3 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><h3 id="分析-24"><a href="#分析-24" class="headerlink" title="分析"></a>分析</h3><p>迭代和递归都可以完成，很经典的一道题，为了加深印象分别都写一下，细节可以看代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) prev.next = l1;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) prev.next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试季来临，于是最近两天阅读了《剑指offer第二版》这本程序员面试必备书籍，全书题目不多，但是涵盖了许多重要的知识点，通过自己的阅读也收获良多，所以写下这个阅读笔记。该笔记对书中的面试题进行了自己的分析，相比于原书有的放矢，因此精简了很多，这样做一是加深自己对每个题的印象，二是可以方便今后复习时无需再次看原书，简单的过一下笔记就好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://www.yingzq.com/tags/Java/"/>
    
      <category term="阅读笔记" scheme="http://www.yingzq.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法（归纳分析及java实现）</title>
    <link href="http://www.yingzq.com/2019/12/25/common-sorting-algorithms/"/>
    <id>http://www.yingzq.com/2019/12/25/common-sorting-algorithms/</id>
    <published>2019-12-25T11:55:56.000Z</published>
    <updated>2020-02-19T17:41:15.969Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法是算法的入门知识，其经典思想可以用于很多算法当中。本文将介绍常见排序算法的原理、对它们的分析以及对应的Java代码实现。</p><a id="more"></a><blockquote><p>注：排序就是将一组对象按照某种逻辑顺序重新排列的过程，在商业数据处理和现代科学计算中有着重要的地位。</p></blockquote><h2 id="排序算法概述"><a href="#排序算法概述" class="headerlink" title="排序算法概述"></a>排序算法概述</h2><h3 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h3><p>常见的排序算法可以分成两大类：</p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破$O(n\log n)$，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li></ul><div align=center><img src="http://image.yingzq.com/img/20191229143752.png" width="600" alt="排序算法分类" /><p>图：排序算法分类</p></div><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><table><thead><tr><th align="center">排序方法</th><th align="center">时间复杂度（平均）</th><th align="center">时间复杂度（最好）</th><th align="center">时间复杂度（最坏）</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">选择排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">插入排序</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">$O(n^{1.3})$</td><td align="center">$O(n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">$O(n\log n)$</td><td align="center">$O(n\log n)$</td><td align="center">$O(n\log n)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td align="center">快速排序</td><td align="center">$O(n\log n)$</td><td align="center">$O(n\log n)$</td><td align="center">$O(n^2)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">$O(n\log n)$</td><td align="center">$O(n\log n)$</td><td align="center">$O(n\log n)$</td><td align="center">$O(1)$</td><td align="center">不稳定</td></tr><tr><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">计数排序</td><td align="center">$O(n+k)$</td><td align="center">$O(n+k)$</td><td align="center">$O(n+k)$</td><td align="center">$O(n+k)$</td><td align="center">稳定</td></tr><tr><td align="center">桶排序</td><td align="center">$O(n+n(\log n - \log m))$</td><td align="center">$O(n)$</td><td align="center">$O(n\log n)$</td><td align="center">$O(n+m)$</td><td align="center">稳定</td></tr><tr><td align="center">基数排序</td><td align="center">$O(k*n)$</td><td align="center">$O(k*n)$</td><td align="center">$O(k*n)$</td><td align="center">$O(k+n)$</td><td align="center">稳定</td></tr></tbody></table><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>具体流程如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样一趟比较交换下来排在最右的元素就会是最大的数；</li><li>除去最右的元素，我们对剩余的元素做同样的工作，如此重复下去，直到排序完成。</li></ol><h3 id="动态演示"><a href="#动态演示" class="headerlink" title="动态演示"></a>动态演示</h3><div align=center><img src="http://image.yingzq.com/img/bubble-sort.gif" width="700" alt="冒泡排序演示" /><p>冒泡排序演示</p></div><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><strong>时间复杂度</strong>：平均、最好、最坏的时间复杂度均为$O(n^2)$，也就是运行时间和输入无关。因为总要进行n次遍历，每次遍历进行数据比较、交换的时间为$O(n)$；但是也可以通过添加一个标志位将最好的时间复杂度提升为$O(n)$。</li><li><strong>空间复杂度</strong>：$O(1)$</li><li><strong>是否稳定</strong>：稳定；因为当相邻元素相等的时候算法并不会交换这两元素的位置，因此冒泡排序是稳定的。</li></ul><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>选择排序是一种简单直观的排序算法。</p><p>具体流程如下：</p><ol><li>找到数组中最小的那个元素；</li><li>将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）；</li><li>在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置；</li><li>如此往复，直到将整个数组排序。</li></ol><p>因为这种算法会不断的选择剩余元素之中的最小值，所以叫做选择排序。</p><h3 id="动态展示"><a href="#动态展示" class="headerlink" title="动态展示"></a>动态展示</h3><div align=center><img src="http://image.yingzq.com/img/selection-sort.gif" width="700" alt="选择排序展示" /><p>选择排序展示</p></div><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;  <span class="comment">// 最小元素的引索</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[min]) min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><strong>时间复杂度</strong>：平均、最好、最坏的时间复杂度均为$O(n^2)$，也就是运行时间和输入无关。因为总要进行n次遍历，每次遍历需要花费$O(n)$的时间来找到最小元素的引索。</li><li><strong>空间复杂度</strong>：$O(1)$</li><li><strong>是否稳定</strong>：不稳定；由于选择元素之后会发生交换操作，所以有可能把前面的元素交换到后面，例如数组 [3, 3, 2] ，第一次交换时改变了两个3的位置顺序，所以不是稳定的排序。</li></ul><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位，这种算法叫做插入排序。</p><p>具体流程如下：</p><ol><li>从数组第2个元素开始抽取元素；</li><li>把它与左边第一个元素比较，如果左边第一个元素比它大，则继续与左边第二个元素比较下去，直到遇到不比它大的元素，然后插到这个元素的右边；</li><li>继续选取第3，4，…n个元素,重复步骤 2 ，选择适当的位置插入。</li></ol><h3 id="动态演示-1"><a href="#动态演示-1" class="headerlink" title="动态演示"></a>动态演示</h3><div align=center><img src="http://image.yingzq.com/img/insertion-sort.gif" width="700" alt="插入排序展示" /><p>插入排序展示</p></div><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 将arr[i]插入到arr[i-1]、arr[i-2]、arr[i-3]...之中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">                swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><strong>时间复杂度</strong>：平均时间复杂度和最坏时间复杂度均为$O(n^2)$，但是最好时间复杂度为$O(n)$，也就是插入排序算法所需的时间取决于输入中元素的初始顺序。当排序一个随机顺序或者逆序的数组时，需要插入n-1次，每次插入平均的比较、交换次数为$O(n)$，所以平均和最坏的时间复杂度为$O(n^2)$；当排序一个已经排好序的数组时，每次插入仅需要$O(1)$次比较，因此最好时间复杂度为$O(n)$；对于接近有序的数组插入排序算法也是极快的。</li><li><strong>空间复杂度</strong>：$O(1)$</li><li><strong>是否稳定</strong>：稳定；因为在比较元素大小的时候，如果两个元素相等则不会进行交换。</li></ul><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><p>希尔排序是插入排序的一种更高效的改进版本，也叫缩小增量排序。相较于插入排序一点一点的移动元素，希尔排序实现了快速移动一大步。</p><p>具体流程如下：</p><ol><li>先设定一个合适的h，例如数组总长度的1/3；</li><li>利用插入排序，使得数组中任意间隔为h的元素都是有序的，这样的数组也被称为h有序数组；</li><li>按一定的规律减小h的值，重复第2步，直到h=1。</li></ol><h3 id="算法图示"><a href="#算法图示" class="headerlink" title="算法图示"></a>算法图示</h3><div align=center><img src="http://image.yingzq.com/img/20191226212553.png" width="700" alt="希尔排序图示" /><p>图：希尔排序图示</p></div><blockquote><p>注：较为复杂的算法动态图反而不好看清，所以使用图示来展示。</p></blockquote><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; len / <span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;  <span class="comment">// 1, 4, 13, 40, 121, 364, ...</span></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 将数组变为h有序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 将arr[i]插入到arr[i-h], arr[i-2*h], arr[i-3*h]... 之中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) &#123;</span><br><span class="line">                    swap(arr, j, j - h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：递增序列的选择也是一大难题，代码使用的是$h_{t+1} = 3 * h_t + 1$</p></blockquote><h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><strong>时间复杂度</strong>：希尔排序的时间复杂度无法准确量化，平均复杂度介于$O(n\log n)$和$O(n^2)$之间，并且和递增序列的选择也有着很大关系；有人用大量实验说明对于一个已知的非常好的递增序列，平均时间复杂度大约为$O(n^{1.3})$。</li><li><strong>空间复杂度</strong>：$O(1)$</li><li><strong>是否稳定</strong>：不稳定；虽然插入排序是稳定的，但是希尔排序在插入的时候是跳跃性插入的，有可能破坏稳定性。</li></ul><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><p>什么是归并呢？归并操作即将两个有序的数组归并成一个更大的有序数组。</p><p>很快人们就基于归并操作发明了一种简单的递归排序算法：归并排序。要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。</p><blockquote><p>归并排序是一种分治的排序方法。</p></blockquote><h3 id="算法图示-1"><a href="#算法图示-1" class="headerlink" title="算法图示"></a>算法图示</h3><div align=center><img src="http://image.yingzq.com/img/20191226225842.png" width="600" alt="归并排序图示" /><p>图：归并排序图示</p></div><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p>归并排序有两种实现方式：</p><ol><li>自顶向下的递归实现</li><li>自底向上的迭代实现</li></ol><h4 id="自顶向下（Top-down）"><a href="#自顶向下（Top-down）" class="headerlink" title="自顶向下（Top-down）"></a>自顶向下（Top-down）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux;  <span class="comment">//归并所需的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数组arr[lo..hi]排序</span></span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(arr, lo, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, hi);</span><br><span class="line">        merge(arr, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将arr[lo..mid]和arr[mid+1..hi]归并</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将arr[lo..hi]复制到aux[lo..hi]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">            aux[k] = arr[k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) arr[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) arr[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (aux[j] &lt; aux[i]) arr[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> arr[k] = aux[i++];  <span class="comment">// 包含两元素相等的情况，取较前位置的元素来保证算法稳定性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自底向上（Bottom-up）"><a href="#自底向上（Bottom-up）" class="headerlink" title="自底向上（Bottom-up）"></a>自底向上（Bottom-up）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeBU</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux;  <span class="comment">//归并所需的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; len; sz *= <span class="number">2</span>)  <span class="comment">// sz:子数组大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; len - sz; lo += sz + sz)  <span class="comment">// lo:子数组引索</span></span><br><span class="line">                merge(arr, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, len - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将arr[lo..mid]和arr[mid+1..hi]归并</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将arr[lo..hi]复制到aux[lo..hi]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">            aux[k] = arr[k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) arr[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) arr[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (aux[j] &lt; aux[i]) arr[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> arr[k] = aux[i++];  <span class="comment">// 包含两元素相等的情况，取较前位置的元素来保证算法稳定性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><strong>时间复杂度</strong>：平均、最好、最坏的时间复杂度均为$O(n\log n)$；因为归并排序递归的深度为$\log n$，每一层进行比较并移动的次数均为$O(n)$。</li><li><strong>空间复杂度</strong>：$O(n)$；递归深度为$O(\log n)$，辅助数组的空间为$O(n)$，所以整体的空间复杂度为$O(n)$。</li><li><strong>是否稳定</strong>：稳定；因为在合并的时候，如果两个元素相等则选择前面的元素到辅助数组，所以相等元素的相对顺序未发生改变。</li></ul><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><p>快速排序可能是应用最广泛的排序算法了。</p><p>快速排序引人注目的特点包括它是原地排序（只需要一个很小的辅助栈），且将长度为n的数组排序所需的时间和$n\log n$成正比，前面讲到的排序算法均无法将这两个优点同时结合起来。另外，快速排序的内循环比大多数排序算法都要短小，这意味着它无论是在理论上还是实际中都要更快。</p><p>快速排序的基本思想：通过一趟排序将要排序的数据<strong>分割成独立的两部分</strong>，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<strong>递归进行</strong>，以此达到整个数据变成有序序列。</p><blockquote><p>和归并排序一样，快速排序也是一种分治的排序方法。</p></blockquote><h3 id="算法图示-2"><a href="#算法图示-2" class="headerlink" title="算法图示"></a>算法图示</h3><blockquote><p>注：快速排序的关键是递归进行切分（partition）操作，所以我们<strong>主要展示如何进行一次partition操作</strong>。</p></blockquote><div align=center><img src="http://image.yingzq.com/img/20200101133024.png" width="500" alt="快速排序partition示意图" /><p>图：快速排序partition示意图</p></div><div align=center><img src="http://image.yingzq.com/img/20191227224720.png" width="700" alt="快速排序partition详细轨迹" /><p>图：快速排序partition详细轨迹</p></div><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        shuffle(arr);  <span class="comment">// 打乱数组，保证快排算法性能</span></span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(arr, lo, hi);</span><br><span class="line">        sort(arr, lo, j - <span class="number">1</span>);</span><br><span class="line">        sort(arr, j + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将数组切分为arr[lo..i-1], arr[i], arr[i+1..hi]</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;  <span class="comment">// 左右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> v = arr[lo];  <span class="comment">// 切分元素，即pivot</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 扫描左右，检查扫描是否结束并交换元素</span></span><br><span class="line">            <span class="keyword">while</span> (arr[++i] &lt; v) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (arr[--j] &gt; v) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, lo, j);  <span class="comment">// 将切分元素v放入正确的位置</span></span><br><span class="line">        <span class="keyword">return</span> j;  <span class="comment">// arr[lo..j-1] &lt;= arr[j] &lt;= arr[j+1..hi]达成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = i + random.nextInt(n - i);  <span class="comment">// i &lt;= r &lt;= n-1</span></span><br><span class="line">            swap(arr, i, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：当输入的数组有序或者基本有序时，快排的时间复杂度为$O(n^2)$。<strong>这里有两种解决方法，一种是在最开始随机打乱数组，另一种是进行partition操作时随机选择切分元素。</strong></p></blockquote><h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><strong>时间复杂度</strong>：平均、最好的时间复杂度为$O(n\log n)$，最坏的时间复杂度为$O(n^2)$。</li><li><strong>空间复杂度</strong>：$O(1)$</li><li><strong>是否稳定</strong>：不稳定；因为随机打乱数组或随机选择切分元素均会使得相等元素的相对顺序发生改变。</li></ul><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><h3 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h3><p>堆排序是指利用<strong>堆</strong>这种数据结构所设计的一种排序算法。</p><p><strong>堆</strong>是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p>具体流程如下：</p><ol><li>大顶堆的构造，将原始数组重新组织安排进一个堆中；</li><li>将堆首（最大值）和堆尾互换；</li><li>将堆的尺寸减1，利用下沉操作（代码中的sink()函数）将新的堆首元素调整到相应位置；</li><li>重复步骤二和步骤三，直到堆的尺寸为 1。</li></ol><blockquote><p>注：关于<strong>堆</strong>的具体内容可以看 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485231&amp;idx=1&amp;sn=8dfdc04bd209fba3077269faabe7c36f&source=41#wechat_redirect" target="_blank" rel="noopener">二叉堆是什么鬼？</a> 和 <a href="https://algs4.cs.princeton.edu/24pq/" target="_blank" rel="noopener">算法4 优先队列</a>等相关资料 ，这里就不再详细讲解了。</p></blockquote><h3 id="算法图示-3"><a href="#算法图示-3" class="headerlink" title="算法图示"></a>算法图示</h3><p>上面的步骤其实主要分成两步：</p><ul><li>第一步是<strong>堆的构建</strong>，这里不使用优先队列中的不断插入新元素来构建堆（时间复杂度$O(n\log n$)），而是从右到左用下沉操作（sink()函数）构建子堆，可以证明这里只需要$O(n)$的时间复杂度即可构建堆；</li><li>第二步是<strong>下沉排序</strong>，从堆中按递减顺序取出所有元素并得到排序结果。</li></ul><div align=center><img src="http://image.yingzq.com/img/20191229114501.png" width="700" alt="堆的构造（左）和下沉排序（右）" /><p>图：堆的构造（左）和下沉排序（右）</p></div><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 建立大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            sink(a, k, N);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 下沉排序</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            swap(a, <span class="number">1</span>, N--);</span><br><span class="line">            sink(a, <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n &amp;&amp; less(a, j, j + <span class="number">1</span>)) j++;</span><br><span class="line">            <span class="keyword">if</span> (!less(a, k, j)) <span class="keyword">break</span>;</span><br><span class="line">            swap(a, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[i - <span class="number">1</span>] &lt; a[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i - <span class="number">1</span>];</span><br><span class="line">        a[i - <span class="number">1</span>] = a[j - <span class="number">1</span>];</span><br><span class="line">        a[j - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：注意代码中的less()函数和swap()函数引索都减去了 1，这是由于堆顶元素从 引索 1 开始更方便。</p></blockquote><h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><strong>时间复杂度</strong>：平均、最好、最坏的时间复杂度均为$O(n\log n)$。</li><li><strong>空间复杂度</strong>：$O(1)$，堆排序是原地排序。</li><li><strong>是否稳定</strong>：不稳定。</li></ul><h2 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h2><h3 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围、最大值和最小值的差值不是很大的整数</strong>。</p><h3 id="动态演示-2"><a href="#动态演示-2" class="headerlink" title="动态演示"></a>动态演示</h3><div align=center><img src="http://image.yingzq.com/img/counting-sort.gif" width="700" alt="计数排序展示" /><p>计数排序展示</p></div><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 得到数列的最大值和最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = max(arr);</span><br><span class="line">        <span class="keyword">int</span> min = min(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算出现频率</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            count[num - min] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历频率数组，生成结果</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[idx++] = i + min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr)</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr)</span><br><span class="line">            min = Math.min(min, num);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是单纯的给整数排序，上面的代码就已经可以解决问题了。但是如果我们希望对数组进行的是稳定排序，也就是相同元素的相对顺序不改变呢？可以使用如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 得到数列的最大值和最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = max(arr);</span><br><span class="line">        <span class="keyword">int</span> min = min(arr);</span><br><span class="line">        <span class="keyword">int</span> R = max - min + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算出现频率</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            count[num - min + <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将频率转为引索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            count[i+<span class="number">1</span>] += count[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将元素分类</span></span><br><span class="line">        <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            aux[count[arr[i] - min]++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 回写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            arr[i] = aux[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr)</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr)</span><br><span class="line">            min = Math.min(min, num);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><strong>时间复杂度</strong>：当输入的元素是 n 个 m 到 m+k 之间的整数时，很容易算出平均、最好、最坏的时间复杂度均为$O(n+k)$。所以当 k 的值远小于 n 或者和 n 差不多大时，算法可以达到$O(n)$级别的线性时间复杂度。</li><li><strong>空间复杂度</strong>：$O(n+k)$；因为需要一个 k 大小的用来计数的数组，还需要一个 n 大小的辅助数组。</li><li><strong>是否稳定</strong>：稳定。</li></ul><h2 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h2><h3 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h3><p>桶排序是计数排序的升级版。它利用了<strong>函数的映射关系</strong>，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><p>具体流程如下：</p><ol><li>根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数；</li><li>遍历待排序集合，将每一个元素移动到对应的桶中；</li><li>将每个不为空的桶进行排序；</li><li>拼接不为空的桶中的数据，得到结果。</li></ol><h3 id="算法图示-4"><a href="#算法图示-4" class="headerlink" title="算法图示"></a>算法图示</h3><div align=center><img src="http://image.yingzq.com/img/20191228220059.png" width="700" alt="桶排序展示" /><p>图：桶排序展示</p></div><h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bucket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">double</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 得到数列的最大值和最小值</span></span><br><span class="line">        <span class="keyword">double</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化桶</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = arr.length;  <span class="comment">// 桶个数，这里取数组长度</span></span><br><span class="line">        List&lt;List&lt;Double&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            bucketList.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历原始数组，将每个元素放入桶中</span></span><br><span class="line">        <span class="keyword">double</span> gap = max - min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = (<span class="keyword">int</span>) ((num - min) * (bucketNum - <span class="number">1</span>) / gap);  <span class="comment">// 定义的映射规则</span></span><br><span class="line">            bucketList.get(idx).add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 对每个桶内部进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Double&gt; bucket : bucketList) &#123;</span><br><span class="line">            Collections.sort(bucket);  <span class="comment">// JDK底层采用了归并排序的优化版本</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 拼接不为空的桶中的数据，得到结果</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Double&gt; bucket : bucketList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> num : bucket) &#123;</span><br><span class="line">                arr[idx++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注1：这里使用double类型是因为刚好计数排序是无法完成double类型数组的排序的。另外，<strong>桶个数</strong>以及<strong>映射规则</strong>是根据实际情况调整的，代码中只是起了“举例”的作用。<br>注2：代码第二步中的初始化桶其实用数组而不是ArrayList更好，但是java不支持泛型数组，因此使用ArratList写起来更加简洁清晰。</p></blockquote><h3 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><strong>时间复杂度</strong>：这里用 m 来表示桶的个数，平均时间复杂度为$O(n) + O(m\frac{n}{m} \log \frac{n}{m})=O(n+n(\log n - \log m))$，当每个桶刚好有1个元素时有最好的时间复杂度$O(n)$，当一个桶有 n 个元素而其他桶都为空时有最坏时间复杂度$O(n\log n)$。</li><li><strong>空间复杂度</strong>：$O(n+m)$</li><li><strong>是否稳定</strong>：稳定；要注意的是桶内使用的排序算法需要是稳定排序。</li></ul><h2 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h2><h3 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。</p><p>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><h3 id="算法图示-5"><a href="#算法图示-5" class="headerlink" title="算法图示"></a>算法图示</h3><div align=center><img src="http://image.yingzq.com/img/20191229122730.png" width="600" alt="基数排序LSD展示" /><p>图：基数排序LSD展示</p></div><h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LSD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">10</span>;  <span class="comment">// 一位整数的范围在0~9之间，所以设置基数R=10</span></span><br><span class="line">        <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[N];  <span class="comment">// 辅助数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最大值位数</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (max / <span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxLen++;</span><br><span class="line">            max = max / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= maxLen; k++) &#123;</span><br><span class="line">            <span class="comment">// 对每一位使用计数排序</span></span><br><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R + <span class="number">1</span>];  <span class="comment">// 计算出现频率</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = (num / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, k - <span class="number">1</span>)) % <span class="number">10</span>;</span><br><span class="line">                count[idx + <span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;  <span class="comment">// 将频率转换为引索</span></span><br><span class="line">                count[i + <span class="number">1</span>] += count[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;  <span class="comment">// 将元素分类</span></span><br><span class="line">                <span class="keyword">int</span> idx = (num / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, k - <span class="number">1</span>)) % <span class="number">10</span>;</span><br><span class="line">                aux[count[idx]++] = num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;  <span class="comment">// 回写</span></span><br><span class="line">                arr[i] = aux[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h3><ul><li><strong>时间复杂度</strong>：用 k 来表示所需排序元素的平均位数，则基数排序平均、最好、最坏的时间复杂度均为$O(k*n)$；因为一共进行了 k 次循环，每次循环是一次计数排序（O(n)时间复杂度）。</li><li><strong>空间复杂度</strong>：$O(n+k)$</li><li><strong>是否稳定</strong>：稳定。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://algs4.cs.princeton.edu/20sorting/" target="_blank" rel="noopener">Algorithms 4th edition, sorting</a></li><li><a href="https://zhuanlan.zhihu.com/p/57088609" target="_blank" rel="noopener">必学十大经典排序算法，看这篇就够了</a></li><li><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法是算法的入门知识，其经典思想可以用于很多算法当中。本文将介绍常见排序算法的原理、对它们的分析以及对应的Java代码实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://www.yingzq.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Python3.7.6官方教程阅读笔记</title>
    <link href="http://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/"/>
    <id>http://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/</id>
    <published>2019-11-19T09:23:40.000Z</published>
    <updated>2020-02-27T07:06:24.177Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要复习一下Python一些基本的知识点，网上有着许许多多的Python学习教程，眼花缭乱，但是其实Python是有 <a href="https://docs.python.org/zh-cn/3/" target="_blank" rel="noopener">官方中文文档</a> 的，并且写的非常不错！所以对照着文档中的入门教程进行了学习，同时记录了一些值得注意的地方。</p><a id="more"></a><blockquote><p>注：本文选取了对应Python 3.7.6版本的官方教程进行阅读，另外本文只是<strong>简单记录了官方教程1到9章中（也就是不含标准库的部分）值得留意的、零碎的笔记</strong>便于复习。想要系统的学习一遍可移步 <a href="https://docs.python.org/zh-cn/3.7/tutorial/index.html" target="_blank" rel="noopener">官方入门教程</a> 。</p></blockquote><h2 id="初入Python"><a href="#初入Python" class="headerlink" title="初入Python"></a>初入Python</h2><h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p>Python除法运算 <code>/</code> 永远返回浮点数类型。如果想要得到一个忽略小数部分的整数结果（floor division），可以使用 <code>//</code> 运算符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> / <span class="number">3</span>  <span class="comment"># classic division returns a float</span></span><br><span class="line"><span class="number">5.666666666666667</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> // <span class="number">3</span>  <span class="comment"># floor division discards the fractional part</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>如果你不希望前置了 <code>\</code> 的字符转义成特殊字符，可以使用 <code>原始字符串</code> 方式，在引号前添加 <code>r</code> 即可:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'C:\some\name'</span>)  <span class="comment"># here \n means newline!</span></span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r'C:\some\name'</span>)  <span class="comment"># note the r before the quote</span></span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure><p>字符串字面值可以跨行连续输入。一种方式是用三重引号：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个 <code>\</code> 即可。</p><p>字符串可以用 <code>+</code> 进行连接（粘到一起），也可以用 <code>*</code> 进行重复:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 3 times 'un', followed by 'ium'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="string">'un'</span> + <span class="string">'ium'</span></span><br><span class="line"><span class="string">'unununium'</span></span><br></pre></td></tr></table></figure><p>相邻的两个或多个 <code>字符串字面值（引号引起来的字符）</code> 将会自动连接到一起:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Py'</span> <span class="string">'thon'</span></span><br><span class="line"><span class="string">'Python'</span></span><br></pre></td></tr></table></figure><p>把很长的字符串拆开分别输入的时候尤其有用:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = (<span class="string">'Put several strings within parentheses '</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">'to have them joined together.'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text</span><br><span class="line"><span class="string">'Put several strings within parentheses to have them joined together.'</span></span><br></pre></td></tr></table></figure><p>但是只能对两个字面值这样操作，变量或表达式不行，如果你想连接变量，或者连接变量和字面值，可以用 <code>+</code> 号。</p><p>字符串是可以被 <code>索引（下标访问）</code> 的，第一个字符索引是 0。单个字符并没有特殊的类型，只是一个长度为一的字符串。索引也可以用负数，这种会从右边开始数，<strong>注意 -0 和 0 是一样的，所以负数索引从 -1 开始</strong>。</p><p>除了索引，字符串还支持 <code>切片</code>，<strong>注意<code>切片</code>的开始总是被包括在结果中，而结束不被包括</strong>。另外切片的索引有默认值：省略开始索引时默认为 0，省略结束索引时默认为到字符串的结束。</p><p>试图使用过大的索引会产生一个错误，但是切片中的越界索引会被自动处理:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">42</span>]  <span class="comment"># the word only has 6 characters</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: string index out of range</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">4</span>:<span class="number">42</span>]</span><br><span class="line"><span class="string">'on'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">42</span>:]</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure><p><strong>Python 中的字符串不能被修改，它们是 <code>immutable</code> 的。</strong> 因此，向字符串的某个索引位置赋值会产生一个错误:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>] = <span class="string">'J'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:] = <span class="string">'py'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><blockquote><p>immutable: 具有固定值的对象。不可变对象包括数字、字符串和元组。这样的对象不能被改变。如果必须存储一个不同的值，则必须创建新的对象。它们在需要常量哈希值的地方起着重要作用，例如作为字典中的键。</p></blockquote><p>如果需要一个不同的字符串，应当新建一个:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'J'</span> + word[<span class="number">1</span>:]</span><br><span class="line"><span class="string">'Jython'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>] + <span class="string">'py'</span></span><br><span class="line"><span class="string">'Pypy'</span></span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Python 中可以通过组合一些值得到多种 <code>复合</code> 数据类型。其中最常用的 <code>列表</code>，可以通过方括号括起、逗号分隔的一组值（元素）得到。一个 <code>列表</code> 可以包含不同类型的元素，但通常使用时各个元素类型相同。</p><p>和字符串（以及各种内置的 <code>sequence</code> 类型）一样，列表也支持索引和切片。所有的切片操作都返回一个新列表，这个新列表包含所需要的元素。就是说，如下的切片会返回<code>列表的一个新的(浅)拷贝</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[:]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><p>与 <code>immutable</code> 的字符串不同, 列表是一个 <code>mutable</code> 类型，就是说，它自己的内容是可以改变的。</p><blockquote><p>注：后面章节会更加详细的介绍列表。</p></blockquote><h2 id="流程控制工具"><a href="#流程控制工具" class="headerlink" title="流程控制工具"></a>流程控制工具</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>值得注意的是Python中使用的是<code>elif</code>而不是类似Java、C语言中的 “else if” ，其实关键字<code>elif</code>就是 “else if” 的缩写。Python中一个 <code>if ... elif ... elif ...</code> 序列可以看作是其他语言中的 switch 或 case 语句的替代。</p><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p>Python中的 <code>for</code> 语句与你在 C 或 Java 中可能用到的有所不同。Python中的 <code>for</code> 语句是对任意序列进行迭代（例如列表或字符串），条目的迭代顺序与它们在序列中出现的顺序一致。</p><p><strong>如果在循环内需要修改序列中的值（比如重复某些选中的元素），推荐你先拷贝一份副本。</strong> 对序列进行循环不代表制作了一个副本进行操作。切片操作使这件事非常简单：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = [<span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> w <span class="keyword">in</span> words[:]:  <span class="comment"># Loop over a slice copy of the entire list.</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> len(w) &gt; <span class="number">6</span>:</span><br><span class="line"><span class="meta">... </span>        words.insert(<span class="number">0</span>, w)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words</span><br><span class="line">[<span class="string">'defenestrate'</span>, <span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br></pre></td></tr></table></figure><p>如果写成 <code>for w in words:</code>，这个示例就会创建无限长的列表，一次又一次重复地插入 <code>defenestrate</code>。</p><h3 id="循环中的-else-子句"><a href="#循环中的-else-子句" class="headerlink" title="循环中的 else 子句"></a>循环中的 else 子句</h3><p>Python <code>循环语句</code>可能带有一个 <code>else 子句</code>；<strong>它会在循环遍历完列表 (使用 for) 或是在条件变为假 (使用 while) 的时候被执行，但是不会在循环被 break 语句终止时被执行。</strong> 这可以通过以下搜索素数的循环为例来进行说明:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line"><span class="meta">... </span>        print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h3><p><code>pass</code> 语句什么也不做。<strong>当语法上需要一个语句，但程序需要什么动作也不做时，可以使用它</strong>。例如:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span>  <span class="comment"># Busy-wait for keyboard interrupt (Ctrl+C)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通常还用于创建最小的类:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyEmptyClass</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>pass</code> 的另一个可以使用的场合是在你编写新的代码时作为一个函数或条件子句体的占位符，允许你保持在更抽象的层次上进行思考。 <code>pass</code> 会被静默地忽略:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">initlog</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span>   <span class="comment"># Remember to implement this!</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="函数定义的更多形式"><a href="#函数定义的更多形式" class="headerlink" title="函数定义的更多形式"></a>函数定义的更多形式</h2><p>给函数定义有可变数目的参数也是可行的。这里有三种形式，可以组合使用。</p><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>最有用的形式是对一个或多个参数指定一个默认值。这样创建的函数，可以用比定义时允许的更少的参数调用。此类函数可以通过几种方式调用:</p><ul><li>只给出必需的参数</li><li>给出部分可选的参数</li><li>给出所有的参数</li></ul><p>需要注意的是<strong>默认值是在定义过程中在函数定义处计算的</strong>，所以:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(arg=i)</span>:</span></span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">f()</span><br></pre></td></tr></table></figure><p>会打印 <code>5</code>。</p><p><strong>重要警告：</strong> <code>默认值只会执行一次</code>。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。比如，下面的函数会存储在后续调用中传递给它的参数:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, L=[])</span>:</span></span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line">print(f(<span class="number">1</span>))</span><br><span class="line">print(f(<span class="number">2</span>))</span><br><span class="line">print(f(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>这将打印出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>如果你不想要在后续调用之间共享默认值，你可以这样写这个函数:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>也可以使用形如 <code>kwarg=value</code> 的关键字参数来调用函数。</p><p>需要注意的是，在函数调用中，<strong>关键字参数必须跟随在位置参数的后面；传递的所有关键字参数必须与函数接受的其中一个参数匹配，它们的顺序并不重要，这也包括非可选参数；也不能对同一个参数多次赋值。</strong></p><p>当存在一个形式为 <code>**name</code> 的最后一个形参时，它会接收一个<strong>字典</strong>，其中包含除了与已有形参相对应的关键字参数以外的所有关键字参数。这可以与一个形式为 <code>*name</code>，接收一个包含除了已有形参列表以外的位置参数的<strong>元组</strong>的形参 (将在下一小节介绍) 组合使用，其中 <code>*name</code> 必须出现在 <code>**name</code> 之前！。例如，如果我们这样定义一个函数:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cheeseshop</span><span class="params">(kind, *arguments, **keywords)</span>:</span></span><br><span class="line">    print(<span class="string">"-- Do you have any"</span>, kind, <span class="string">"?"</span>)</span><br><span class="line">    print(<span class="string">"-- I'm sorry, we're all out of"</span>, kind)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> arguments:</span><br><span class="line">        print(arg)</span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line">    <span class="keyword">for</span> kw <span class="keyword">in</span> keywords:</span><br><span class="line">        print(kw, <span class="string">":"</span>, keywords[kw])</span><br></pre></td></tr></table></figure><p>它可以像这样调用:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cheeseshop(<span class="string">"Limburger"</span>, <span class="string">"It's very runny, sir."</span>,</span><br><span class="line">           <span class="string">"It's really very, VERY runny, sir."</span>,</span><br><span class="line">           shopkeeper=<span class="string">"Michael Palin"</span>,</span><br><span class="line">           client=<span class="string">"John Cleese"</span>,</span><br><span class="line">           sketch=<span class="string">"Cheese Shop Sketch"</span>)</span><br></pre></td></tr></table></figure><p>当然它会打印:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- Do you have any Limburger ?</span><br><span class="line">-- I&#39;m sorry, we&#39;re all out of Limburger</span><br><span class="line">It&#39;s very runny, sir.</span><br><span class="line">It&#39;s really very, VERY runny, sir.</span><br><span class="line">----------------------------------------</span><br><span class="line">shopkeeper : Michael Palin</span><br><span class="line">client : John Cleese</span><br><span class="line">sketch : Cheese Shop Sketch</span><br></pre></td></tr></table></figure><p>注意打印时关键字参数的顺序保证与调用函数时提供它们的顺序是相匹配的。</p><h3 id="任意的参数列表"><a href="#任意的参数列表" class="headerlink" title="任意的参数列表"></a>任意的参数列表</h3><p>最后，最不常用的选项是可以使用任意数量的参数调用函数。这些参数会被包含在一个<strong>元组</strong>里，在可变数量的参数之前，可能会出现零个或多个普通参数:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_multiple_items</span><span class="params">(file, separator, *args)</span>:</span></span><br><span class="line">    file.write(separator.join(args))</span><br></pre></td></tr></table></figure><p><strong>一般来说，这些 <code>可变参数</code> 将在形式参数列表的末尾，因为它们收集传递给函数的所有剩余输入参数。出现在 <code>*args</code> 参数之后的任何形式参数都是 ‘仅关键字参数’，也就是说它们只能作为关键字参数而不能是位置参数:</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat</span><span class="params">(*args, sep=<span class="string">"/"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sep.join(args)</span><br></pre></td></tr></table></figure><h3 id="解包参数列表"><a href="#解包参数列表" class="headerlink" title="解包参数列表"></a>解包参数列表</h3><p>当参数已经在列表或元组中但需要为需要单独位置参数的函数调用解包时，会发生相反的情况。例如，内置的 range() 函数需要单独的 start 和 stop 参数。如果它们不能单独使用，请使用 <code>*</code> 运算符编写函数调用以从列表或元组中解包参数:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">3</span>, <span class="number">6</span>))            <span class="comment"># normal call with separate arguments</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = [<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(*args))            <span class="comment"># call with arguments unpacked from a list</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>以同样的方式，字典可以使用 <code>**</code> 运算符来提供关键字参数。</p><h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><p>可以用 <code>lambda</code> 关键字来创建一个小的匿名函数。这个函数返回两个参数的和：<code>lambda a, b: a+b</code> 。<strong>lambda函数可以在需要函数对象的任何地方使用。</strong> 它们在语法上限于单个表达式。从语义上来说，它们只是正常函数定义的语法糖。与嵌套函数定义一样，lambda函数可以引用所包含域的变量:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_incrementor</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = make_incrementor(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">0</span>)</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>)</span><br><span class="line"><span class="number">43</span></span><br></pre></td></tr></table></figure><p>上面的例子使用一个lambda表达式来返回一个函数。另一个用法是传递一个小函数作为参数:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs = [(<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">2</span>, <span class="string">'two'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">4</span>, <span class="string">'four'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs.sort(key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs</span><br><span class="line">[(<span class="number">4</span>, <span class="string">'four'</span>), (<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">2</span>, <span class="string">'two'</span>)]</span><br></pre></td></tr></table></figure><h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>以下是有关文档字符串的内容和格式的一些约定。</p><p><strong>第一行应该是对象目的的简要概述。</strong> 为简洁起见，它不应显式声明对象的名称或类型，因为这些可通过其他方式获得（除非名称恰好是描述函数操作的动词）。这一行应以大写字母开头，以句点结尾。</p><p><strong>如果文档字符串中有更多行，则第二行应为空白，从而在视觉上将摘要与其余描述分开。</strong> 后面几行应该是一个或多个段落，描述对象的调用约定，它的副作用等。</p><p>Python 解析器不会从 Python 中删除多行字符串文字的缩进，因此处理文档的工具必须在需要时删除缩进。 这是使用以下约定完成的：<strong>文档字符串第一行之后的第一个非空行确定整个文档字符串的缩进量（我们不能使用第一行，因为它通常与字符串的开头引号相邻，因此它的缩进在字符串文字中不明显）。</strong> 然后从字符串的所有行的开头剥离与该缩进 “等效” 的空格。 缩进更少的行不应该出现，但是如果它们出现，则应该剥离它们的所有前导空格。 应在转化制表符为空格后测试空格的等效性（通常转化为8个空格）。</p><p>下面是一个多行文档字符串的例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Do nothing, but document it.</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    No, really, it doesn't do anything.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    """</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_function.__doc__)</span><br><span class="line">Do nothing, but document it.</span><br><span class="line"></span><br><span class="line">    No, really, it doesn<span class="string">'t do anything.</span></span><br></pre></td></tr></table></figure><h3 id="函数标注"><a href="#函数标注" class="headerlink" title="函数标注"></a>函数标注</h3><p><code>函数标注</code>是关于用户自定义函数中使用的类型的完全可选元数据信息。</p><p><strong>函数标注以字典的形式存放在函数的 <code>__annotations__</code> 属性中，并且不会影响函数的任何其他部分。</strong> 形参标注的定义方式是在形参名称后加上冒号，后面跟一个表达式，该表达式会被求值为标注的值。 返回值标注的定义方式是加上一个组合符号 <code>-&gt;</code>，后面跟一个表达式，该标注位于形参列表和表示 def 语句结束的冒号之间。 下面的示例有一个位置参数，一个关键字参数以及返回值带有相应标注:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(ham: str, eggs: str = <span class="string">'eggs'</span>)</span> -&gt; str:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Annotations:"</span>, f.__annotations__)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Arguments:"</span>, ham, eggs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> ham + <span class="string">' and '</span> + eggs</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="string">'spam'</span>)</span><br><span class="line">Annotations: &#123;'ham': &lt;class 'str'&gt;, 'return': &lt;class 'str'&gt;, 'eggs': &lt;class 'str'&gt;&#125;</span><br><span class="line">Arguments: spam eggs</span><br><span class="line"><span class="string">'spam and eggs'</span></span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="列表的更多特性"><a href="#列表的更多特性" class="headerlink" title="列表的更多特性"></a>列表的更多特性</h3><p><strong>1. 列表对象方法的清单</strong></p><ul><li>list.<strong>append</strong>(x) ：在列表的末尾添加一个元素。相当于 <code>a[len(a):] = [x]</code> 。</li><li>list.<strong>extend</strong>(iterable) ：使用可迭代对象中的所有元素来扩展列表。相当于 <code>a[len(a):] = iterable</code> 。</li><li>list.<strong>insert</strong>(i, x) ：在给定的位置插入一个元素。第一个参数是要插入的元素的索引，所以 <code>a.insert(0, x)</code> 插入列表头部， <code>a.insert(len(a), x)</code> 等同于 <code>a.append(x)</code> 。</li><li>list.<strong>remove</strong>(x) ：移除列表中第一个值为 x 的元素。如果没有这样的元素，则抛出 ValueError 异常。</li><li>list.<strong>pop</strong>([i]) ：删除列表中给定位置的元素并返回它。如果没有给定位置，<code>a.pop()</code> 将会删除并返回列表中的最后一个元素。<em>（ 方法签名中 i 两边的方括号表示这个参数是可选的，而不是要你输入方括号。你会在 Python 参考库中经常看到这种表示方法)</em></li><li>list.<strong>clear</strong>() ：移除列表中的所有元素。等价于<code>del a[:]</code>。</li><li>list.<strong>index</strong>(x[, start[, end]]) ：返回列表中第一个值为 x 的元素的从零开始的索引。如果没有这样的元素将会抛出 ValueError 异常。可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数。</li><li>list.<strong>count</strong>(x) ：返回元素 x 在列表中出现的次数。</li><li>list.<strong>sort</strong>(key=None, reverse=False) ：对列表中的元素进行排序。</li><li>list.<strong>reverse</strong>() ：翻转列表中的元素。</li><li>list.<strong>copy</strong>() ：返回列表的一个浅拷贝，等价于 <code>a[:]</code>。</li></ul><p>根据上面的方法，是可以很轻松的将列表作为<code>栈</code>或者<code>队列</code>使用的。但是列表作为<code>队列</code>使用是相当低效的，因为在列表的末尾添加和弹出元素非常快，但是在列表的开头插入或弹出元素却很慢 (因为所有的其他元素都必须移动一位)，若要实现一个队列，可使用 <code>collections.deque</code>，它被设计成可以快速地从两端添加或弹出元素。</p><p><strong>2. 列表推导式</strong></p><p>列表推导式提供了一个更简单的创建列表的方法。常见的用法是把某种操作应用于序列或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。</p><p>例如，假设我们想创建一个平方列表，像这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    squares.append(x**<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p>可以写成：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p><strong>列表推导式的结构是由一对方括号所包含的以下内容：一个表达式，后面跟一个 for 子句，然后是零个或多个 for 或 if 子句。 其结果将是一个新列表，由对表达式依据后面的 for 和 if 子句的内容进行求值计算而得出。</strong> 举例来说，以下列表推导式会将两个列表中不相等的元素组合起来:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure><p>而它等价于</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> x != y:</span><br><span class="line"><span class="meta">... </span>            combs.append((x, y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure><p>注意在上面两个代码片段中，<strong>for 和 if 的顺序是相同的</strong>。</p><p>如果表达式是一个元组（例如上面的 <code>(x, y)</code>），那么就必须加上括号。另外列表推导式可以使用复杂的表达式和嵌套函数。</p><p><strong>3. 嵌套的列表推导式</strong></p><p>列表推导式中的初始表达式可以是任何表达式，包括另一个列表推导式。</p><p>考虑下面这个 3x4的矩阵，它由3个长度为4的列表组成</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [</span><br><span class="line"><span class="meta">... </span>    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"><span class="meta">... </span>]</span><br></pre></td></tr></table></figure><p>下面的列表推导式将交换其行和列</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>如上节所示，嵌套的列表推导式是基于跟随其后的 for 进行求值的，所以这个例子等价于:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure><p>实际应用中，你应该会更喜欢使用内置函数去组成复杂的流程语句。 <code>zip()</code> 函数将会很好地处理这种情况</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*matrix))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure><h3 id="del-语句"><a href="#del-语句" class="headerlink" title="del 语句"></a>del 语句</h3><p>有一种方式可以从列表按照给定的索引而不是值来移除一个元素: 那就是 <code>del</code> 语句。 它不同于会返回一个值的 pop() 方法， <code>del</code> 语句也可以用来从列表中移除切片或者清空整个列表，也可以删除整个变量。</p><h3 id="元组，集合以及字典"><a href="#元组，集合以及字典" class="headerlink" title="元组，集合以及字典"></a>元组，集合以及字典</h3><p><code>元组</code>可能看起来与列表很像，但它们通常是在不同的场景被使用，并且有着不同的用途。元组是 <code>immutable</code> ，其序列通常包含不同种类的元素，并且通过解包或者索引来访问（如果是 <code>namedtuples</code> 的话甚至还可以通过属性访问）。列表是 <code>mutable</code> ，并且列表中的元素一般是同种类型的，并且通过迭代访问。</p><p>Python也包含有 <code>集合</code> 类型。集合是由不重复元素组成的无序的集。它的基本用法包括成员检测和消除重复元素。集合对象也支持像 联合，交集，差集，对称差分等数学运算。<code>花括号或 set() 函数</code>可以用来创建集合。<strong>注意：</strong>要创建一个空集合你只能用 <code>set()</code> 而不能用 <code>{}</code>，因为后者是创建一个空字典。</p><p>下面简单演示集合之间常用的运算：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Demonstrate set operations on unique letters from two words</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  <span class="comment"># unique letters in a</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># letters in a but not in b</span></span><br><span class="line">&#123;<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># letters in a or b or both</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># letters in both a and b</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># letters in a or b but not both</span></span><br><span class="line">&#123;<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>&#125;</span><br></pre></td></tr></table></figure><p>还有一个非常有用的 Python 內置数据类型是 <code>字典</code>。与以连续整数为索引的序列不同，字典是以 <code>关键字</code> 为索引的，关键字可以是任意不可变类型，通常是字符串或数字。如果一个元组只包含字符串、数字或元组，那么这个元组也可以用作关键字。但如果元组直接或间接地包含了可变对象，那么它就不能用作关键字。列表不能用作关键字，因为列表可以通过索引、切片或 append() 和 extend() 之类的方法来改变。</p><p>对于字典的创建，除了一般的初始化，还有一些其他方法：</p><ul><li>dict() 构造函数可以直接从键值对序列里创建字典，例如<code>dict([(&#39;sape&#39;, 4139), (&#39;guido&#39;, 4127), (&#39;jack&#39;, 4098)])</code>。</li><li>字典推导式可以从任意的键值表达式中创建字典，例如<code>{x: x**2 for x in (2, 4, 6)}</code>。</li><li>当关键字是简单字符串时，有时直接通过关键字参数来指定键值对更方便，例如<code>dict(sape=4139, guido=4127, jack=4098)</code>。</li></ul><h3 id="循环的技巧"><a href="#循环的技巧" class="headerlink" title="循环的技巧"></a>循环的技巧</h3><ul><li>当在字典中循环时，用 <code>items()</code> 方法可将关键字和对应的值同时取出</li><li>当在序列中循环时，用 <code>enumerate()</code> 函数可以将索引位置和其对应的值同时取出</li><li>当同时在两个或更多序列中循环时，可以用 <code>zip()</code> 函数将其内元素一一匹配</li><li>如果要逆向循环一个序列，可以先正向定位序列，然后调用 <code>reversed()</code> 函数</li><li>如果要按某个指定顺序循环一个序列，可以用 <code>sorted()</code> 函数，它可以<strong>在不改动原序列的基础上返回一个新的排好序的序列</strong></li><li>有时可能会想在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全的</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是一个包含Python定义和语句的文件。文件名就是模块名后跟文件后缀 <code>.py</code> 。在一个模块内部，模块名（作为一个字符串）可以通过全局变量 <code>__name__</code> 的值获得。</p><h3 id="以脚本的方式执行模块"><a href="#以脚本的方式执行模块" class="headerlink" title="以脚本的方式执行模块"></a>以脚本的方式执行模块</h3><p>当你用下面方式运行一个Python模块:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python test.py &lt;arguments&gt;</span><br></pre></td></tr></table></figure><p>模块里的代码会被执行，就好像你导入了模块一样，但是 <code>__name__</code> 被赋值为 <code>&quot;__main__&quot;</code>。 这意味着通过在你的模块末尾添加这些代码:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    test(int(sys.argv[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p><strong>你既可以把这个文件当作脚本又可当作一个可调入的模块来使用， 因为那段解析命令行的代码只有在当模块是以“main”文件的方式执行的时候才会运行，如果模块是被导入的，那些代码是不运行的。</strong> 这经常用于为模块提供一个方便的用户接口，或用于测试（以脚本的方式运行模块从而执行一些测试套件）。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。 例如，模块名 <code>A.B</code> 表示 <code>A</code> 包中名为 <code>B</code> 的子模块。正如模块的使用使得不同模块的作者不必担心彼此的全局变量名称一样，使用加点的模块名可以使得 NumPy 或 Pillow 等多模块软件包的作者不必担心彼此的模块名称一样。</p><p><strong>必须要有 <code>__init__.py</code> 文件才能让 Python 将包含该文件的目录当作包。</strong> 这样可以防止具有通常名称例如 <code>string</code> 的目录在无意中隐藏稍后在模块搜索路径上出现的有效模块。 在最简单的情况下，<code>__init__.py</code> 可以只是一个空文件，但它也可以执行包的初始化代码或设置 <code>__all__</code> 变量，具体将在后文介绍。</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="更漂亮的输出格式"><a href="#更漂亮的输出格式" class="headerlink" title="更漂亮的输出格式"></a>更漂亮的输出格式</h3><p><strong>1. 格式化字符串文字</strong></p><p><code>格式化字符串字面值（常简称为 f-字符串）</code>能让你在字符串前加上 <code>f</code> 和 <code>F</code> 并将表达式写成 <code>{expression}</code> 来在字符串中包含 Python 表达式的值。</p><p>可选的格式说明符可以跟在表达式后面。这样可以更好地控制值的格式化方式。以下示例将pi舍入到小数点后三位:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f'The value of pi is approximately <span class="subst">&#123;math.pi:<span class="number">.3</span>f&#125;</span>.'</span>)</span><br><span class="line">The value of pi <span class="keyword">is</span> approximately <span class="number">3.142</span>.</span><br></pre></td></tr></table></figure><p>关于更多格式规范的参考，请参阅参考指南 <a href="https://docs.python.org/zh-cn/3.7/library/string.html#formatspec" target="_blank" rel="noopener">格式规格迷你语言</a> 。</p><p><strong>2. 字符串的 format() 方法</strong></p><p><code>str.format()</code> 方法的基本用法如下所示:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'We are the &#123;&#125; who say "&#123;&#125;!"'</span>.format(<span class="string">'knights'</span>, <span class="string">'Ni'</span>))</span><br><span class="line">We are the knights who say <span class="string">"Ni!"</span></span><br></pre></td></tr></table></figure><p>花括号和其中的字符（称为格式字段）将替换为传递给 <code>str.format()</code> 方法的对象。花括号中的数字可用来表示传递给 <code>str.format()</code> 方法的对象的位置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;0&#125; and &#123;1&#125;'</span>.format(<span class="string">'spam'</span>, <span class="string">'eggs'</span>))</span><br><span class="line">spam <span class="keyword">and</span> eggs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;1&#125; and &#123;0&#125;'</span>.format(<span class="string">'spam'</span>, <span class="string">'eggs'</span>))</span><br><span class="line">eggs <span class="keyword">and</span> spam</span><br></pre></td></tr></table></figure><p>如果在 <code>str.format()</code> 方法中使用关键字参数，则使用参数的名称引用它们的值:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'This &#123;food&#125; is &#123;adjective&#125;.'</span>.format(</span><br><span class="line"><span class="meta">... </span>      food=<span class="string">'spam'</span>, adjective=<span class="string">'absolutely horrible'</span>))</span><br><span class="line">This spam <span class="keyword">is</span> absolutely horrible.</span><br></pre></td></tr></table></figure><p>位置和关键字参数可以任意组合:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'The story of &#123;0&#125;, &#123;1&#125;, and &#123;other&#125;.'</span>.format(<span class="string">'Bill'</span>, <span class="string">'Manfred'</span>, other=<span class="string">'Georg'</span>))</span><br><span class="line">The story of Bill, Manfred, <span class="keyword">and</span> Georg.</span><br></pre></td></tr></table></figure><p>关于使用 <code>str.format()</code> 进行字符串格式化的完整概述，请参阅 <a href="https://docs.python.org/zh-cn/3.7/library/string.html#formatstrings" target="_blank" rel="noopener">格式字符串语法</a> 。</p><p><strong>3. str() 与 repr()</strong></p><p><code>str()</code> 函数是用于返回人类可读的值的表示，而 <code>repr()</code> 是用于生成解释器可读的表示（如果没有等效的语法，则会强制执行 SyntaxError）对于没有人类可读性的表示的对象， <code>str()</code> 将返回和 <code>repr()</code> 一样的值。很多值使用任一函数都具有相同的表示，比如数字或类似列表和字典的结构。特殊的是字符串有两个不同的表示。</p><p><strong>4. 手动格式化字符串</strong></p><p>字符串对象的 <code>str.rjust()</code> 方法通过在左侧填充空格来对给定宽度的字段中的字符串进行右对齐。类似的方法还有 <code>str.ljust()</code> 和 <code>str.center()</code> 。这些方法不会写入任何东西，它们只是返回一个新的字符串，如果输入的字符串太长，它们不会截断字符串，而是原样返回；这虽然会弄乱你的列布局，但这通常比另一种方法好，后者会在显示值时可能不准确。（如果你真的想截断，你可以添加一个切片操作，例如 <code>x.ljust(n)[:n]</code> 。）</p><p>还有另外一个方法，<code>str.zfill()</code> ，它会在数字字符串的左边填充零。</p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p><strong>1. open() 函数</strong></p><p><code>open()</code> 返回一个 <code>file object</code>，最常用的有两个参数： <code>open(filename, mode)</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'workfile'</span>, <span class="string">'w'</span>)</span><br></pre></td></tr></table></figure><p>第一个参数是包含文件名的字符串。第二个参数是另一个字符串，其中包含一些描述文件使用方式的字符。mode 可以是 <code>&#39;r&#39;</code> ，表示文件只能读取，<code>&#39;w&#39;</code> 表示只能写入（已存在的同名文件会被删除），还有 <code>&#39;a&#39;</code> 表示打开文件以追加内容；任何写入的数据会自动添加到文件的末尾。<code>&#39;r+&#39;</code> 表示打开文件进行读写。<code>mode参数</code> 是可选的；省略时默认为 <code>&#39;r&#39;</code>。</p><p>在处理文件对象时，最好使用 <code>with</code> 关键字。 <strong>优点是当子句体结束后文件会正确关闭，即使在某个时刻引发了异常。</strong> 而且使用 <code>with</code> 相比等效的 <code>try-finally</code> 代码块要简短得多:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'workfile'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    read_data = f.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.closed</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>2. 文件对象的方法</strong></p><p>要读取文件内容，请调用 <code>f.read(size)</code>，它会读取一些数据并将其作为字符串（在文本模式下）或字节串对象（在二进制模式下）返回。 <code>size</code> 是一个可选的数值参数。 当 <code>size</code> 被省略或者为负数时，将读取并返回整个文件的内容；如果文件的大小是你的机器内存的两倍就会出现问题。 当取其他值时，将读取并返回至多 <code>size</code> 个字符（在文本模式下）或 <code>size</code> 个字节（在二进制模式下）。 如果已到达文件末尾，<code>f.read()</code> 将返回一个空字符串 (<code>&#39;&#39;</code>)。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">'This is the entire file.\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure><p><code>f.readline()</code> 从文件中读取一行；换行符（<code>\n</code>）留在字符串的末尾，如果文件不以换行符结尾，则在文件的最后一行省略。<strong>这使得返回值明确无误</strong>；如果 <code>f.readline()</code> 返回一个空的字符串，则表示已经到达了文件末尾，而空行使用 <code>&#39;\n&#39;</code> 表示，该字符串只包含一个换行符。</p><p>要从文件中读取行，你可以循环遍历文件对象。这是内存高效，快速的，并简化代码:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line"><span class="meta">... </span>    print(line, end=<span class="string">''</span>)</span><br><span class="line">...</span><br><span class="line">This <span class="keyword">is</span> the first line of the file.</span><br><span class="line">Second line of the file</span><br></pre></td></tr></table></figure><p>如果你想以列表的形式读取文件中的所有行，你也可以使用 <code>list(f)</code> 或 <code>f.readlines()</code>。</p><p><code>f.write(string)</code> 会把 <code>string</code> 的内容写入到文件中，并返回写入的字符数。在写入其他类型的对象之前，需要先把它们转化为字符串（在文本模式下）或者字节对象（在二进制模式下）。</p><p>文件对象有一些额外的方法，使用频率没这么高，就不详细介绍了。</p><p><strong>3. 使用 json 保存结构化数据</strong></p><p>Python 允许你使用称为 <code>JSON (JavaScript Object Notation)</code> 的流行数据交换格式，而不是让用户不断的编写和调试代码以将复杂的数据类型保存到文件中。名为 <code>json</code> 的标准模块可以采用 Python 数据层次结构，并将它们转化为字符串表示形式；这个过程称为 <code>serializing</code> 。从字符串表示中重建数据称为 <code>deserializing</code> 。在序列化和反序列化之间，表示对象的字符串可能已存储在文件或数据中，或通过网络连接发送到某个远程机器。</p><h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p><code>语法错误</code>又称<code>解析错误</code>，可能是你在学习Python 时最容易遇到的错误:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span> print(<span class="string">'Hello world'</span>)</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span> print(<span class="string">'Hello world'</span>)</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>解析器会输出出现语法错误的那一行，并显示一个“箭头”，指向这行里面检测到第一个错误。 错误是由箭头指示的位置<strong>上面</strong>的 token 引起的（或者至少是在这里被检测出的）：在示例中，在 <code>print()</code> 这个函数中检测到了错误，因为在它前面少了个冒号 (<code>&#39;:&#39;</code>) 。文件名和行号也会被输出，以便输入来自脚本文件时你能知道去哪检查。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>即使语句或表达式在语法上是正确的，但在尝试执行时，它仍可能会引发错误，在执行时检测到的错误被称为 <code>异常</code>。</p><p>异常不一定会导致严重后果， 但是大多数异常并不会被程序处理，此时会显示如下所示的错误信息:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> * (<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> + spam*<span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'spam'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'2'</span> + <span class="number">2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">'t convert '</span>int<span class="string">' object to str implicitly</span></span><br></pre></td></tr></table></figure><p>错误信息的最后一行告诉我们程序遇到了什么类型的错误。异常有不同的类型，而其类型名称将会作为错误信息的一部分中打印出来：上述示例中的异常类型依次是：ZeroDivisionError， NameError 和 TypeError。作为异常类型打印的字符串是发生的内置异常的名称。对于所有内置异常都是如此，但对于用户定义的异常则不一定如此（虽然这是一个有用的规范）。标准的异常类型是内置的标识符（而不是保留关键字）。</p><p>这一行的剩下的部分根据异常类型及其原因提供详细信息。</p><p>错误信息的前一部分以堆栈回溯的形式显示发生异常时的上下文。通常它包含列出源代码行的堆栈回溯；但是它不会显示从标准输入中读取的行。</p><p><a href="https://docs.python.org/zh-cn/3.7/library/exceptions.html#bltin-exceptions" target="_blank" rel="noopener">内置异常</a> 列出了内置异常和它们的含义。</p><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>可以编写处理所选异常的程序。请看下面的例子，它会要求用户一直输入，直到输入的是一个有效的整数，但允许用户中断程序（使用 Control-C 或操作系统支持的其他操作）；请注意用户引起的中断可以通过引发 KeyboardInterrupt 异常来指示:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        x = int(input(<span class="string">"Please enter a number: "</span>))</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Oops!  That was no valid number.  Try again..."</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>try 语句</code> 的工作原理如下：</p><ul><li>首先，执行 <code>try 子句</code>（try 和 except 关键字之间的（多行）语句）。</li><li>如果没有异常发生，则跳过 <code>except 子句</code> 并完成 <code>try 语句</code>的执行。</li><li>如果在执行<code>try 子句</code>时发生了异常，则跳过该子句中剩下的部分。然后，如果异常的类型和 except 关键字后面的异常匹配，则执行 <code>except 子句</code> ，然后继续执行 <code>try 语句</code><strong>之后</strong>的代码。</li></ul><p>如果发生的异常和 except 子句中指定的异常不匹配，则将其传递到外部的 try 语句中；如果没有找到处理程序，则它是一个 未处理异常，执行将停止并显示如上所示的消息。</p><p>一个 <code>try 语句</code>可能有多个 <code>except 子句</code>，以指定不同异常的处理程序。 最多会执行一个处理程序，处理程序只处理相应的 <code>try 子句</code> 中发生的异常，而不处理同一 <code>try 语句</code> 内其他处理程序中的异常。</p><p><code>try ... except 语句</code> 有一个可选的 <code>else 子句</code>，在使用时必须放在<strong>所有的 <code>except 子句</code> 后面</strong>。<strong>对于在try 子句不引发异常时必须执行的代码来说很有用。</strong></p><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p><code>raise</code> 语句允许程序员强制发生指定的异常。例如:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure><p><code>raise</code> 唯一的参数就是要抛出的异常。这个参数必须是一个异常实例或者是一个异常类（派生自 <code>Exception</code> 的类）。如果传递的是一个异常类，它将通过调用没有参数的构造函数来隐式实例化:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> ValueError  <span class="comment"># shorthand for 'raise ValueError()'</span></span><br></pre></td></tr></table></figure><p>如果你需要确定是否引发了异常但不打算处理它，则可以使用更简单的 <code>raise</code> 语句形式重新引发异常:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> NameError:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'An exception flew by!'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span></span><br><span class="line">...</span><br><span class="line">An exception flew by!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure><h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h3><p>程序可以通过创建新的异常类来命名它们自己的异常，异常通常应该直接或间接地从 <code>Exception</code> 类派生。</p><p>可以定义异常类，它可以执行任何其他类可以执行的任何操作，但通常保持简单，通常只提供许多属性，这些属性允许处理程序为异常提取有关错误的信息。在创建可能引发多个不同错误的模块时，通常的做法是为该模块定义的异常创建基类，并为不同错误条件创建特定异常类的子类。</p><p>大多数异常都定义为名称以“Error”结尾，类似于标准异常的命名。</p><h3 id="定义清理操作"><a href="#定义清理操作" class="headerlink" title="定义清理操作"></a>定义清理操作</h3><p>try 语句有另一个可选的 <code>finally 子句</code>，用于定义必须在所有情况下执行的清理操作。</p><p>如果存在 <code>finally 子句</code>，则 <code>finally 子句</code>将作为 try 语句结束前的最后一项任务被执行。 <strong><code>finally 子句</code> 不论 try 语句是否产生了异常都会被执行。</strong> 以下几点讨论了当异常发生时一些更复杂的情况：</p><ul><li>如果在执行 try 子句期间发生了异常，该异常可由一个 except 子句进行处理。 如果异常没有被某个 except 子句所处理，则该异常会在 <code>finally 子句</code> 执行之后被重新引发。</li><li>异常也可能在 except 或 else 子句执行期间发生。 同样地，该异常会在 <code>finally 子句</code> 执行之后被重新引发。</li><li>如果在执行 try 语句时遇到一个 break, continue 或 return 语句，则 <code>finally 子句</code> 将在执行 break, continue 或 return 语句之前被执行。</li><li>如果 <code>finally 子句</code> 中包含一个 return 语句，则返回值将来自 <code>finally 子句</code> 的某个 return 语句的返回值，而非来自 try 子句的 return 语句的返回值。</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>这一章节官方文档讲的有些晦涩，特别是“Python 作用域和命名空间”这一节，后来发现菜鸟教程对于这一部分的讲解还挺通俗易懂的，下面贴出相应网址：</p><ul><li><a href="https://www.runoob.com/python3/python3-class.html" target="_blank" rel="noopener">Python3 面向对象</a></li><li><a href="https://www.runoob.com/python3/python3-namespace-scope.html" target="_blank" rel="noopener">Python3 命名空间和作用域</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想要复习一下Python一些基本的知识点，网上有着许许多多的Python学习教程，眼花缭乱，但是其实Python是有 &lt;a href=&quot;https://docs.python.org/zh-cn/3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方中文文档&lt;/a&gt; 的，并且写的非常不错！所以对照着文档中的入门教程进行了学习，同时记录了一些值得注意的地方。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://www.yingzq.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.yingzq.com/tags/Python/"/>
    
      <category term="阅读笔记" scheme="http://www.yingzq.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Transformer代码实现</title>
    <link href="http://www.yingzq.com/2019/11/18/the-annotated-transformer/"/>
    <id>http://www.yingzq.com/2019/11/18/the-annotated-transformer/</id>
    <published>2019-11-18T07:22:27.000Z</published>
    <updated>2020-02-19T17:43:10.648Z</updated>
    
    <content type="html"><![CDATA[<p>Transformer是如今几乎所有的预训练模型的基本结构。也许我们平时更多的是关注如何更好的利用已经训练好的GPT、BERT等模型进行fine-tune，但是同样重要的是，我们需要了解这些强力的模型具体是如何构建的。所以本文我们主要研究如何在PyTorch框架下用代码实现 <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">“Attention is All You Need”</a> 论文中原始Transformer的结构。</p><a id="more"></a><blockquote><p>本文内容参考了 <a href="http://nlp.seas.harvard.edu/2018/04/03/attention.html" target="_blank" rel="noopener">The Annotated Transformer</a> ，对应的代码则针对<code>PyTorch 1.3</code>环境做了一定更新，完整代码可见 <a href="https://github.com/YingZiqiang/hexo-blog-code/tree/master/the-annotated-transformer" target="_blank" rel="noopener">Transformer Code</a> 。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本文的测试环境是<code>Python 3.6+</code>和<code>PyTorch 1.3</code>，如果版本不对可能代码需要略微的调整。</p><p>在这里先导入所有需要用到的库，方便检测是否有缺失：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> math, copy, time</span><br></pre></td></tr></table></figure><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>当谈及序列模型(sequence modeling)，我们首先想到的就是RNN及其变种，但是RNN模型的缺点也非常明显：<strong>需要顺序计算，从而很难并行</strong>。因此出现了Extended Neural GPU、ByteNet和ConvS2S等网络模型。这些模型都是以CNN为基础，这比较容易并行，但是和RNN相比，它较难学习到长距离的依赖关系。</p><p>本文的Transformer使用了Self-Attention机制，它在编码每一词的时候都能够注意(attend to)整个句子，从而可以解决长距离依赖的问题，同时计算Self-Attention可以用矩阵乘法一次计算所有的时刻，因此可以充分利用计算资源。</p><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p>目前的主流神经序列转换(neural sequence transduction)模型都是基于Encoder-Decoder结构的。所谓的序列转换模型就是把一个输入序列转换成另外一个输出序列，它们的长度很可能是不同的。比如基于神经网络的机器翻译，输入是法语句子，输出是英语句子，这就是一个序列转换模型。类似的包括文本摘要、对话等问题都可以看成序列转换问题。我们这里主要关注机器翻译，但是任何输入是一个序列输出是另外一个序列的问题都可以考虑使用Encoder-Decoder结构。</p><p>Encoder将输入序列$(x_1,\ldots,x_n)$编码成一个连续的序列$\boldsymbol{z}=(z_1,\ldots,z_n)$。而Decoder根据$\boldsymbol{z}$来解码得到输出序列$(y_1,\ldots,y_m)$。Decoder是自回归的(auto-regressive)，它会把前一个时刻的输出作为当前时刻的输入。Encoder-Decoder结构对应的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderDecoder</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A standard Encoder-Decoder architecture. Base for this and many other models.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, encoder, decoder, src_embed, tgt_embed, generator)</span>:</span></span><br><span class="line">        super(EncoderDecoder, self).__init__()</span><br><span class="line">        self.encoder = encoder</span><br><span class="line">        self.decoder = decoder</span><br><span class="line">        self.src_embed = src_embed</span><br><span class="line">        self.tgt_embed = tgt_embed</span><br><span class="line">        self.generator = generator</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, src, tgt, src_mask, tgt_mask)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Take in and process masked src and target sequences.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.decode(self.encode(src, src_mask), src_mask, tgt, tgt_mask)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self, src, src_mask)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.encoder(self.src_embed(src), src_mask)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(self, memory, src_mask, tgt, tgt_mask)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.decoder(self.tgt_embed(tgt), memory, src_mask, tgt_mask)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Define standard linear + softmax generation step.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d_model, vocab)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()</span><br><span class="line">        self.proj = nn.Linear(d_model, vocab)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(self.proj(x), dim=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>EncoderDecoder定义了一种通用的Encoder-Decoder架构，具体的encoder、decoder、src_embed、target_embed和generator都是构造函数传入的参数。这样我们做实验更换不同的组件就会更加方便。</p><p>解释一下各种参数的意义：encoder、encoder分别代表编码器和解码器；src_embed、tgt_embed分别代表将源语言、目标语言的ID序列编码为词向量(embedding)的方法；generator则是根据解码器当前时刻的隐状态输出当前时刻的词，上面已给出具体的实现方法(即Generator类)。</p><p>Transformer模型也遵循着Encoder-Decoder的架构。它的Encoder是由$N=6$个相同的EncoderLayer组成，每个EncoderLayer包含一个Self-Attention Sublayer层和一个Feed-Forward Sublayer层；而它的Decoder也是由$N=6$个相同的DecoderLayer组成，每个DecoderLayer包含一个Self-Attention Sublayer层、一个Encoder-Decoder-Attention Sublayer层和一个Feed-Forward Sublayer层。</p><blockquote><p>注：Feed-Forward层其实就是全连接层的意思。</p></blockquote><p>下图清晰的展示了Transformer整体架构：</p><div align=center><img src="http://image.yingzq.com/img/20191106202340.png" width="500" alt="Transformer整体架构" /><p>图：Transformer整体架构</p></div><h3 id="Encoder-and-Decoder-Stacks"><a href="#Encoder-and-Decoder-Stacks" class="headerlink" title="Encoder and Decoder Stacks"></a>Encoder and Decoder Stacks</h3><h4 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h4><p>前面提到Encoder是由$N=6$个相同结构的EncoderLayer堆叠而成，所以我们定义Encoder的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clones</span><span class="params">(module, N)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Produce N identical layers.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> nn.ModuleList([copy.deepcopy(module) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoder</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Core encoder is a stack of N layers.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, layer, N)</span>:</span></span><br><span class="line">        super(Encoder, self).__init__()</span><br><span class="line">        self.layers = clones(layer, N)</span><br><span class="line">        self.norm = LayerNorm(layer.size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, mask)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Pass the input (and mask) through each layer in turn.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            x = layer(x, mask)</span><br><span class="line">        <span class="keyword">return</span> self.norm(x)</span><br></pre></td></tr></table></figure><p>也就是Encoder会把传入的layer深拷贝N次，然后让传入的Tensor依次通过这N个layer，最后再通过一层 <a href="https://arxiv.org/abs/1607.06450" target="_blank" rel="noopener">Layer Normalization</a>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayerNorm</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Construct a layernorm module, see https://arxiv.org/abs/1607.06450 for details.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, features, eps=<span class="number">1e-6</span>)</span>:</span></span><br><span class="line">        super(LayerNorm, self).__init__()</span><br><span class="line">        self.a_2 = nn.Parameter(torch.ones(features))</span><br><span class="line">        self.b_2 = nn.Parameter(torch.zeros(features))</span><br><span class="line">        self.eps = eps</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        mean = x.mean(<span class="number">-1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        std = x.std(<span class="number">-1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> self.a_2 * (x - mean) / (std + self.eps) + self.b_2</span><br></pre></td></tr></table></figure><p>按照原论文，每一个EncoderLayer的每一个子层(sub-layer)的输出应该是$LayerNorm(x+Sublayer(x))$，其中的Sublayer(x)是对子层结构实现的抽象函数。这里稍微做了一些修改，首先在每一个子层的输出之后加了一个 <a href="http://jmlr.org/papers/v15/srivastava14a.html" target="_blank" rel="noopener">Dropout层</a> ，另外一个不同就是把LayerNorm层放到前面了。也就是现在每一个子层实际的输出是：</p><p>$$x+Dropout(Sublayer(LayerNorm(x)))$$</p><blockquote><p>注：原论文的LayerNorm放在最后，这里把它放在前面并且在Encoder的最后一层再加上了一个LayerNorm。这里的实现和论文的实现基本是一致的，只是给最底层的输入x多做了一个LayerNorm。</p></blockquote><p>为了加快残差连接的速度，模型中所有的子层(sub-layer)，包括Embedding层，将它们的输出维度均设置为$d_{model}=512$。所以我们有如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SublayerConnection</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A residual connection followed by a layer norm.</span></span><br><span class="line"><span class="string">    Note for code simplicity the norm is first as opposed to last.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, dropout)</span>:</span></span><br><span class="line">        super(SublayerConnection, self).__init__()</span><br><span class="line">        self.norm = LayerNorm(size)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, sublayer)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Apply residual connection to any sublayer with the same size.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> x + self.dropout(sublayer(self.norm(x)))</span><br></pre></td></tr></table></figure><p>上面提到EncoderLayer是由Self-Attention、Feed-Forward这两个子层构成，所以有：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderLayer</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Encoder is made up of self-attn and feed forward.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, self_attn, feed_forward, dropout)</span>:</span></span><br><span class="line">        super(EncoderLayer, self).__init__()</span><br><span class="line">        self.self_attn = self_attn</span><br><span class="line">        self.feed_forward = feed_forward</span><br><span class="line">        self.sublayer = clones(SublayerConnection(size, dropout), <span class="number">2</span>)</span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, mask)</span>:</span></span><br><span class="line">        x = self.sublayer[<span class="number">0</span>](x, <span class="keyword">lambda</span> x: self.self_attn(x, x, x, mask))</span><br><span class="line">        <span class="keyword">return</span> self.sublayer[<span class="number">1</span>](x, self.feed_forward)</span><br></pre></td></tr></table></figure><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p>Decoder也是由$N=6$个相同结构的DecoderLayer堆叠而成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoder</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Generic N layer decoder with masking.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, layer, N)</span>:</span></span><br><span class="line">        super(Decoder, self).__init__()</span><br><span class="line">        self.layers = clones(layer, N)</span><br><span class="line">        self.norm = LayerNorm(layer.size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, memory, src_mask, tgt_mask)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:</span><br><span class="line">            x = layer(x, memory, src_mask, tgt_mask)</span><br><span class="line">        <span class="keyword">return</span> self.norm(x)</span><br></pre></td></tr></table></figure><p>前面讲到，一个DecoderLayer除了有和EncoderLayer一样的两个子层，还多了一个Encoder-Decoder-Attention子层，这个子层会让模型在解码时会考虑最后一层Encoder所有时刻的输出。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoderLayer</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Decoder is made of self-attn, src-attn, and feed forward.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, self_attn, src_attn, feed_forward, dropout)</span>:</span></span><br><span class="line">        super(DecoderLayer, self).__init__()</span><br><span class="line">        self.size = size</span><br><span class="line">        self.self_attn = self_attn</span><br><span class="line">        self.src_attn = src_attn</span><br><span class="line">        self.feed_forward = feed_forward</span><br><span class="line">        self.sublayer = clones(SublayerConnection(size, dropout), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, memory, src_mask, tgt_mask)</span>:</span></span><br><span class="line">        m = memory</span><br><span class="line">        x = self.sublayer[<span class="number">0</span>](x, <span class="keyword">lambda</span> x: self.self_attn(x, x, x, tgt_mask))</span><br><span class="line">        x = self.sublayer[<span class="number">1</span>](x, <span class="keyword">lambda</span> x: self.src_attn(x, m, m, src_mask))</span><br><span class="line">        <span class="keyword">return</span> self.sublayer[<span class="number">2</span>](x, self.feed_forward)</span><br></pre></td></tr></table></figure><blockquote><p>注：多出来的这一层Attention子层(代码中是src_attn)实现和Self-Attention是一样的，只不过src_attn的Query来自于前层Decoder的输出，但是Key和Value来自于Encoder最后一层的输出(代码中是memory)；而Self-Attention的Q、K、V则均来自前层的输出。</p></blockquote><p>Decoder和Encoder还有一个关键的不同：Decoder在解码第t个时刻的时候只能使用小于t时刻的输入，而不能使用t+1时刻及其之后的输入。因此我们需要一个函数来产生一个Mask矩阵：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsequent_mask</span><span class="params">(size)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Mask out subsequent positions.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    attn_shape = (<span class="number">1</span>, size, size)</span><br><span class="line">    subsequent_mask = np.triu(np.ones(attn_shape), k=<span class="number">1</span>).astype(<span class="string">'uint8'</span>)</span><br><span class="line">    <span class="keyword">return</span> torch.from_numpy(subsequent_mask) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上面代码的意思是先用triu函数产生一个上三角矩阵，再利用matrix == 0得到所需要的下三角矩阵。</p><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><h4 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h4><p>Attention(包括Self-Attention和普通的Attention)可以看成一个函数，它的输入是Query,Key和Value，输出是一个Tensor。其中输出是Value的加权平均，而权重则来自Query和Key的计算。</p><p>论文中首先提到了Scaled Dot-Product Attention，如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191107111357.png" width="300" alt="Scaled Dot-Product Attention" /><p>图：Scaled Dot-Product Attention</p></div><blockquote><p>Scaled Dot-Product Attention需要保证Query和Key的维度是相同的，记为$d_k$，Value的维度记为$d_v$。</p></blockquote><p>具体计算是先将一组query和所有的keys作点乘运算，然后除以$\sqrt{d_k}$保证后续梯度的稳定性，然后将这些分数进行softmax归一化，作为query和Keys的相似程度，也就是values加权平均的权重，最后将所有values作加权平均作为输出。这里用矩阵直接表示：</p><p>$$Attention(Q,K,V)=softmax(\frac{Q K^T}{\sqrt{d_k}})V$$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attention</span><span class="params">(query, key, value, mask=None, dropout=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Compute 'Scaled Dot Product Attention'</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    d_k = query.size(<span class="number">-1</span>)</span><br><span class="line">    scores = torch.matmul(query, key.transpose(<span class="number">-2</span>, <span class="number">-1</span>)) / math.sqrt(d_k)</span><br><span class="line">    <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        scores = scores.masked_fill(mask == <span class="number">0</span>, <span class="number">-1e9</span>)</span><br><span class="line">    p_attn = F.softmax(scores, dim=<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> dropout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        p_attn = dropout(p_attn)</span><br><span class="line">    <span class="keyword">return</span> torch.matmul(p_attn, value), p_attn</span><br></pre></td></tr></table></figure><p>论文中非常重要的Multi-Head Attention便是基于Scaled Dot-Product Attention。其实很简单，前面定义的一组Q、K和V可以让一个词attend to相关的词，我们可以定义多组Q、K和V，它们分别可以关注不同的上下文：</p><div align=center><img src="http://image.yingzq.com/img/20191107113854.png" width="300" alt="Multi-Head Attention" /><p>图：Multi-Head Attention</p></div><p>由上图我们可以得到如下计算公式：</p><p>$$MultiHead(Q,K,V)=Concat(head_1,\ldots,head_h)W^O \\<br>where \  head_i=Attention(QW_i^Q,KW_i^K,VW_i^V)$$</p><p>论文中使用了$h=8$个Head，所以此时$d_k=d_v=d_{model}/h=64$。虽然此时Head数扩大了$h=8$由于每一个Head的维度缩小了$h=8$倍，所以总体的计算成本是基本不变的。</p><p>根据上述分析，我们可以写出Multi-Head Attention的代码了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiHeadedAttention</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Implements 'Multi-Head Attention' proposed in the paper.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, h, d_model, dropout=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Take in model size and number of heads.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        super(MultiHeadedAttention, self).__init__()</span><br><span class="line">        <span class="keyword">assert</span> d_model % h == <span class="number">0</span></span><br><span class="line">        <span class="comment"># We assume d_v always equals d_k</span></span><br><span class="line">        self.d_k = d_model // h</span><br><span class="line">        self.h = h</span><br><span class="line">        self.linears = clones(nn.Linear(d_model, d_model), <span class="number">4</span>)</span><br><span class="line">        self.attn = <span class="literal">None</span></span><br><span class="line">        self.dropout = nn.Dropout(p=dropout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, query, key, value, mask=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Same mask applied to all h heads.</span></span><br><span class="line">            mask = mask.unsqueeze(<span class="number">1</span>)</span><br><span class="line">        nbatches = query.size(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1) Do all the linear projections in batch from d_model =&gt; h x d_k</span></span><br><span class="line">        query, key, value = [l(x).view(nbatches, <span class="number">-1</span>, self.h, self.d_k).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">                             <span class="keyword">for</span> l, x <span class="keyword">in</span> zip(self.linears, (query, key, value))]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2) Apply attention on all the projected vectors in batch.</span></span><br><span class="line">        x, self.attn = attention(query, key, value, mask=mask, dropout=self.dropout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3) "Concat" using a view and apply a final linear.</span></span><br><span class="line">        x = x.transpose(<span class="number">1</span>, <span class="number">2</span>).contiguous().view(nbatches, <span class="number">-1</span>, self.h * self.d_k)</span><br><span class="line">        <span class="keyword">return</span> self.linears[<span class="number">-1</span>](x)</span><br></pre></td></tr></table></figure><h4 id="Attention在模型中的应用"><a href="#Attention在模型中的应用" class="headerlink" title="Attention在模型中的应用"></a>Attention在模型中的应用</h4><p>在Transformer里，有3个地方用到了Multi-Head Attention：</p><p>1) Decoder的Encoder-Decoder-Attention层。其中query来自于前一层Decoder的输出，而key和value则来自于是Encoder最后一层的输出，<strong>这个Attention层使得Decoder在解码时会考虑最后一层Encoder所有时刻的输出</strong>，是一种在Encoder-Decoder架构中常用的注意力机制。<br>2) Encoder的Self-Attention层。query，key和value均来自于相同的地方，也就是前层Encoder的输出。<br>3) Decoder的Self-Attention层。query，key和value均来自于相同的地方，也就是前层Decoder的输出，但是Mask使得它不能访问未来时刻的输出。</p><h3 id="Feed-Forward"><a href="#Feed-Forward" class="headerlink" title="Feed-Forward"></a>Feed-Forward</h3><p>除了Attention子层，Encoder和Decoder的每一层还包括一个Feed-Forward子层，也就是全连接层。每个时刻的全连接层是可以独立并行计算的(当然参数是共享的)。全连接层由两个线性变换以及它们之间的ReLU激活组成：</p><p>$$FFN(x)=max(0,xW_1+b_1)W_2+b_2$$</p><p>全连接层的输入和输出都是$d_{model}=512$维的，中间隐单元的个数是$d_{ff}=2048$。代码实现非常简单：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositionwiseFeedForward</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Implements FFN equation.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d_model, d_ff, dropout=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        super(PositionwiseFeedForward, self).__init__()</span><br><span class="line">        self.w_1 = nn.Linear(d_model, d_ff)</span><br><span class="line">        self.w_2 = nn.Linear(d_ff, d_model)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.w_2(self.dropout(F.relu(self.w_1(x))))</span><br></pre></td></tr></table></figure><h3 id="Embeddings"><a href="#Embeddings" class="headerlink" title="Embeddings"></a>Embeddings</h3><p>和大部分NLP任务一样，输入的词序列都是ID序列，所以需要有个Embeddings层。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Embeddings</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d_model, vocab)</span>:</span></span><br><span class="line">        super(Embeddings, self).__init__()</span><br><span class="line">        <span class="comment"># lut =&gt; lookup table</span></span><br><span class="line">        self.lut = nn.Embedding(vocab, d_model)</span><br><span class="line">        self.d_model = d_model</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.lut(x) * math.sqrt(self.d_model)</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，在Embeddings层，所有的权重都扩大了$\sqrt{d_{model}}$倍。</p></blockquote><h3 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h3><p>其实Transformer是没有考虑词的顺序(位置)关系的。为了解决这个问题引入位置编码(Positional Encoding)，论文中使用的公式如下：</p><p>$$PE_{(pos,2i)}=sin(pos/10000^{2i/d_{model}}) \\<br>PE_{(pos,2i+1)}=cos(pos/10000^{2i/d_{model}})$$</p><p>其中pos代表位置而i代表维度。例如输入的ID序列长度为10，那么经过Embeddings层后Tensor的尺寸就是(10,512)，此时上式中的pos的范围就是0~9；对于不同维度，这里范围是0~511，偶数维使用sin函数，而奇数维使用cos函数。</p><p><strong>这种位置编码的好处是：$PE_{pos+k}$可以表示成$PE_{pos}$的线性函数，这样网络就能容易的学到相对位置的关系。</strong> 我们来简单验证下，这里$10000^{2i/d_{model}}$是一个常数，我们记为$W_{i}$。</p><p>$$PE_{(pos+k,2i)}=sin(\frac{pos+k}{W_{i}})=sin(\frac{pos}{W_{i}})cos(\frac{k}{W_{i}})+cos(\frac{pos}{W_{i}})sin(\frac{k}{W_{i}}) \\<br>=PE_{(pos,2i)}cos(\frac{k}{W_{i}})+PE_{(pos,2i+1)}sin(\frac{k}{W_{i}})$$</p><p>$$PE_{(pos+k,2i+1)}=cos(\frac{pos+k}{W_{i}})=cos(\frac{pos}{W_{i}})cos(\frac{k}{W_{i}})-sin(\frac{pos}{W_{i}})sin(\frac{k}{W_{i}}) \\<br>=PE_{(pos,2i+1)}cos(\frac{k}{W_{i}})-PE_{(pos,2i)}sin(\frac{k}{W_{i}})$$</p><p>可以看到$PE_{pos+k}$的确是$PE_{pos}$的线性函数。</p><p>位置编码的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositionalEncoding</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Implement the PE function.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d_model, dropout, max_len=<span class="number">5000</span>)</span>:</span></span><br><span class="line">        super(PositionalEncoding, self).__init__()</span><br><span class="line">        self.dropout = nn.Dropout(p=dropout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compute the positional encodings once in log space.</span></span><br><span class="line">        pe = torch.zeros(max_len, d_model)</span><br><span class="line">        position = torch.arange(<span class="number">0</span>, max_len).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        div_term = torch.exp(torch.arange(<span class="number">0</span>, d_model, <span class="number">2</span>) * -(math.log(<span class="number">10000.0</span>) / d_model))</span><br><span class="line">        pe[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(position * div_term)</span><br><span class="line">        pe[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(position * div_term)</span><br><span class="line">        pe = pe.unsqueeze(<span class="number">0</span>)</span><br><span class="line">        self.register_buffer(<span class="string">'pe'</span>, pe)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = x + self.pe[:, :x.size(<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> self.dropout(x)</span><br></pre></td></tr></table></figure><h3 id="完整模型"><a href="#完整模型" class="headerlink" title="完整模型"></a>完整模型</h3><p>这里我们定义一个函数，输入是超参，输出是根据超参构建的模型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_model</span><span class="params">(src_vocab, tgt_vocab, N=<span class="number">6</span>, d_model=<span class="number">512</span>, d_ff=<span class="number">2048</span>, h=<span class="number">8</span>, dropout=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Helper: Construct a model from hyperparameters.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    c = copy.deepcopy</span><br><span class="line">    attn = MultiHeadedAttention(h, d_model)</span><br><span class="line">    ff = PositionwiseFeedForward(d_model, d_ff, dropout)</span><br><span class="line">    position = PositionalEncoding(d_model, dropout)</span><br><span class="line">    model = EncoderDecoder(</span><br><span class="line">        Encoder(EncoderLayer(d_model, c(attn), c(ff), dropout), N),</span><br><span class="line">        Decoder(DecoderLayer(d_model, c(attn), c(attn), c(ff), dropout), N),</span><br><span class="line">        nn.Sequential(Embeddings(d_model, src_vocab), c(position)),</span><br><span class="line">        nn.Sequential(Embeddings(d_model, tgt_vocab), c(position)),</span><br><span class="line">        Generator(d_model, tgt_vocab))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This was important from their code.</span></span><br><span class="line">    <span class="comment"># Initialize parameters with Glorot / fan_avg.</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters():</span><br><span class="line">        <span class="keyword">if</span> p.dim() &gt; <span class="number">1</span>:</span><br><span class="line">            nn.init.xavier_uniform_(p)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>首先我们需要一个Batch类，用于提供批次数据，并且构造所需要的掩码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Batch</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Object for holding a batch of data with mask during training.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, src, trg=None, pad=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.src = src</span><br><span class="line">        self.src_mask = (src != pad).unsqueeze(<span class="number">-2</span>)</span><br><span class="line">        <span class="keyword">if</span> trg <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.trg = trg[:, :<span class="number">-1</span>]</span><br><span class="line">            self.trg_y = trg[:, <span class="number">1</span>:]</span><br><span class="line">            self.trg_mask = self.make_std_mask(self.trg, pad)</span><br><span class="line">            self.ntokens = (self.trg_y != pad).sum().item()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_std_mask</span><span class="params">(tgt, pad)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Create a mask to hide padding and future words.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tgt_mask = (tgt != pad).unsqueeze(<span class="number">-2</span>)</span><br><span class="line">        tgt_mask = tgt_mask &amp; subsequent_mask(tgt.size(<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> tgt_mask</span><br></pre></td></tr></table></figure><p>值得注意的是解码阶段的Mask(代码中是trg_mask)需要将未来时刻的输出掩盖掉，这在前面已经实现了相应的函数(即subsequent_mask函数)。</p><p>接下来再写出运行一个epoch的训练代码，非常的简单：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_epoch</span><span class="params">(data_iter, model, loss_compute)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Standard Training and Logging Function</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    total_tokens = <span class="number">0</span></span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    tokens = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, batch <span class="keyword">in</span> enumerate(data_iter):</span><br><span class="line">        out = model.forward(batch.src, batch.trg, batch.src_mask, batch.trg_mask)</span><br><span class="line">        loss = loss_compute(out, batch.trg_y, batch.ntokens)</span><br><span class="line">        total_loss += loss</span><br><span class="line">        total_tokens += batch.ntokens</span><br><span class="line">        tokens += batch.ntokens</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">1</span>:</span><br><span class="line">            elapsed = time.time() - start</span><br><span class="line">            print(<span class="string">"Epoch Step: %d Loss: %f Tokens per Sec: %f"</span> % (i, loss / batch.ntokens, tokens / elapsed))</span><br><span class="line">            start = time.time()</span><br><span class="line">            tokens = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> total_loss / total_tokens</span><br></pre></td></tr></table></figure><p>对于优化器(optimizer)，论文选用了常见的 <a href="https://arxiv.org/abs/1412.6980" target="_blank" rel="noopener">Adam optimizer</a> ，相应的优化器参数是$\beta_1=0.9,\beta_2=0.98,\epsilon=10^{-9}$。特别的，对于比较重要的学习率参数，是随着训练的进行动态变化的，具体公式如下：</p><p>$$lrate=d_{model}^{-0.5} \cdot min(step\_num^{−0.5},step\_num \cdot warmup\_steps^{−1.5})$$</p><p>也就是在最开始的$warmup\_steps$步，学习率线性增加；然后再慢慢的非线性降低。论文中$warmup\_steps=4000$。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoamOpt</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Optim wrapper that implements rate.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model_size, factor, warmup, optimizer)</span>:</span></span><br><span class="line">        self.optimizer = optimizer</span><br><span class="line">        self._step = <span class="number">0</span></span><br><span class="line">        self.warmup = warmup</span><br><span class="line">        self.factor = factor</span><br><span class="line">        self.model_size = model_size</span><br><span class="line">        self._rate = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Update parameters and rate.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._step += <span class="number">1</span></span><br><span class="line">        rate = self.rate()</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> self.optimizer.param_groups:</span><br><span class="line">            p[<span class="string">'lr'</span>] = rate</span><br><span class="line">        self._rate = rate</span><br><span class="line">        self.optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rate</span><span class="params">(self, step=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> step <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            step = self._step</span><br><span class="line">        <span class="keyword">return</span> self.factor * (self.model_size ** (<span class="number">-0.5</span>) * min(step ** (<span class="number">-0.5</span>), step * self.warmup ** (<span class="number">-1.5</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_std_opt</span><span class="params">(model)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> NoamOpt(model.src_embed[<span class="number">0</span>].d_model, <span class="number">2</span>, <span class="number">4000</span>,</span><br><span class="line">                   torch.optim.Adam(model.parameters(), lr=<span class="number">0</span>, betas=(<span class="number">0.9</span>, <span class="number">0.98</span>), eps=<span class="number">1e-9</span>))</span><br></pre></td></tr></table></figure><p>论文中使用到了3种Regularization，一种是Dropout，一种是残差连接，这两种前面已经做出讲解。最后一种是Label Smoothing，虽然Label Smoothing增加了模型训练的困惑度，但是的确使得最终的指标上升了，具体实现如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LabelSmoothing</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Implement label smoothing.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, padding_idx, smoothing=<span class="number">0.0</span>)</span>:</span></span><br><span class="line">        super(LabelSmoothing, self).__init__()</span><br><span class="line">        self.criterion = nn.KLDivLoss(reduction=<span class="string">'sum'</span>)</span><br><span class="line">        self.padding_idx = padding_idx</span><br><span class="line">        self.confidence = <span class="number">1.0</span> - smoothing</span><br><span class="line">        self.smoothing = smoothing</span><br><span class="line">        self.size = size</span><br><span class="line">        self.true_dist = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x, target)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> x.size(<span class="number">1</span>) == self.size</span><br><span class="line">        true_dist = x.clone()</span><br><span class="line">        true_dist.fill_(self.smoothing / (self.size - <span class="number">2</span>))</span><br><span class="line">        true_dist.scatter_(<span class="number">1</span>, target.unsqueeze(<span class="number">1</span>), self.confidence)</span><br><span class="line">        true_dist[:, self.padding_idx] = <span class="number">0</span></span><br><span class="line">        mask = torch.nonzero(target == self.padding_idx)</span><br><span class="line">        <span class="keyword">if</span> mask.size(<span class="number">0</span>) &gt; <span class="number">0</span>:</span><br><span class="line">            true_dist.index_fill_(<span class="number">0</span>, mask.squeeze(), <span class="number">0.0</span>)</span><br><span class="line">        self.true_dist = true_dist</span><br><span class="line">        <span class="keyword">return</span> self.criterion(x, true_dist)</span><br></pre></td></tr></table></figure><h2 id="A-First-Example"><a href="#A-First-Example" class="headerlink" title="A First Example"></a>A First Example</h2><p>论文中要完成的是一个机器翻译任务，但是那可能有点麻烦，所以我们就来完成一个简单的<code>复制任务</code>来检验我们的模型，也就是给定来自一个小型词汇表的token序列，我们的目标是通过Encoder-Decoder结构生成相同的token序列，例如输入是<code>[1,2,3,4,5]</code>，那么生成的序列也应该是<code>[1,2,3,4,5]</code>。</p><p>任务数据生成代码如下，让src=trg即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_gen</span><span class="params">(V, batch, nbatches)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Generate random data for a src-tgt copy task.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nbatches):</span><br><span class="line">        data = torch.from_numpy(np.random.randint(<span class="number">1</span>, V, size=(batch, <span class="number">10</span>)))</span><br><span class="line">        data[:, <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> Batch(src=data, trg=data, pad=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>然后是一个计算loss的方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleLossCompute</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A simple loss compute and train function.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, generator, criterion, opt=None)</span>:</span></span><br><span class="line">        self.generator = generator</span><br><span class="line">        self.criterion = criterion</span><br><span class="line">        self.opt = opt</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x, y, norm)</span>:</span></span><br><span class="line">        x = self.generator(x)</span><br><span class="line">        loss = self.criterion(x.contiguous().view(<span class="number">-1</span>, x.size(<span class="number">-1</span>)), y.contiguous().view(<span class="number">-1</span>)) / norm</span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="keyword">if</span> self.opt <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.opt.step()</span><br><span class="line">            self.opt.optimizer.zero_grad()</span><br><span class="line">        <span class="keyword">return</span> loss.item() * norm</span><br></pre></td></tr></table></figure><p>在预测阶段是一个自回归模型，为了简单我们直接使用Greedy Search(一般情况下是使用Beam Search)，也就是每一个时刻都取概率最大的词作为输出。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greedy_decode</span><span class="params">(model, src, src_mask, max_len, start_symbol)</span>:</span></span><br><span class="line">    memory = model.encode(src, src_mask)</span><br><span class="line">    ys = torch.ones(<span class="number">1</span>, <span class="number">1</span>, dtype=torch.long).fill_(start_symbol)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_len - <span class="number">1</span>):</span><br><span class="line">        out = model.decode(memory, src_mask, ys, subsequent_mask(ys.size(<span class="number">1</span>)))</span><br><span class="line">        prob = model.generator(out[:, <span class="number">-1</span>])</span><br><span class="line">        _, next_word = torch.max(prob, dim=<span class="number">1</span>)</span><br><span class="line">        next_word = next_word.item()</span><br><span class="line">        ys = torch.cat([ys, torch.ones(<span class="number">1</span>, <span class="number">1</span>, dtype=torch.long).fill_(next_word)], dim=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ys</span><br></pre></td></tr></table></figure><p>最后，将这个例子运行起来，我们便可以看到，几分钟的时间内Transformer已经能够完美的完成这个<code>复制任务</code>！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Train the simple copy task.</span></span><br><span class="line">V = <span class="number">11</span></span><br><span class="line">criterion = LabelSmoothing(size=V, padding_idx=<span class="number">0</span>, smoothing=<span class="number">0.0</span>)</span><br><span class="line">model = make_model(V, V, N=<span class="number">2</span>)</span><br><span class="line">model_opt = NoamOpt(model.src_embed[<span class="number">0</span>].d_model, <span class="number">1</span>, <span class="number">400</span>,</span><br><span class="line">                    torch.optim.Adam(model.parameters(), lr=<span class="number">0</span>, betas=(<span class="number">0.9</span>, <span class="number">0.98</span>), eps=<span class="number">1e-9</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">15</span>):</span><br><span class="line">    model.train()</span><br><span class="line">    run_epoch(data_gen(V, <span class="number">30</span>, <span class="number">20</span>), model, SimpleLossCompute(model.generator, criterion, model_opt))</span><br><span class="line">    model.eval()</span><br><span class="line">    print(run_epoch(data_gen(V, <span class="number">30</span>, <span class="number">5</span>), model, SimpleLossCompute(model.generator, criterion, <span class="literal">None</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This code predicts a translation using greedy decoding for simplicity.</span></span><br><span class="line">print()</span><br><span class="line">print(<span class="string">"&#123;&#125;predict&#123;&#125;"</span>.format(<span class="string">'*'</span> * <span class="number">10</span>, <span class="string">'*'</span> * <span class="number">10</span>))</span><br><span class="line">model.eval()</span><br><span class="line">src = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]])</span><br><span class="line">src_mask = torch.ones(<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">print(greedy_decode(model, src, src_mask, max_len=<span class="number">10</span>, start_symbol=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文相对于 <a href="http://nlp.seas.harvard.edu/2018/04/03/attention.html" target="_blank" rel="noopener">原博客</a> 有所扩充也有所删减。扩充主要在对代码的讲解部分；删减则主要是并没有完全复现机器翻译的任务，但是其实机器翻译的任务与上节中的<code>复制任务</code>是非常类似的，所以也没有继续在这上面花费精力，若对机器翻译非常感兴趣的童鞋倒是可以阅读 <a href="http://nlp.seas.harvard.edu/2018/04/03/attention.html" target="_blank" rel="noopener">原博客</a> 了解更多。</p><p>总体来说我们完完全全复现了 <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">“Attention is All You Need”</a> 中的结构，论文的思想真的的非常棒的！代码也在<code>PyTroch 1.3</code>的环境中测试通过，许多组件具有很好复用性，完整代码可见 <a href="https://github.com/YingZiqiang/hexo-blog-code/tree/master/the-annotated-transformer" target="_blank" rel="noopener">Transformer Code</a> ，可以方便以后对铺天盖地的基于Transformer的预训练模型的学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Transformer是如今几乎所有的预训练模型的基本结构。也许我们平时更多的是关注如何更好的利用已经训练好的GPT、BERT等模型进行fine-tune，但是同样重要的是，我们需要了解这些强力的模型具体是如何构建的。所以本文我们主要研究如何在PyTorch框架下用代码实现 &lt;a href=&quot;https://arxiv.org/abs/1706.03762&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“Attention is All You Need”&lt;/a&gt; 论文中原始Transformer的结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NLP" scheme="http://www.yingzq.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://www.yingzq.com/tags/NLP/"/>
    
      <category term="Deep Learning" scheme="http://www.yingzq.com/tags/Deep-Learning/"/>
    
      <category term="Transformer" scheme="http://www.yingzq.com/tags/Transformer/"/>
    
      <category term="BERT" scheme="http://www.yingzq.com/tags/BERT/"/>
    
      <category term="PyTorch" scheme="http://www.yingzq.com/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>Transformer图解</title>
    <link href="http://www.yingzq.com/2019/10/30/the-illustrated-transformer/"/>
    <id>http://www.yingzq.com/2019/10/30/the-illustrated-transformer/</id>
    <published>2019-10-29T16:23:45.000Z</published>
    <updated>2020-03-03T05:27:13.700Z</updated>
    
    <content type="html"><![CDATA[<p>Transformer模型来自论文 <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention Is All You Need</a> 。这个模型最初是为了提高机器翻译的效率，它的Self-Attention机制和Position Encoding可以替代RNN。因为RNN是顺序执行的，t时刻没有完成就不能处理t+1时刻，因此很难并行。但是后来发现Self-Attention效果很好，在很多其它的地方也可以使用Transformer模型。这包括著名的GPT和BERT模型，都是以Transformer为基础的。</p><p>本文我们将通过图解的方式来直观的理解Transformer模型的基本原理，内容主要参考了文章 <a href="http://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">The Illustrated Transformer</a> 。</p><a id="more"></a><h2 id="模型概述"><a href="#模型概述" class="headerlink" title="模型概述"></a>模型概述</h2><p>我们首先把模型看成一个黑盒子，如下图所示，对于机器翻译来说，它的输入是源语言(法语)的句子，输出是目标语言(英语)的句子。</p><div align=center><img src="http://image.yingzq.com/img/20191103151039.png" width="700" alt="Transformer的输入和输出" /><p>图：Transformer的输入和输出</p></div><p>把黑盒子稍微打开一点，我们可以看到Transformer(或者任何的NMT系统)由2个部分组成：Encoders和Decoders，如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191103151740.png" width="600" alt="典型的Encoder-Decoder结构" /><p>图：典型的Encoder-Decoder结构</p></div><blockquote><p>注：这里Encoder/Decoder使用复数形式是为了强调编码/解码阶段可能由多个组件堆叠而成，下文会讲到</p></blockquote><p>其中Encoders是由多个(论文中是6个)Encoder堆叠而成，Decoders也同样是由多个(论文中是6个)Decoder堆叠而成，如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191103153855.png" width="600" alt="Stacked Encoder and Decoder" /><p>图：Stacked Encoder and Decoder</p></div><p>对于Encoders中的每一个Encoder，它们结构都是相同的，<strong>但是并不会共享权值</strong>。每个Encoder由两个子网络层组成，分别是一个Self-Attention层和一个Feed-Forward层(全连接层)，如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191103154622.png" width="600" alt="Transformer的一个Encoder层" /><p>图：Transformer的一个Encoder层</p></div><p>对于Decoders中的每一个Decoder，它们的结构也都是相同的并且权值不共享。<strong>相比于Encoder，每一个Decoder除了Self-Attention层和全连接层之外还多了一个普通的Attention层，这个Attention层使得Decoder在解码时会考虑最后一层Encoder所有时刻的输出。</strong> 它的结构如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191103155935.png" width="700" alt="Transformer的一个Decoder层" /><p>图：Transformer的一个Decoder层</p></div><h2 id="画出Tensor进行分析"><a href="#画出Tensor进行分析" class="headerlink" title="画出Tensor进行分析"></a>画出Tensor进行分析</h2><p>现在我们已经了解了模型的主要组件，让我们开始研究对应的Tensor如何在这些组件之间流动。</p><p>由于输入的句子是一个词的序列，利用NLP的常规做法，我们先通过Embedding把它变成一个连续稠密的向量，如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191103161116.png" width="600" alt="Emebdding层" /><p>图：Emebdding层</p></div><blockquote><p>注：每一个词都编码成了512维度的向量，为了便于展示我们将用上面这些简单的小方块来表示这些向量</p></blockquote><p>虽然Emebdding层只发生在最底层的Encoder中，但是对于所有的Encoder层，你都可以按照<strong>同一种</strong>思维模式来理解，那就是<strong>它们都接收一个512维度的向量列表作为输入，只不过最底层的Encoder接收的是单词嵌入，其它Encoder则接收的是前一层Encoder的输出</strong>。</p><p>Embedding之后的序列会输入到最底层的Encoder，首先经过Self-Attention层然后再经过全连接层，如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191103163213.png" width="600" alt="Transformer Encoder层" /><p>图：Transformer Encoder层</p></div><h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><p>接下来，我们将以一个较短的句子为例，看看在编码器中每个子层中具体都发生了什么，首先最底层的Encoder结构如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191103235047.png" width="600" alt="Transformer Encoder层" /><p>图：Transformer Encoder层</p></div><p>可以看出这张图与上一张图内容基本相同，但是其实本张图展示了更多的细节：图中Self-Attention层是<strong>一个大的方框</strong>，表示它的输入是所有的$x_1,x_2,\ldots,x_n$，输出是$z_1,z_2,\ldots,z_n$，也就是说在计算$z_i$时需要依赖所有时刻的输入$x_1,x_2,\ldots,x_n$，不过我们可以用矩阵运算一下子把所有的$z_i$计算出来(后面介绍)；而全连接层是<strong>每个时刻是一个方框</strong>(但不同时刻的参数是共享的)，表示计算$r_i$只需要$z_i$，因此全连接网络的计算是完全是独立的，很容易并行计算；此外，前一层的输出$r_1,r_2,\ldots,r_n$直接输入到下一层。</p><h2 id="Self-Attention概述"><a href="#Self-Attention概述" class="headerlink" title="Self-Attention概述"></a>Self-Attention概述</h2><p>再把黑盒子打开一点，我们来了解一下Tensor如何在Self-Attention层中流动。</p><p>Self-Attention是Trandformer中最重要的组件，我们先来提炼一下它是如何工作的。假如我们想要翻译下面的句子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;The animal didn&#39;t cross the street because it was too tired&quot;</span><br></pre></td></tr></table></figure><p>句子的意思大概是“这个动物无法穿越马路，因为它太累了”，这里的it到底指代什么呢，是animal还是street？要知道具体的指代，我们需要在理解it的时候同时关注所有的单词，重点是animal、street和tired，然后根据知识(常识)我们知道只有animal才能tired，而street是不能tired的。<strong>Self-Attention用Encoder在编码一个词的时候会考虑句子中所有其它的词，从而确定怎么编码当前词。</strong> 但是如果把tired换成narrow，那么it就指代的是street了。</p><p><strong>而LSTM(即使是双向的)是无法实现上面的逻辑的。</strong> 为什么呢？比如前向的LSTM，我们在编码it的时候根本没有看到后面是tired还是narrow，所有它无法把it编码成哪个词。而后向的LSTM呢？当然它看到了tired，但是到it的时候它还没有看到animal和street这两个单词，当然就更无法编码it的内容了。</p><p>当然多层的LSTM理论上是可以编码这个语义的，它需要下层的LSTM同时编码了animal和street以及tired三个词的语义，然后由更高层的LSTM来把it编码成animal的语义。但是这样模型更加复杂。</p><p>下图是模型的最上一层(下标0是第一层，5是第六层)Encoder的Attention可视化图，这是 <a href="https://colab.research.google.com/github/tensorflow/tensor2tensor/blob/master/tensor2tensor/notebooks/hello_t2t.ipynb" target="_blank" rel="noopener">Tensor2Tensor notebook</a> 输出的内容：</p><div align=center><img src="http://image.yingzq.com/img/20191104092221.png" width="600" alt="Self-Attention的可视化" /><p>图：Self-Attention的可视化</p></div><p>我们可以看到，在编码it这个单词的时候，Self-Attention让模型更多地关注到“The animal”，因此编码后的it有了Animal的语义。</p><h2 id="Self-Attention详细介绍"><a href="#Self-Attention详细介绍" class="headerlink" title="Self-Attention详细介绍"></a>Self-Attention详细介绍</h2><p>下面我们详细的介绍Self-Attention是怎么计算的，首先介绍向量的形式逐个时刻计算，这便于理解，接下来我们把它写出矩阵的形式一次计算所有时刻的结果。</p><p>对于输入的每一个向量(第一层是词的Embedding，其它层是前一层的输出)，我们首先需要生成3个新的向量Q、K和V，分别代表Query向量、Key向量和Value向量。<strong>Query向量表示为了编码当前词，需要去注意(attend to)其它(其实也包括它自己)的词；而Key向量可以认为是这个词用于被检索的关键信息；Value向量则是真正的内容。</strong></p><p>我们对比一下普通的Attention(Luong 2015)，使用内积计算energy的情况。如下图所示，在这里，Key和Value向量都是它本身，而Query向量是当前隐状态$h_t$。计算energy $e_{tj}$的时候我们计算Q($h_t$)和K($\overline{h}_j$)的内积，然后用softmax进行归一化，最后把所有的$\overline{h}_j$加权平均得到context向量。</p><div align=center><img src="http://image.yingzq.com/img/20191104100653.png" width="600" alt="普通的Attention机制" /><p>图：普通的Attention机制</p></div><p><strong>而Self-Attention里的Query不是隐状态，并且来自当前输入向量本身，因此叫作Self-Attention。</strong> 另外Key和Value都不是输入向量，而是输入向量做了一下线性变换，这样做的好处是模型可以根据数据从输入向量中提取最适合作为Key和Value的部分。类似的，Query也是对输入向量做一下线性变换，它让系统可以根据任务学习出最适合的Query，从而可以注意到特定的内容。</p><p>K、V和Q的具体的计算过程如下如所示：</p><div align=center><img src="http://image.yingzq.com/img/20191104101640.png" width="600" alt="K、V和Q的计算过程" /><p>图：K、V和Q的计算过程</p></div><p>图中输入的是两个词“thinking”和“machines”，我们对它们进行Embedding(这是第一层，如果是后面的层，直接输入就是向量了)，得到向量$x_1$,$x_2$。接着我们用3个矩阵分别对它们进行变换，得到向量$q_1,k_1,v_1$和$q_2,k_2,v_2$。比如$q_1=x_1W^Q$，图中$x_1$的shape是1x4，$W^Q$是4x3，得到的$q_1$便是1x3。其它的计算也是类似的。</p><p>值得注意的是，为了能够使得Key和Query可以内积，我们要求$W^K$和$W^Q$的shape是一样的，但是并不要求$W^V$和它们一定一样(虽然实际论文实现是一样的)。</p><p>每个时刻t都计算出$q_t,k_t,v_t$后，我们就可以来计算Self-Attention了。以第一个时刻为例，我们首先计算$q_1$和$k_1,k_2$的内积，得到score，过程如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191104102956.png" width="600" alt="Self-Attention的向量计算步骤一" /><p>图：Self-Attention的向量计算步骤一</p></div><p>接下来使用softmax把score归一化，注意这里把score除以$\sqrt{d_k}$($d_k$表示Key向量的维度)之后再计算的softmax，根据论文的说法，这样计算梯度时会更加稳定(stable)。计算过程如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191104104331.png" width="600" alt="Self-Attention的向量计算步骤二" /><p>图：Self-Attention的向量计算步骤二</p></div><blockquote><p>简单阐述下为什么这里要除以$\sqrt{d_k}$。假设q、k向量中的每一个元素是独立的随机变量并且它们的均值是0方差是1，此时将q、k向量做点乘运算$q \cdot k=\sum_{i=1}^{d_k} q_i k_i$，点乘的结果是一个均值为0，方差为$d_k$的随机变量。</p></blockquote><p>接下来用softmax得到的归一化分数对所有时刻的V求加权平均，这样就可以认为得到的向量在Self-Attention的帮助下综合考虑了所有时刻的输入信息，计算过程如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191104112848.png" width="600" alt="Self-Attention的向量计算步骤三" /><p>图：Self-Attention的向量计算步骤三</p></div><p>这里只是演示了计算第一个时刻的过程，计算其它时刻的过程是完全一样的。</p><h2 id="Self-Attention的矩阵计算"><a href="#Self-Attention的矩阵计算" class="headerlink" title="Self-Attention的矩阵计算"></a>Self-Attention的矩阵计算</h2><p>前面介绍的方法需要一个循环遍历所有的时刻t计算得到$z_t$，我们可以把上面的向量计算变成矩阵的形式，从而一次计算出所有时刻的输出，这样的矩阵运算可以充分利用硬件资源(包括一些软件的优化)，从而效率更高。</p><p>首先还是计算Q、K和V，不过不是计算某个时刻的$q_t,k_t,v_t$了，而是一次计算所有时刻的Q、K和V。计算过程如下图所示。这里的输入是一个矩阵，矩阵的第i行表示第i个时刻的输入$x_i$。</p><div align=center><img src="http://image.yingzq.com/img/20191104113256.png" width="400" alt="Self-Attention的矩阵计算步骤一" /><p>图：Self-Attention的矩阵计算步骤一</p></div><p>接下来就是计算Q和K得到score，然后除以$\sqrt{d_k}$，然后再softmax，最后加权平均得到输出。全过程如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191104113551.png" width="600" alt="Self-Attention的矩阵计算步骤二" /><p>图：Self-Attention的矩阵计算步骤二</p></div><h2 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h2><p>这篇论文还提出了Multi-Head Attention的概念。其实很简单，前面定义的一组Q、K和V可以让一个词attend to相关的词，我们可以定义多组Q、K和V，它们分别可以关注不同的上下文。计算Q、K和V的过程还是一样，这不过现在变换矩阵从一组$(W^Q,W^K,W^V)$变成了多组$(W_0^Q,W_0^K,W_0^V)$ ，$(W_1^Q,W_1^K,W_1^V)$，…。如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191104114652.png" width="600" alt="Multi-Head计算多组Q、K和V" /><p>图：Multi-Head计算多组Q、K和V</p></div><p>论文中使用了8组不同的Q、K和V。对于输入矩阵X，每一组Q、K和V都可以得到一个输出矩阵Z，如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191104114937.png" width="600" alt="Multi-Head计算输出多个Z" /><p>图：Multi-Head计算输出多个Z</p></div><p>但是后面的全连接网络需要的输入是一个矩阵而不是多个矩阵，因此我们可以把每个head输出的$Z_i$拼接起来，然后再经过一个线性变换(矩阵$W^O$)得到最终的输出矩阵Z。这个过程如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191104115314.png" width="600" alt="Multi-Head生成最终的矩阵Z" /><p>图：Multi-Head生成最终的矩阵Z</p></div><p>上面的步骤涉及很多步骤和矩阵运算，我们用一张大图把整个过程表示出来，如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191104115506.png" width="700" alt="Multi-Head计算完整过程" /><p>图：Multi-Head计算完整过程</p></div><p>让我们回顾一下之前的例子，当我们在例句“The animal didn’t cross the street because it was too tired”中编码单词“it”时，不同的head把焦点放到了哪里：</p><div align=center><img src="http://image.yingzq.com/img/20191104115858.png" width="400" alt="Multi-Head Attention的焦点" /><p>图：Multi-Head Attention的焦点</p></div><p>可以看到，有的head(橘黄色部分)计算的结果认为其与“the animal”关系比较密切，而另一个head(绿色部分)则认为和“tired”关系更近。换句话说，使用Multi-Head Attention对“it”进行编码时，可以同时注意到“animal”和“tired”，这使得对“it”的编码更加全面而准确。</p><h2 id="位置编码-Positional-Encoding"><a href="#位置编码-Positional-Encoding" class="headerlink" title="位置编码(Positional Encoding)"></a>位置编码(Positional Encoding)</h2><blockquote><p>注意：这是Transformer原始论文使用的位置编码方法，而在BERT模型里，使用的是简单的可以学习的Embedding，和Word Embedding一样，只不过输入是位置而不是词而已。</p></blockquote><p>我们的目的是用Self-Attention替代RNN，RNN能够记住过去的信息，这可以通过Self-Attention“实时”的注意相关的任何词来实现等价(甚至更好)的效果。RNN还有一个特点就是能考虑词的顺序(位置)关系，一个句子即使词完全是相同的但是语义可能完全不同，比如“北京到上海的机票”与“上海到北京的机票”，它们的语义就有很大的差别。我们上面的介绍的Self-Attention是不考虑词的顺序的，如果模型参数固定了，上面两个句子的北京都会被编码成相同的向量。但是实际上我们可以期望这两个北京编码的结果不同，前者可能需要编码出发城市的语义，而后者需要包含目的城市的语义。而RNN是可以(至少是可能)学到这一点的。当然RNN为了实现这一点的代价就是顺序处理，很难并行。</p><p>为了解决这个问题，我们需要引入位置编码，也就是t时刻的输入，除了Embedding之外(这是与位置无关的)，我们还引入一个向量，这个向量是与t有关的，我们把Embedding和位置编码向量加起来作为模型的输入。这样的话如果两个词在不同的位置出现了，虽然它们的Embedding是相同的，但是由于位置编码不同，最终得到的向量也是不同的。</p><p>位置编码有很多方法，其中需要考虑的一个重要因素就是需要它编码的是相对位置的关系。比如两个句子：“北京到上海的机票”和“你好，我们要一张北京到上海的机票”。显然加入位置编码之后，两个北京的向量是不同的了，两个上海的向量也是不同的了，但是我们期望$Q_{北京1} K_{上海1}=Q_{北京2} K_{上海2}$。具体的位置编码算法不是这里关注的重点，我们以后再介绍。位置编码加入后的模型如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191104195401.png" width="700" alt="位置编码" /><p>图：位置编码</p></div><p>举一个简单的例子，假设Embedding的维度是4，那么实际的位置编码应该是这样的：</p><div align=center><img src="http://image.yingzq.com/img/20191104201012.png" width="600" alt="位置编码例子" /><p>图：位置编码例子</p></div><h2 id="残差连接"><a href="#残差连接" class="headerlink" title="残差连接"></a>残差连接</h2><p>在继续之前，我们需要说说编码器架构中的一个细节：每个Encoder中的每个子层(Self-Attention层和全连接层)在其周围都有一个残差连接，然后紧接着是一个 <a href="https://arxiv.org/abs/1607.06450" target="_blank" rel="noopener">Layer Normalization</a> 层。如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191104203857.png" width="600" alt="残差和Layer Normalization" /><p>图：残差和Layer Normalization</p></div><p>下图则展示了更多细节：输入$x_1,x_2$经Self-Attention层之后变成$z_1,z_2$，然后和残差连接的输入$x_1,x_2$加起来，然后经过Layer Normalization层输出给全连接层；全连接层正如上文提到的也是有一个残差连接和一个Layer Normalization层，最后再输出给上一层。</p><div align=center><img src="http://image.yingzq.com/img/20191104204732.png" width="600" alt="残差和Layer Normalization细节" /><p>图：残差和Layer Normalization细节</p></div><p><strong>Decoder和Encoder是类似的，区别在于它多了一个Encoder-Decoder Attention层，这个层的输入除了来自Self-Attention之外还有Encoder最后一层的所有时刻的输出。Encoder-Decoder Attention层的Query来自下一层，而Key和Value则来自Encoder的输出。</strong></p><p>如果我们仅考虑一个由两个编码器和两个解码器组成的Transformer，它看起来是这样的:</p><div align=center><img src="http://image.yingzq.com/img/20191104210604.png" width="700" alt="两层Encoder、Decoder堆叠的Transformer" /><p>图：两层Encoder、Decoder堆叠的Transformer</p></div><h2 id="省略部分"><a href="#省略部分" class="headerlink" title="省略部分"></a>省略部分</h2><p>到这里，Transformer的主体部分已经全部介绍完，关于机器翻译任务解码的细节、最后输出层的设计、损失函数的选取等并不是本文关注的重点，我们会在 <a href="/2019/11/18/the-annotated-transformer/" title="Transformer代码实现">Transformer代码实现</a> 中完完全全的实现一遍，在这里便不做多余的介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Transformer模型来自论文 &lt;a href=&quot;https://arxiv.org/abs/1706.03762&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Attention Is All You Need&lt;/a&gt; 。这个模型最初是为了提高机器翻译的效率，它的Self-Attention机制和Position Encoding可以替代RNN。因为RNN是顺序执行的，t时刻没有完成就不能处理t+1时刻，因此很难并行。但是后来发现Self-Attention效果很好，在很多其它的地方也可以使用Transformer模型。这包括著名的GPT和BERT模型，都是以Transformer为基础的。&lt;/p&gt;
&lt;p&gt;本文我们将通过图解的方式来直观的理解Transformer模型的基本原理，内容主要参考了文章 &lt;a href=&quot;http://jalammar.github.io/illustrated-transformer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Illustrated Transformer&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NLP" scheme="http://www.yingzq.com/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://www.yingzq.com/tags/NLP/"/>
    
      <category term="Deep Learning" scheme="http://www.yingzq.com/tags/Deep-Learning/"/>
    
      <category term="Transformer" scheme="http://www.yingzq.com/tags/Transformer/"/>
    
      <category term="BERT" scheme="http://www.yingzq.com/tags/BERT/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://www.yingzq.com/2019/10/22/greedy-algorithm/"/>
    <id>http://www.yingzq.com/2019/10/22/greedy-algorithm/</id>
    <published>2019-10-22T14:04:30.000Z</published>
    <updated>2020-04-10T14:09:08.567Z</updated>
    
    <content type="html"><![CDATA[<p>贪心算法，又名贪婪算法，是在寻找最优解问题时的常用方法。贪心算法分阶段地工作，在每一个阶段，选取<strong>当前状态下最好或最优</strong>的的选择，而不考虑将来的后果。通常，这意味着选择的是某个<strong>局部最优</strong>。这种 “眼下能够拿到的就拿” 的策略也正是贪心算法名称的由来，就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。</p><p>当算法终止时，我们希望<strong>局部最优</strong>等于<strong>全局最优</strong>。如果是这样的话，那么算法就是正确的；否则，算法得到的就是一个次最优解（suboptimal solution）。如果不要求绝对最佳答案，有时候也可以使用简单的贪心算法生成近似的答案，而无需使用产生准确答案所需要的复杂算法。</p><blockquote><p>注：本文我们主要考虑第一种情况，也就是贪心算法能得到最优解的情况</p></blockquote><p>贪心算法的应用实例也非常广泛，例如最短路径中的Dijkstra算法，最小生成树中的Prim算法和Kruskal算法。所以贪心算法是值得我们深入了解的。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>首先要明确一个问题可以使用贪心算法的两个<strong>基本要素</strong>：</p><ol><li><code>贪心选择性质</code>：所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到</li><li><code>最优子结构性质</code>：一个问题的最优解包含其子问题的最优解</li></ol><p>贪心算法的<strong>基本过程</strong>如下：</p><ol><li>建立数学模型来描述问题</li><li>把求解的问题分成若干个子问题</li><li>对每一子问题求解，得到子问题的局部最优解</li><li>把子问题的解局部最优解合成原来解问题的一个解</li></ol><p>其实上面的两段话大致有个印象就好，具体的做法我们接下来通过一些例子学习。</p><h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="分发饼干（LeetCode455-easy）"><a href="#分发饼干（LeetCode455-easy）" class="headerlink" title="分发饼干（LeetCode455 easy）"></a>分发饼干（LeetCode455 easy）</h3><p><strong>题目：</strong></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 g<sub>i</sub> ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 s<sub>j</sub> 。如果 s<sub>j</sub> &gt;= g<sub>i</sub> ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>注意：</strong></p><ul><li>你可以假设胃口值为正。</li><li>一个小朋友最多只能拥有一块饼干。</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>咋一看似乎有点麻烦，回溯、动态规划什么的已经开始酝酿了！但是再一想，本题的目标是尽可能满足多数量的孩子，那么很显然有如下结论：<strong>无论饼干情况如何，肯定是先满足胃口小的孩子是最优的；反之对于某个特定孩子而言，饼干肯定要选择最小的但是能满足该孩子的是最优的。</strong></p><p>所以这题可以使用贪心算法，优先使用最小的饼干满足最小的胃口，如果不可以，则丢弃这个饼干，采用次小的，依次类推，直到没有饼干或者没有小朋友。具体代码思路如下：</p><ol><li>对<code>g</code>和<code>s</code>升序排序</li><li>初始化两个指针<code>i</code>和<code>j</code>分别指向<code>g</code>和<code>s</code>初始位置</li><li>对比<code>g[i]</code>和<code>s[j]</code><ul><li><code>g[i] &lt;= s[j]</code>： 饼干满足胃口，把能满足的孩子数量加 1，并移动指针<code>i = i + 1</code>，<code>j = j + 1</code></li><li><code>g[i] &gt; s[j]</code>：无法满足胃口，<code>j</code>右移，继续查看下一块饼干是否可以满足胃口</li></ul></li></ol><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;i&lt;g.length &amp;&amp; j&lt;s.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[j]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柠檬水找零（LeetCode-860-easy）"><a href="#柠檬水找零（LeetCode-860-easy）" class="headerlink" title="柠檬水找零（LeetCode 860 easy）"></a>柠檬水找零（LeetCode 860 easy）</h3><p><strong>题目</strong></p><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，按账单 bills 支付的顺序一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。<br>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>顾客付款有三种可能：5、10、20。</p><ul><li>如果收到5美元，直接把5元放进口袋，什么也不用做</li><li>如果收到的10美元，则需要翻一翻自己的口袋里是否有5美元的零钱，没有则交易失败，可以关门回家了（返回false）</li><li>如果收到20美元，这时可以找零<code>10美元+5美元</code>或者<code>三张5美元</code>，这个时候如何抉择呢？<strong>我们使用贪心策略，尽可能地多留5元在手上，防止后面付款10元的顾客无法找零</strong>，也就是优先使用<code>10美元+5美元</code>，如果没有则使用<code>5美元+5美元+5美元</code>的组合，都不成立的话则交易失败，可以关门回家了（返回false）</li></ul><p>可以很显然的看出，当算法终止时局部最优是等于全局最优的，这一题的贪心策略是完全正确的。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : bills) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) five++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;five--; ten++;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ten &gt; <span class="number">0</span>) &#123;ten--; five--;&#125;</span><br><span class="line">            <span class="keyword">else</span> five -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (five &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳跃游戏（LeetCode-55-medium）"><a href="#跳跃游戏（LeetCode-55-medium）" class="headerlink" title="跳跃游戏（LeetCode 55 medium）"></a>跳跃游戏（LeetCode 55 medium）</h3><p><strong>题目：</strong></p><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>这题粗略一看是可以用动态规划完成的，但是仔细研读后，其实我们很容易有这种想法：</p><ol><li>如果某一个作为<code>起跳点</code>的格子可以跳跃的距离是3，那么表示后面3个格子都可以作为<code>起跳点</code></li><li>那么我们选择这3个<code>起跳点</code>中的哪一个呢？其实在这里，我们是希望选择的新的<code>起跳点</code>可以让后续的跳跃尽可能的远，这样的局部最优很显然是全局最优。所以可以对每一个能作为<code>起跳点</code>的格子都尝试跳一次，把<code>能跳到的最远距离</code>不断更新</li><li>如果可以一直跳到最后就成功了，反之则失败</li></ol><p>那什么是<code>能跳到的最远距离</code>呢？在代码中便是<code>i+nums[i]</code>，也就是此时数组的下标加上该位置数组元素对应的数值。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            max = Math.max(i + nums[i], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳跃游戏-II（LeetCode-45-hard）"><a href="#跳跃游戏-II（LeetCode-45-hard）" class="headerlink" title="跳跃游戏 II（LeetCode 45 hard）"></a>跳跃游戏 II（LeetCode 45 hard）</h3><p><strong>题目：</strong></p><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p>说明: 假设你总是可以到达数组的最后一个位置。</p><p><strong>分析</strong></p><p>和上题的思路是一样的，我们每次贪心的跳到<code>i+nums[i]</code>最大的位置，这样跳的次数肯定是最少的。</p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (idx + nums[idx] &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">            <span class="keyword">int</span> pos = idx + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = idx + <span class="number">1</span>; i &lt;= idx + nums[idx]; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt; pos + nums[pos]) pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            idx = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用最少数量的箭引爆气球（LeetCode-452-medium）"><a href="#用最少数量的箭引爆气球（LeetCode-452-medium）" class="headerlink" title="用最少数量的箭引爆气球（LeetCode 452 medium）"></a>用最少数量的箭引爆气球（LeetCode 452 medium）</h3><p><strong>题目：</strong></p><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。</p><p>一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 $x_{start}, x_{end}$，且满足 $x_{start} ≤ x ≤ x_{end}$，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">对于该样例，我们可以在x &#x3D; 6（射爆[2,8],[1,6]两个气球）和 x &#x3D; 11（射爆另外两个气球）。</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>对于某个气球，至少需要使用1只弓箭将它击穿。</p><p>因此有如下贪心策略：在击穿某个气球的同时，尽可能的击穿其他更多的气球。</p><p>算法思路如下：</p><ol><li>对各个气球排序，按照气球<code>左端点</code>从小到大排序。</li><li>遍历气球数组，同时维护一个<code>射击区间</code>，在满足可以将当前气球击穿的情况下，尽可能的击穿更多的气球，每击穿一个新的气球，更新一次射击区间（保证射击区间可以将新气球也击穿）。</li><li>如果新的气球没法被击穿了，则需要增加一名弓箭手，即维护一个新的射击区间，随后继续遍历气球数组。</li></ol><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// int start = points[0][0];</span></span><br><span class="line">        <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; points[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// start = points[i][0];</span></span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// start = points[i][0];</span></span><br><span class="line">                end = Math.min(end, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们发现，<code>end</code>是至关重要的，<code>start</code>是可有可无的。因此本题最好的方式是按照气球的<code>右端点</code>从小到大排序，这里直接给出相应代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; points[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.zhihu.com/search?q=%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95&type=content" target="_blank" rel="noopener">小白带你学—贪心算法</a></li><li><a href="https://leetcode.com/problemset/algorithms/" target="_blank" rel="noopener">LeetCode Algorithms</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;贪心算法，又名贪婪算法，是在寻找最优解问题时的常用方法。贪心算法分阶段地工作，在每一个阶段，选取&lt;strong&gt;当前状态下最好或最优&lt;/strong&gt;的的选择，而不考虑将来的后果。通常，这意味着选择的是某个&lt;strong&gt;局部最优&lt;/strong&gt;。这种 “眼下能够拿到的就
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://www.yingzq.com/tags/Java/"/>
    
      <category term="算法设计技巧" scheme="http://www.yingzq.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/"/>
    
      <category term="LeetCode" scheme="http://www.yingzq.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Git的杀手锏：分支模型（下）</title>
    <link href="http://www.yingzq.com/2019/10/16/git-branching-part-two/"/>
    <id>http://www.yingzq.com/2019/10/16/git-branching-part-two/</id>
    <published>2019-10-16T05:12:25.000Z</published>
    <updated>2020-02-19T17:40:19.606Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="/2019/10/13/git-branching/" title="Git的杀手锏：分支模型（上）">Git的杀手锏：分支模型（上）</a>中，我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作。在本章我们继续来学习Git分支的工作流、远程分支和变基等内容。</p><a id="more"></a><h2 id="Git分支开发工作流"><a href="#Git分支开发工作流" class="headerlink" title="Git分支开发工作流"></a>Git分支开发工作流</h2><p>现在我们已经学会新建和合并分支，那么可以或者应该用它来做些什么呢？本节会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出这些典型的工作模式。</p><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>因为Git使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p><p>许多使用Git的开发者都喜欢使用这种方式来工作，比如只在<code>master</code>分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。他们还有一些名为<code>develop</code>或者<code>next</code>的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入<code>master</code>分支了。这样，在确保这些已完成的特性分支（短期分支，比如之前的<code>iss53</code>分支）能够通过所有测试，并且不会引入更多bug之后，就可以合并入主干分支中，等待下一次的发布。</p><p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p><div align=center><img src="http://image.yingzq.com/img/20191021224943.png" width="800" alt="渐进稳定分支的线性图" /><p>图1：渐进稳定分支的线性图</p></div><p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p><div align=center><img src="http://image.yingzq.com/img/20191021225228.png" width="800" alt="渐进稳定分支的流水线视图" /><p>图2：渐进稳定分支的流水线视图</p></div><p>你可以用这种方法维护不同层次的稳定性。一些大型项目还有一个<code>proposed</code>（建议）或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入<code>next</code>或者<code>master</code>分支。这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。<strong>再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</strong></p><h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p>特性分支对任何规模的项目都适用。特性分支是一种短期分支，它被用来实现单一特性或其相关工作。也许你从来没有在其他的版本控制系统上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。然而，在Git中一天之内多次创建、使用、合并、删除分支都很常见。</p><p>你已经在前文中创建的<code>iss53</code>和<code>hotfix</code>特性分支中看到过这种用法。你在特性分支（<code>iss53</code>和<code>hotfix</code>分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。<strong>这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。</strong> 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p><p>考虑这样一个例子，你在<code>master</code>分支上工作到<code>C1</code>，这时为了解决一个问题而新建<code>iss91</code>分支，在<code>iss91</code>分支上工作到<code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个<code>iss91v2</code>分支试图用另一种方法解决那个问题，接着你回到<code>master</code>分支工作了一会儿，你又冒出了一个不太确定的想法，你便在<code>C10</code>的时候新建一个<code>dumbidea</code>分支，并在上面做些实验。你的提交历史看起来像下面这个样子：</p><div align=center><img src="http://image.yingzq.com/img/20191021232901.png" width="800" alt="拥有多个特性分支的提交历史" /><p>图3：拥有多个特性分支的提交历史</p></div><p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在<code>iss91v2</code>分支中方案；另外，你将<code>dumbidea</code>分支拿给你的同事看过之后，结果发现这是个惊人之举。这时你可以抛弃<code>iss91</code>分支（即丢弃<code>C5</code>和<code>C6</code>提交），然后把另外两个分支合并入主干分支。最终你的提交历史看起来像下面这个样子：</p><div align=center><img src="http://image.yingzq.com/img/20191021233532.png" width="800" alt="合并了dumbidea和iss91v2分支之后的提交历史" /><p>图4：合并了dumbidea和iss91v2分支之后的提交历史</p></div><blockquote><p>更多有关分支工作流的细节可以参考 <a href="https://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows#ch05-distributed-git" target="_blank" rel="noopener">Distributed Workflows</a></p></blockquote><p>最后请牢记，当你做这么多操作的时候，这些分支全部都存于本地。当你新建和合并分支的时候，所有这一切都只发生在你本地的Git版本库中，没有与服务器发生交互。</p><h2 id="Git远程分支"><a href="#Git远程分支" class="headerlink" title="Git远程分支"></a>Git远程分支</h2><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。你可以通过<code>git ls-remote [remote]</code>来显式地获得远程引用的完整列表，或者通过<code>git remote show [remote]</code>获得远程分支的更多信息。然而，一个更常见的做法是利用远程跟踪分支。</p><p>远程跟踪分支是远程分支状态的引用。它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p><p>它们以<code>&lt;remote&gt;/&lt;branch&gt;</code>形式命名。例如，如果你想要看你最后一次与远程仓库<code>origin</code>通信时<code>master</code>分支的状态，你可以查看<code>origin/master</code>分支。你与同事合作解决一个问题并且他们推送了一个<code>iss53</code>分支，你可能有自己的本地<code>iss53</code>分支；但是在服务器上的分支会指向<code>origin/iss53</code>的提交。</p><p>这可能有一点儿难以理解，让我们来看一个例子。假设你的网络里有一个在<code>git.ourcompany.com</code>的Git服务器。如果你从这里克隆，Git的<code>clone</code>命令会为你自动将其命名为<code>origin</code>，拉取它的所有数据，创建一个指向它的<code>master</code>分支的指针，并且在本地将其命名为<code>origin/master</code>。Git也会给你一个与<code>origin</code>的<code>master</code>分支在指向同一个地方的本地<code>master</code>分支，这样你就有工作的基础。</p><blockquote><p><strong>注意：“origin” 并无特殊含义</strong><br>远程仓库名字 “origin” 与分支名字 “master” 一样，在Git中并没有任何特别的含义一样。同时 “master” 是当你运行<code>git init</code>时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行<code>git clone</code>时默认的远程仓库名字。如果你运行<code>git clone -o booyah</code>，那么你默认的远程分支名字将会是<code>booyah/master</code>。</p></blockquote><div align=center><img src="http://image.yingzq.com/img/20191022002503.png" width="750" alt="克隆之后的服务器与本地仓库" /><p>图5：克隆之后的服务器与本地仓库</p></div><p>如果你在本地的<code>master</code>分支做了一些工作，与此同时，其他人推送提交到<code>git.ourcompany.com</code>并更新了它的<code>master</code>分支，那么你的提交历史将向不同的方向前进。另外，只要你不与<code>origin</code>服务器连接，你的<code>origin/master</code>指针就不会移动。</p><div align=center><img src="http://image.yingzq.com/img/20191022142139.png" width="750" alt="本地与远程的工作可以分叉" /><p>图6：本地与远程的工作可以分叉</p></div><p>如果要同步你的工作，运行<code>git fetch &lt;remote&gt;</code>命令（在本例中是<code>git fetch origin</code>）。这个命令查找 “origin” 是哪一个服务器（在本例中是<code>git.ourcompany.com</code>），从中抓取本地没有的数据，并且更新本地数据库，移动<code>origin/master</code>指针指向更新后的位置。</p><div align=center><img src="http://image.yingzq.com/img/20191022142624.png" width="750" alt="git fetch更新远程仓库引用" /><p>图7：git fetch更新远程仓库引用</p></div><p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部Git服务器，仅用于你小组的开发工作。这个服务器位于<code>git.team1.ourcompany.com</code>。你可以运行<code>git remote add</code>命令添加一个新的远程仓库引用到当前的项目。将这个远程仓库命名为<code>teamone</code>，将其作为整个URL的缩写。</p><div align=center><img src="http://image.yingzq.com/img/20191022143333.png" width="750" alt="添加另一个远程仓库" /><p>图8：添加另一个远程仓库</p></div><p>现在，可以运行<code>git fetch teamone</code>来抓取远程仓库<code>teamone</code>有而本地没有的数据。因为那台服务器上现有的数据是<code>origin</code>服务器上的一个子集，所以Git并不会抓取数据而是会设置远程跟踪分支<code>teamone/master</code>指向<code>teamone</code>的<code>master</code>分支。</p><div align=center><img src="http://image.yingzq.com/img/20191022143611.png" width="750" alt="远程跟踪分支teamone/master" /><p>图9：远程跟踪分支teamone/master</p></div><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p><p>如果希望和别人一起在名为<code>serverfix</code>的分支上工作，你可以像推送第一个分支那样推送它。运行<code>git push &lt;remote&gt; &lt;branch&gt;</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15&#x2F;15), done.</span><br><span class="line">Writing objects: 100% (24&#x2F;24), 1.91 KiB | 0 bytes&#x2F;s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure><p>这里有些工作被简化了。Git自动将<code>serverfix</code>分支名字展开为<code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的<code>serverfix</code>分支来更新远程仓库上的<code>serverfix</code>分支。” 你也可以运行<code>git push origin serverfix:serverfix</code>，它会做同样的事——也就是说 “推送本地的<code>serverfix</code>分支，将其作为远程仓库的<code>serverfix</code>分支”。你也可以通过这种格式来推送本地分支到一个命名不相同的远程分支，例如你并不想让远程仓库上的分支叫做<code>serverfix</code>，可以运行<code>git push origin serverfix:awesomebranch</code>来将本地的<code>serverfix</code>分支推送到远程仓库上的<code>awesomebranch</code>分支。</p><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支<code>origin/serverfix</code>，指向服务器的<code>serverfix</code>分支的引用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Compressing objects: 100% (2&#x2F;2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3&#x2F;3), done.</span><br><span class="line">From https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin&#x2F;serverfix</span><br></pre></td></tr></table></figure><p><strong>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本。换句话说，这种情况下，不会有一个新的<code>serverfix</code>分支，只有一个不可以修改的<code>origin/serverfix</code>指针。</strong></p><p>可以运行<code>git merge origin/serverfix</code>将这些工作合并到当前所在的分支。如果想要在自己的<code>serverfix</code>分支上工作，可以将其建立在远程跟踪分支之上：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b serverfix origin&#x2F;serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#39;serverfix&#39;</span><br></pre></td></tr></table></figure><p>这会给你一个用于工作的本地分支，并且起点位于<code>origin/serverfix</code>。</p><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。跟踪分支是与远程分支有直接关系的本地分支。如果在一个跟踪分支上输入<code>git pull</code>，Git能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪<code>origin/master</code>的<code>master</code>分支。然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪<code>master</code>分支。最简单的实例就是像之前看到的那样，运行<code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。这是一个十分常用的操作所以Git提供了<code>--track</code>快捷方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout --track origin&#x2F;serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#39;serverfix&#39;</span><br></pre></td></tr></table></figure><p>事实上，这个命令实在是太常用了，所以有一个快捷方式中的快捷方式。如果您试图检出的分支满足(a)名称不存在(b)有且仅有一个远程分支名称和它完全匹配，Git将为您创建跟踪分支：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#39;serverfix&#39;</span><br></pre></td></tr></table></figure><p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地使用原始版本的命令增加一个不同名字的本地分支：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b sf origin&#x2F;serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#39;sf&#39;</span><br></pre></td></tr></table></figure><p>现在，本地分支<code>sf</code>会自动从<code>origin/serverfix</code>拉取。</p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用<code>-u</code>或<code>--set-upstream-to</code>选项运行<code>git branch</code>来显式地设置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -u origin&#x2F;serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：上游快捷方式</strong><br>当设置好跟踪分支后，可以通过<code>@{upstream}</code>或<code>@{u}</code>快捷方式来引用它。所以在<code>master</code>分支时并且它正在跟踪<code>origin/master</code>时，如果愿意的话可以使用<code>git merge @{u}</code>来取代<code>git merge origin/master</code>。</p></blockquote><p>如果想要查看设置的所有跟踪分支，可以使用<code>git branch</code>的<code>-vv</code>选项。这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">  iss53     7e424c3 [origin&#x2F;iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin&#x2F;master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone&#x2F;server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure><p>这里可以看到<code>iss53</code>分支正在跟踪<code>origin/iss53</code>并且 “ahead” 是2，意味着本地有两个提交还没有推送到服务器上。也能看到<code>master</code>分支正在跟踪<code>origin/master</code>分支并且是最新的。接下来可以看到<code>serverfix</code>分支正在跟踪<code>teamone</code>服务器上的<code>server-fix-good</code>分支并且领先3落后1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。最后看到<code>testing</code>分支并没有跟踪任何远程分支。</p><p><strong>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。</strong>如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。可以像这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch --all; git branch -vv</span><br></pre></td></tr></table></figure><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>当<code>git fetch</code>命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。它只会获取数据然后让你自己合并。然而，有一个命令叫作<code>git pull</code>在大多数情况下它的含义是一个<code>git fetch</code>紧接着一个<code>git merge</code>命令。如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过<code>clone</code>或<code>checkout</code>命令为你创建的，<code>git pull</code>都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p><p>由于<code>git pull</code>的魔法经常令人困惑所以通常单独显式地使用<code>fetch</code>与<code>merge</code>命令会更好一些。</p><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>假设你已经通过远程分支做完所有的工作了，也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的<code>master</code>分支（或任何其他稳定代码分支）。可以运行带有<code>--delete</code>选项的<code>git push</code>命令来删除一个远程分支。例如想要从服务器上删除<code>serverfix</code>分支，运行下面的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure><p>基本上这个命令做的只是从服务器上移除这个指针。Git服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p><h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在Git中整合来自不同分支的修改主要有两种方法：<code>merge</code>以及<code>rebase</code>。在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p><h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h3><p>考虑之前遇到的情况，开发任务分叉到了两个不同分支，又各自提交了更新。</p><div align=center><img src="http://image.yingzq.com/img/20191022154849.png" width="750" alt="分叉的提交历史" /><p>图10：分叉的提交历史</p></div><p>之前介绍过，整合分支最容易的方法是<code>merge</code>命令。它会把两个分支的最新快照（<code>C3</code>和<code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交），如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191022155124.png" width="750" alt="通过合并操作来整合分叉了的历史" /><p>图11：通过合并操作来整合分叉了的历史</p></div><p>其实，还有一种方法：你可以提取在<code>C4</code>中引入的补丁和修改，然后在<code>C3</code>的基础上应用一次。在Git中，这种操作就叫做 <strong>变基</strong>。 你可以使用<code>rebase</code>命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p>在上面这个例子中，运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支<code>experiment</code>、变基操作的目标基底分支<code>master</code>）的最近共同祖先<code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底<code>C3</code>，最后以此将之前另存为临时文件的修改依序应用。</p><div align=center><img src="http://image.yingzq.com/img/20191022161447.png" width="750" alt="将C4中的修改变基到C3上" /><p>图12：将C4中的修改变基到C3上</p></div><p>现在回到<code>master</code>分支，进行一次快进合并。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge experiment</span><br></pre></td></tr></table></figure><div align=center><img src="http://image.yingzq.com/img/20191022161720.png" width="750" alt="master分支的快进合并" /><p>图13：master分支的快进合并</p></div><p>此时，<code>C4&#39;</code>指向的快照就和上面使用<code>merge</code>命令的例子中<code>C5</code>指向的快照一模一样了。这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁，例如向某个其他人维护的项目贡献代码时。在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到<code>origin/master</code>上，然后再向主项目提交修改。这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p><strong>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</strong></p><h3 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。</p><p>就像下图的例子：</p><div align=center><img src="http://image.yingzq.com/img/20191022162427.png" width="800" alt="从一个特性分支里再分出一个特性分支的提交历史" /><p>图14：从一个特性分支里再分出一个特性分支的提交历史</p></div><p>你创建了一个特性分支<code>server</code>，为服务端添加了一些功能，提交了<code>C3</code>和<code>C4</code>。然后从<code>C3</code>上创建了特性分支<code>client</code>，为客户端添加了一些功能，提交了<code>C8</code>和<code>C9</code>。最后，你回到<code>server</code>分支，又提交了<code>C10</code>。</p><p>假设你希望将<code>client</code>中的修改合并到主分支并发布，但暂时并不想合并<code>server</code>中的修改，因为它们还需要经过更全面的测试。这时，你就可以使用<code>git rebase</code>命令的<code>--onto</code>选项，选中在<code>client</code>分支里但不在<code>server</code>分支里的修改（即<code>C8</code>和<code>C9</code>），将它们在<code>master</code>分支上重放：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rebase --onto master server client</span><br></pre></td></tr></table></figure><p>以上命令的意思是：“取出<code>client</code>分支，找出处于<code>client</code>分支和<code>server</code>分支的共同祖先之后的修改，然后把它们在<code>master</code>分支上重放一遍”。这理解起来有一点复杂，不过效果非常酷。</p><div align=center><img src="http://image.yingzq.com/img/20191022164831.png" width="800" alt="截取特性分支上的另一个特性分支，然后变基到其他分支" /><p>图15：截取特性分支上的另一个特性分支，然后变基到其他分支</p></div><p>现在可以快进合并<code>master</code>分支了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge client</span><br></pre></td></tr></table></figure><div align=center><img src="http://image.yingzq.com/img/20191022165050.png" width="800" alt="快进合并master分支，使之包含来自client分支的修改" /><p>图16：快进合并master分支，使之包含来自client分支的修改</p></div><p>接下来你决定将<code>server</code>分支中的修改也整合进来。使用<code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code>命令可以直接将特性分支（即本例中的<code>server</code>）变基到目标分支（即<code>master</code>）上。这样做能省去你先切换到<code>server</code>分支，再对其执行变基命令的多个步骤：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rebase master server</span><br></pre></td></tr></table></figure><p>这样，<code>server</code>中的代码便被“续”到了<code>master</code>后面，如下图所示：</p><div align=center><img src="http://image.yingzq.com/img/20191022170242.png" width="800" alt="将server中的修改变基到master上" /><p>图17：将server中的修改变基到master上</p></div><p>然后就可以快进合并主分支<code>master</code>了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge server</span><br></pre></td></tr></table></figure><p>至此，<code>client</code>和<code>server</code>分支中的修改都已经整合到主分支里了，你可以删除这两个分支</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d client</span><br><span class="line">$ git branch -d server</span><br></pre></td></tr></table></figure><p>最终提交历史会变成下图中的样子：</p><div align=center><img src="http://image.yingzq.com/img/20191022170702.png" width="800" alt="最终的提交历史" /><p>图18：最终的提交历史</p></div><h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p>奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p><p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p><p><strong>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。</strong>如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用<code>git rebase</code>命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p><h3 id="变基-vs-合并"><a href="#变基-vs-合并" class="headerlink" title="变基 vs. 合并"></a>变基 vs. 合并</h3><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。它是针对历史的文档，本身就有价值，不能乱改。从这个角度看来，改变提交历史是一种亵渎，你使用 <strong>谎言</strong> 掩盖了实际发生过的事情。如果由合并产生的提交历史是一团糟怎么办？既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p><p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。持这一观点的人会使用<code>rebase</code>及<code>filter-branch</code>等工具来编写故事，怎么方便后来的读者就怎么写。</p><p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。Git是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p><p><strong>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们已经讲完了Git分支与合并的基础知识。你现在应该能自如地创建并切换至新分支、在不同分支之间切换以及合并本地分支。你现在应该也能通过推送你的分支至共享服务以分享它们、使用共享分支与他人协作以及在共享之前使用变基操作合并你的分支。同时通过这些例子，我们也能真真切切的感受到Git分支模型的强大，说分支模型是Git的杀手锏一点也不为过！</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git Book</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;/2019/10/13/git-branching/&quot; title=&quot;Git的杀手锏：分支模型（上）&quot;&gt;Git的杀手锏：分支模型（上）&lt;/a&gt;中，我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作。在本章我们继续来学习Git分支的工作流、远程分支和变基等内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.yingzq.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.yingzq.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git的杀手锏：分支模型（上）</title>
    <link href="http://www.yingzq.com/2019/10/13/git-branching/"/>
    <id>http://www.yingzq.com/2019/10/13/git-branching/</id>
    <published>2019-10-13T04:11:55.000Z</published>
    <updated>2020-02-19T17:40:13.456Z</updated>
    
    <content type="html"><![CDATA[<p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。与许多其它版本控制系统不同，Git鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。理解和精通这一特性，你便会意识到Git是如此的强大而又独特，并且从此真正改变你的开发方式。</p><a id="more"></a><blockquote><p>正如文章题目，这也是Git能在众多版本控制系统脱颖而出的“杀手锏”</p></blockquote><h2 id="初识Git分支"><a href="#初识Git分支" class="headerlink" title="初识Git分支"></a>初识Git分支</h2><h3 id="Git分支简介"><a href="#Git分支简介" class="headerlink" title="Git分支简介"></a>Git分支简介</h3><p>在 <a href="/2019/09/18/what-is-git/" title="What is Git">What is Git</a> 中，我们了解到<strong>Git保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照</strong>，这和其他版本控制系统很是不同，那么为什么Git要这样做呢？</p><p>在进行提交操作时，Git会保存一个提交对象（commit object）。知道了Git保存数据的方式，我们可以很自然的想到<strong>该提交对象会包含一个指向暂存内容快照的指针</strong>。但不仅仅是这样，<strong>该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针</strong>。</p><blockquote><p>首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象</p></blockquote><p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和（使用SHA-1哈希算法），然后会把当前版本的文件快照保存到Git仓库中（Git使用blob对象来保存它们），最终将校验和加入到暂存区域等待提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m &#39;The initial commit of my project&#39;</span><br></pre></td></tr></table></figure><p>当使用<code>git commit</code>进行提交操作时，Git会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在Git仓库中这些校验和保存为树对象。随后，Git便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git就可以在需要的时候重现此次保存的快照。</p><p>现在，Git仓库中有五个对象：三个blob对象（保存着文件快照）、一个树对象（记录着目录结构和blob对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p><div align=center><img src="http://image.yingzq.com/img/20191016150929.png" width="750" alt="首次提交对象及其树结构" /><p>图1：首次提交对象及其树结构</p></div><p>如果做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p><div align=center><img src="http://image.yingzq.com/img/20191016151756.png" width="750" alt="提交对象及其父对象" /><p>图2：提交对象及其父对象</p></div><p><strong>Git的分支，其实本质上仅仅是指向提交对象的轻量级可移动指针。</strong>Git的默认分支名字是<code>master</code>。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的<code>master</code>分支。它会在每次的提交操作中自动向前移动。</p><blockquote><p>Git的<code>master</code>分支并不是一个特殊分支。它就跟其它分支完全没有区别。之所以几乎每一个仓库都有<code>master</code>分支，是因为<code>git init</code>命令默认创建它，并且大多数人都懒得去改动它。</p></blockquote><div align=center><img src="http://image.yingzq.com/img/20191018152124.png" width="750" alt="分支及其提交历史" /><p>图3：分支及其提交历史</p></div><h3 id="Git分支创建"><a href="#Git分支创建" class="headerlink" title="Git分支创建"></a>Git分支创建</h3><p>Git创建新分支很简单，因为Git只是为你创建了一个可以移动的新的指针。例如创建一个<code>testing</code>分支，你需要使用<code>git branch</code>命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure><p>这会在当前所在的提交对象上创建一个指针。</p><div align=center><img src="http://image.yingzq.com/img/20191018153630.png" width="750" alt="两个指向相同提交历史的分支" /><p>图4：两个指向相同提交历史的分支</p></div><p>那么，Git又是怎么知道当前在哪一个分支上呢？也很简单，它有一个名为<code>HEAD</code>的特殊指针。请注意它和许多其它版本控制系统（如Subversion或CVS）里的<code>HEAD</code>概念完全不同。在Git中，它是一个指针，指向当前所在的本地分支。在本例中，你仍然在<code>master</code>分支上。 <strong>因为<code>git branch</code>命令仅仅创建一个新分支，并不会自动切换到新分支中去</strong>。</p><div align=center><img src="http://image.yingzq.com/img/20191020185042.png" width="750" alt="HEAD指向当前所在的分支" /><p>图5：HEAD指向当前所在的分支</p></div><p>你可以简单地使用<code>git log</code>命令查看各个分支当前所指的对象。提供这一功能的参数是<code>--decorate</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --oneline --decorate</span><br><span class="line">f30ab (HEAD -&gt; master, testing) add feature #32 - ability to add new</span><br><span class="line">34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><p>可以看到，当前 “master” 和 “testing” 分支均指向校验和以<code>f30ab</code>开头的提交对象。</p><h3 id="Git分支切换"><a href="#Git分支切换" class="headerlink" title="Git分支切换"></a>Git分支切换</h3><p>要切换到一个已存在的分支，你需要使用<code>git checkout</code>命令。我们现在切换到新创建的<code>testing</code>分支去：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure><p>这样<code>HEAD</code>就指向<code>testing</code>分支了。</p><div align=center><img src="http://image.yingzq.com/img/20191021113753.png" width="750" alt="HEAD指向当前所在的分支" /><p>图6：HEAD指向当前所在的分支</p></div><p>那么，这样的实现方式会给我们带来什么好处呢？现在不妨再提交一次：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m &#39;made a change&#39;</span><br></pre></td></tr></table></figure><div align=center><img src="http://image.yingzq.com/img/20191021143629.png" width="800" alt="HEAD分支随着提交操作自动向前移动" /><p>图7：HEAD分支随着提交操作自动向前移动</p></div><p>这就有意思了，你的<code>testing</code>分支向前移动了，但是<code>master</code>分支却没有，它仍然指向运行<code>git checkout</code>时所指的对象。现在我们切换回 master 分支看看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><div align=center><img src="http://image.yingzq.com/img/20191021144113.png" width="800" alt="检出时HEAD随之移动" /><p>图8：检出时HEAD随之移动</p></div><p>这条命令做了两件事。一是使<code>HEAD</code>指回<code>master</code>分支，二是将工作目录恢复成<code>master</code>分支所指向的快照内容。也就是说，你现在做修改的话，项目将始于一个较旧的版本。本质上来讲，这就是忽略<code>testing</code>分支所做的修改，以便于向另一个方向进行开发。</p><blockquote><p><strong>注意：分支切换会改变你工作目录中的文件</strong><br>在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果Git不能干净利落地完成这个任务，它将禁止切换分支。</p></blockquote><p>我们不妨再稍微做些修改并提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m &#39;made other changes&#39;</span><br></pre></td></tr></table></figure><p>现在，这个项目的提交历史已经产生了分叉。因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回<code>master</code>分支进行了另外一些工作。上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。而所有这些工作，你需要的命令只有<code>branch</code>、<code>checkout</code>和<code>commit</code>。</p><div align=center><img src="http://image.yingzq.com/img/20191021150106.png" width="800" alt="项目分叉历史" /><p>图9：项目分叉历史</p></div><p>你可以简单地使用<code>git log</code>命令查看分叉历史。运行<code>git log --oneline --decorate --graph --all</code>，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --oneline --decorate --graph --all</span><br><span class="line">* c2b9e (HEAD -&gt; master) made other changes</span><br><span class="line">| * 87ab2 (testing) made a change</span><br><span class="line">|&#x2F;</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><p>由于Git的分支实质上仅是包含所指对象校验和（长度为40的SHA-1值字符串）的文件，所以它的创建和销毁都异常高效。创建一个新分支就相当于往一个文件中写入41个字节（40个字符和1个换行符），如此的简单能不快吗？</p><p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。<strong>而在Git中，任何规模的项目都能在瞬间创建新分支。</strong> 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（即共同祖先）也是同样的简单和高效。这些高效的特性使得Git鼓励开发人员频繁地创建和使用分支。</p><p>接下来，让我们看看你为什么应该这样做。</p><blockquote><p><strong>注意：Git可以创建分支并同时切换到该分支</strong><br>创建一个分支并希望同时切换到该分支是很常见的，这可以通过<code>git checkout -b &lt;newbranchname&gt;</code>一条命令即可完成！</p></blockquote><h2 id="Git分支新建与合并"><a href="#Git分支新建与合并" class="headerlink" title="Git分支新建与合并"></a>Git分支新建与合并</h2><p>让我们来看一个简单的Git分支新建与合并的例子，实际工作中你可能会用到类似的工作流。你将经历如下步骤：</p><ol><li>开发某个网站。</li><li>为实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。你将按照如下方式来处理：</p><ol><li>切换到你的线上分支（production branch）。</li><li>为这个紧急任务新建一个分支，并在其中修复它。</li><li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li><li>切换回你最初工作的分支上，继续工作。</li></ol><h3 id="分支新建"><a href="#分支新建" class="headerlink" title="分支新建"></a>分支新建</h3><p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p><div align=center><img src="http://image.yingzq.com/img/20191021160941.png" width="750" alt="一个简单提交历史" /><p>图10：一个简单提交历史</p></div><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。想要新建一个分支并同时切换到那个分支上，你可以运行一个带有<code>-b</code>参数的<code>git checkou</code>命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch &quot;iss53&quot;</span><br></pre></td></tr></table></figure><p>它是下面两条命令的简写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure><div align=center><img src="http://image.yingzq.com/img/20191021161457.png" width="750" alt="创建一个新分支指针" /><p>图11：创建一个新分支指针</p></div><p>你继续在 #53 问题上工作，并且做了一些提交。在此过程中，<code>iss53</code>分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的<code>HEAD</code>指针指向了<code>iss53</code>分支）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &#39;added a new footer [issue 53]&#39;</span><br></pre></td></tr></table></figure><div align=center><img src="http://image.yingzq.com/img/20191021163741.png" width="750" alt="iss53分支随着工作的进展向前推进" /><p>图12：iss53分支随着工作的进展向前推进</p></div><p>现在你接到那个电话，有个紧急问题等待你来解决。有了Git的帮助，你不必把这个紧急问题和<code>iss53</code>的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。你所要做的仅仅是切换回<code>master</code>分支！</p><p>但是，在你这么做之前，<strong>要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止Git切换到该分支</strong>。最好的方法是，在你切换分支之前，保持好一个干净的状态。有一些方法可以绕过这个问题，即保存进度（stashing）和修补提交（commit amending）。</p><p>现在，我们假设你已经把你的修改全部提交了，这时你可以切换回<code>master</code>分支了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br></pre></td></tr></table></figure><p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。请牢记：<strong>当你切换分支的时候，Git会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。Git会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</strong></p><p>接下来，你要修复这个紧急问题。让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br><span class="line">Switched to a new branch &#39;hotfix&#39;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &#39;fixed the broken email address&#39;</span><br><span class="line">[hotfix 1fb7853] fixed the broken email address</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><div align=center><img src="http://image.yingzq.com/img/20191021191514.png" width="750" alt="基于master分支的紧急问题分支hotfix branch" /><p>图13：基于master分支的紧急问题分支hotfix branch</p></div><p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的<code>master</code>分支来部署到线上。你可以使用<code>git merge</code>命令来达到上述目的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>在合并的时候，你应该注意到了“快进（fast-forward）”这个词。由于当前<code>master</code>分支所指向的提交是你当前提交（有关<code>hotfix</code>的提交）的直接上游，所以Git只是简单的将指针向前移动。<strong>换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做“快进（fast-forward）”。</strong></p><div align=center><img src="http://image.yingzq.com/img/20191021192025.png" width="750" alt="master被快进到hotfix" /><p>图14：master被快进到hotfix</p></div><p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。然而，你应该先删除<code>hotfix</code>分支，因为<code>master</code>分支已经指向了同一个位置，所以你已经不再需要它了。你可以使用带<code>-d</code>选项的<code>git branch</code>命令来删除分支：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure><p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（<code>iss53</code>分支）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout iss53</span><br><span class="line">Switched to branch &quot;iss53&quot;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &#39;finished the new footer [issue 53]&#39;</span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><div align=center><img src="http://image.yingzq.com/img/20191021192515.png" width="800" alt="继续在iss53分支上的工作" /><p>图15：继续在iss53分支上的工作</p></div><p>注意到你在<code>hotfix</code>分支上所做的工作并没有包含到<code>iss53</code>分支中。如果你需要拉取<code>hotfix</code>所做的修改，你可以使用<code>git merge master</code>命令将<code>master</code>分支合并入<code>iss53</code>分支，或者你也可以等到<code>iss53</code>分支完成其使命，再将其合并回<code>master</code>分支。</p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>假设你已经修正了 #53 问题，并且打算将你的工作合并入<code>master</code>分支。为此，你需要合并<code>iss53</code>分支到<code>master</code>分支，这和之前你合并<code>hotfix</code>分支所做的工作差不多。你只需要检出到你想合并入的分支，然后运行<code>git merge</code>命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br><span class="line">$ git merge iss53</span><br><span class="line">Merge made by the &#39;recursive&#39; strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>这和你之前合并<code>hotfix</code>分支的时候看起来有一点不一样。在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。因为<code>master</code>分支所在提交并不是<code>iss53</code>分支所在提交的直接祖先，Git不得不做一些额外的工作。出现这种情况的时候，Git会使用两个分支的末端所指的快照（C4和C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。</p><div align=center><img src="http://image.yingzq.com/img/20191021194612.png" width="800" alt="一次典型合并中所用到的三个快照" /><p>图16：一次典型合并中所用到的三个快照</p></div><p><strong>和之前将分支指针向前推进所不同的是，Git将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。</strong>这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p><div align=center><img src="http://image.yingzq.com/img/20191021195914.png" width="800" alt="一个合并提交" /><p>图17：一个合并提交</p></div><p>需要指出的是，Git会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的CVS系统或者Subversion（1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。Git的这个优势使其在合并操作上比其他系统要简单很多。</p><p>既然你的修改已经合并进来了，你已经不再需要<code>iss53</code>分支了。现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d iss53</span><br></pre></td></tr></table></figure><h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>有时候合并操作不会如此顺利。如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git就没法干净的合并它们。如果你对 #53 问题的修改和有关<code>hotfix</code>的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>此时Git做了合并，但是没有自动地创建一个新的合并提交。Git会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用<code>git status</code>命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。Git会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id&#x3D;&quot;footer&quot;&gt;contact : email.support@github.com&lt;&#x2F;div&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&lt;div id&#x3D;&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>这表示<code>HEAD</code>所指示的版本（也就是你的<code>master</code>分支所在的位置，因为你在运行<code>merge</code>命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code>的上半部分），而<code>iss53</code>分支所指示的版本在<code>=======</code>的下半部分。为了解决冲突，你必须选择使用由<code>=======</code>分割的两部分中的一个，或者你也可以自行合并这些内容。例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>这些行被完全删除了。在你解决了所有文件里的冲突之后，对每个文件使用<code>git add</code>命令来将其标记为冲突已解决。一旦暂存这些原本有冲突的文件，Git就会将它们标记为冲突已解决。</p><p>如果你想使用图形化工具来解决冲突，你可以运行<code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git mergetool</span><br><span class="line"></span><br><span class="line">This message is displayed because &#39;merge.tool&#39; is not configured.</span><br><span class="line">See &#39;git mergetool --tool-help&#39; or &#39;git help config&#39; for more details.</span><br><span class="line">&#39;git mergetool&#39; will now attempt to use one of the following tools:</span><br><span class="line">tortoisemerge emerge vimdiff</span><br><span class="line">Merging:</span><br><span class="line">README</span><br><span class="line"></span><br><span class="line">Normal merge conflict for &#39;README&#39;:</span><br><span class="line">  &#123;local&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br><span class="line">Hit return to start merge resolution tool (vimdiff):</span><br></pre></td></tr></table></figure><p>如果你想使用除默认工具（在这里Git使用<code>vimdiff</code>做为默认的合并工具）外的其他合并工具，你可以在“下列工具中（one of the following tools）”这句后面看到所有支持的合并工具。然后输入你喜欢的工具名字就可以了。</p><blockquote><p>如果你需要更加高级的工具来解决复杂的合并冲突，可以参考 <a href="https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging#_advanced_merging" target="_blank" rel="noopener">Git Tools - Advanced Merging</a></p></blockquote><p>等你退出合并工具之后，Git会询问刚才的合并是否成功。如果你回答是，Git会暂存那些文件以表明冲突已解决：你可以再次运行<code>git status</code>来确认所有的合并冲突都已被解决：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use &quot;git commit&quot; to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">    modified:   index.html</span><br></pre></td></tr></table></figure><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入<code>git commit</code>来完成合并提交。默认情况下提交信息看起来像下面这个样子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Merge branch &#39;iss53&#39;</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">    index.html</span><br><span class="line">#</span><br><span class="line"># It looks like you may be committing a merge.</span><br><span class="line"># If this is not correct, please remove the file</span><br><span class="line">#.git&#x2F;MERGE_HEAD</span><br><span class="line"># and try again.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># All conflicts fixed but you are still merging.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#modified:   index.html</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p><h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p><p><code>git branch</code>命令不只是可以创建与删除分支。如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>注意<code>master</code>分支前的<code>*</code>字符：它代表现在检出的那一个分支（也就是说，当前<code>HEAD</code>指针所指向的分支）。这意味着如果在这时候提交，<code>master</code>分支将会随着新的工作向前移动。如果需要查看每一个分支的最后一次提交，可以运行<code>git branch -v</code>命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#39;iss53&#39;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure><p><code>--merged</code>与<code>--no-merged</code>这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。如果要查看哪些分支已经合并到当前分支，可以运行<code>git branch --merged</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>因为之前已经合并了<code>iss53</code>分支，所以现在看到它在列表中。在这个列表中分支名字前没有<code>*</code>号的分支通常可以使用<code>git branch -d</code>删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p><p>查看所有包含未合并工作的分支，可以运行<code>git branch --no-merged</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>这里显示了其他分支。因为它包含了还未合并的工作，尝试使用<code>git branch -d</code>命令删除它时会失败：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d testing</span><br><span class="line">error: The branch &#39;testing&#39; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#39;git branch -D testing&#39;.</span><br></pre></td></tr></table></figure><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用<code>-D</code>选项强制删除它。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作，难以置信的轻量分支模型也正是Git在众多版本控制系统中脱颖而出的杀手锏！</p><p>但是至此关于Git分支的内容还未结束，我们还没充分了解到Git分支的工作流、Git远程分支等内容，限于篇幅将在 <a href="/2019/10/16/git-branching-part-two/" title="Git的杀手锏：分支模型（下）">Git的杀手锏：分支模型（下）</a>继续讲解。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git Book</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。与许多其它版本控制系统不同，Git鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。理解和精通这一特性，你便会意识到Git是如此的强大而又独特，并且从此真正改变你的开发方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.yingzq.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.yingzq.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>请务必掌握的Git基础</title>
    <link href="http://www.yingzq.com/2019/10/01/git-basics/"/>
    <id>http://www.yingzq.com/2019/10/01/git-basics/</id>
    <published>2019-10-01T05:03:38.000Z</published>
    <updated>2020-02-19T17:40:18.378Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前最流行的分布式版本控制系统，值得我们去学会使用并深入了解。本文将会介绍几个最基本的，也是最常用的命令，以后绝大多数时间里用到的可能也就是这几个命令，主要涉及Git的配置、Git仓库的获取、如何记录每次更新到Git仓库、提交历史的查看、Git的撤销操作、Git标签和Git别名等基础知识点，这些是你务必掌握的Git基础！</p><a id="more"></a><h2 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h2><p>在开始阅读前，有几个需要注意的点：</p><ol><li>如果你没听说过Git或者还不了解Git是什么，请参阅文章 <a href="/2019/09/18/what-is-git/" title="What is Git">What is Git</a> 。</li><li>Git有多种使用方式，包括原生的和GUI模式，在这里推荐先使用并熟悉命令行模式，<strong>因为如果你学会了在命令行下如何操作，那么你在操作GUI软件时应该也不会遇到什么困难，但是，反之则不成立。</strong></li></ol><h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>在不同平台上Git安装的方式有一定差异，在这里不详细介绍。值得注意的是，虽然Git具有很好的向后兼容性，但是还是建议大家最好将它升级到最新的版本。</p><p>例如在Ubuntu系统中，可通过如下指令来安装最新稳定版本的Git：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p>在mac系统中则可通过Homebrew来安装最新版本的Git：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure><p>更多的安装指导可查看 <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" target="_blank" rel="noopener">Installing Git</a> 和 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官方下载界面</a> 。</p><p>安装完成后，输入指令<code>git --version</code>，返回正常的版本信息则证明已成功安装Git：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.21.0</span><br></pre></td></tr></table></figure><blockquote><p>注：因为Git的安装是非常方便快捷的，官网也有清晰的指导，所以这一章节讲的非常简略。</p></blockquote><h2 id="初次使用Git前的配置"><a href="#初次使用Git前的配置" class="headerlink" title="初次使用Git前的配置"></a>初次使用Git前的配置</h2><p>在第一次使用一个新编辑器的时候，你会倾向于把字体大小、界面还有需要的插件等统一配置一下，这样在你以后使用这个编辑器的时候，编辑器便会默认载入这些配置，非常的方便。</p><p>Git中也有类似的机制。Git自带一个<code>git config</code>的工具来帮助设置控制Git外观和行为的配置变量，这些变量存储在三个不同的位置：</p><ol><li><code>etc/gitconfig</code>文件: 包含系统上每一个用户及他们仓库的通用配置。如果使用带有<code>--system</code>选项的<code>git config</code>时，它会从此文件读写配置变量。</li><li><code>~/.gitconfig</code>或<code>~/.config/git/config</code>文件：只针对当前用户。可以传递<code>--global</code>选项让Git读写此文件。</li><li>当前使用仓库的Git目录中的config文件（也就是<code>.git/config</code>）：针对该仓库。可以传递<code>--local</code>选项让Git读写此文件，但是其实这个选项是默认的，因此可以省略。</li></ol><p>每一个级别覆盖上一级别的配置，例如<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。</p><p>在Windows系统中，Git会查找<code>$HOME</code>目录下（一般情况下是 C:\Users\$USER）的<code>.gitconfig</code>文件。Git同样也会寻找<code>/etc/gitconfig</code>文件，但只限于MSys的根目录下，即安装Git时所选的目标位置。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>首先你需要设置自己的用户名称和邮箱，这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改（换句话说，不设置用户信息无法进行<code>git commit</code>操作）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;YingZiqiang&quot;</span><br><span class="line">$ git config --global user.email yingzq0116@163.com</span><br></pre></td></tr></table></figure><p>再次强调，如果使用了<code>--global</code>选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有<code>--global</code>选项的命令来配置。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>当Git需要你输入信息时会调用默认的文本编辑器。如果未配置，Git会使用操作系统默认的文本编辑器，通常是Vim。如果你想使用不同的文本编辑器，例如Emacs，可以这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global core.editor emacs</span><br></pre></td></tr></table></figure><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>如果想要检查你的配置，可以使用<code>git config --list</code>命令来列出所有Git当时能找到的配置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name&#x3D;YingZiqiang</span><br><span class="line">user.email&#x3D;88629850@qq.com</span><br><span class="line">push.default&#x3D;simple</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有时候会看到重复的变量名，因为Git可能会从多个配置文件中读取同一个配置变量。这种情况下，<strong>Git会使用它找到的每一个变量的最后一个配置</strong>。</p><p>可以通过输入<code>git config &lt;key&gt;</code>来检查Git的某一项配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">YingZiqiang</span><br></pre></td></tr></table></figure><p>如果你想确认某配置变量的最终决定权的来源，可以输入<code>git config --show-origin &lt;key&gt;</code>查询：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --show-origin user.name</span><br><span class="line">file:&#x2F;Users&#x2F;yingzq&#x2F;.gitconfigYingZiqiang</span><br></pre></td></tr></table></figure><h2 id="Git帮助"><a href="#Git帮助" class="headerlink" title="Git帮助"></a>Git帮助</h2><p>若你使用Git时需要获取帮助，有三种方法可以找到Git命令的使用手册：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure><p>例如，要想获得config命令的手册，执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help config</span><br></pre></td></tr></table></figure><p>另外，如果你不想查看一个Git命令完整的使用手册，仅仅是想要快速查看某些参数的用法，可以通过<code>-h</code>选项来获得一个更加简洁的帮助界面，例如查看<code>git add</code>命令的参数信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add -h</span><br></pre></td></tr></table></figure><blockquote><p>注：你可以随时随地可以使用这些命令而无需联网</p></blockquote><h2 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h2><p>有两种取得Git项目仓库的方法。第一种是在现有项目或目录下导入所有文件到Git中；第二种是从一个服务器克隆一个现有的Git仓库。</p><h3 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h3><p>如果你打算使用Git来对现有的项目进行管理，你只需要进入该项目目录并输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>该命令将创建一个名为<code>.git</code>的子目录，这个子目录含有你初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p><p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化Git仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。你可通过<code>git add</code>命令来实现对指定文件的跟踪，然后执行<code>git commit</code>提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add *.py</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m &#39;initial project version&#39;</span><br></pre></td></tr></table></figure><p>稍后会逐一解释每一条指令的意思。现在，你已经得到了一个实际维护（或者说是跟踪）着若干个文件的Git仓库。</p><h3 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h3><p>如果你想获得一份已经存在了的Git仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到<code>git clone</code>命令。</p><p>克隆仓库的命令格式是<code>git clone [url]</code>。比如，要克隆一个叫“TensorFlow-Examples”的库，可以用下面的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;aymericdamien&#x2F;TensorFlow-Examples</span><br></pre></td></tr></table></figure><p>这会在当前目录下创建一个名为“TensorFlow-Examples”的目录，并在这个目录下初始化一个<code>.git</code>文件夹，并从远程仓库拉取下所有数据放入<code>.git</code>文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的“TensorFlow-Examples”文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;aymericdamien&#x2F;TensorFlow-Examples my-tf-examples</span><br></pre></td></tr></table></figure><p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为“my-tf-examples”。</p><p>Git支持多种数据传输协议。上面的例子使用的是<code>https://</code>协议，不过你也可以使用<code>git://</code>协议或者使用例如<code>user@server:path/to/repo.git</code>的SSH传输协议。</p><blockquote><p>注：Git克隆的是该Git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。当你执行<code>git clone</code>命令的时候，默认配置下远程Git仓库中的每一个文件的每一个版本都将被拉取下来。</p></blockquote><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>现在我们手上有了一个真实项目的Git仓库，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p><p><strong>工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。</strong>已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p><div align=center><img src="http://image.yingzq.com/img/20190927165926.png" width="600" alt="文件的状态变化周期" /><p>图1：文件的状态变化周期</p></div><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>要查看哪些文件处于什么状态，可以用<code>git status</code>命令。如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则Git会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是“master”，这是默认的分支名。在这里不用担心不明白分支是什么，这一部分会在 <a href="/2019/10/13/git-branching/" title="Git的杀手锏：分支模型（上）">Git的杀手锏：分支模型（上）</a> 单独讲解。</p><p>如果在项目中创建一个新的<code>README</code>文件，如果之前并不存在这个文件，使用<code>git status</code>命令，你将看到一个新的未跟踪文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &#39;My Project&#39; &gt; README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>在状态报告中可以看到新建的<code>README</code>文件出现在“Untracked files”下面。未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。不过现在的例子中，我们确实想要跟踪管理README这个文件。</p><h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令<code>git add</code>开始跟踪一个文件。所以如果要跟踪<code>README</code>文件，运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure><p>此时再运行<code>git status</code>命令，会看到<code>README</code>文件已被跟踪，并处于暂存状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br></pre></td></tr></table></figure><p>只要在“Changes to be committed”这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用<code>git init</code>后就运行了<code>git add &lt;files&gt;</code>命令，开始跟踪当前目录下的文件。<strong><code>git add</code>命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</strong></p><h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>现在我们来修改一个已被跟踪的文件。如果你修改了一个名为<code>TINY.md</code>的已被跟踪的文件，然后运行<code>git status</code>命令，会看到下面内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>文件<code>TINY.md</code>出现在“Changes not staged for commit”这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行<code>git add</code>命令。<strong><code>git add</code>是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</strong> 现在让我们运行<code>git add</code>将<code>TINY.md</code>放到暂存区，然后再看看<code>git status</code>的输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。</p><p>这里再追加一个小问题，假设此时，你的<code>TINY.md</code>文件存在一些小瑕疵，于是你重新编辑该文件并存盘了，此时运行<code>git status</code>会发生什么呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>怎么回事？现在<code>TINY.md</code>文件同时出现在暂存区和非暂存区。这怎么可能呢？实际上Git只不过暂存了你运行<code>git add</code>命令时的版本，如果你现在提交，<code>TINY.md</code>的版本是你最后一次运行<code>git add</code>命令时的那个版本，而不是你运行<code>git commit</code>时，在工作目录中的当前版本。 所以，运行了<code>git add</code>之后又作了修订的文件，需要重新运行<code>git add</code>把最新版本重新暂存起来：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p><code>git status</code>命令的输出十分详细，但其用语有些繁琐。如果你使用<code>git status -s</code>命令或<code>git status --short</code>命令，你将得到一种更为紧凑的格式输出。运行<code>git status -s</code>，状态报告输出如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">A  README</span><br><span class="line">M  TINY.md</span><br></pre></td></tr></table></figure><p>新添加的未跟踪文件前面有<code>??</code>标记，新添加到暂存区中的文件前面有<code>A</code>标记，修改过的文件前面有<code>M</code>标记。<strong>其中<code>M</code>有两个可以出现的位置，出现在右边的<code>M</code>表示该文件被修改了但是还没放入暂存区，出现在靠左边的<code>M</code>表示该文件被修改了并放入了暂存区。</strong></p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为<code>.gitignore</code>的文件，列出要忽略的文件模式。来看一个实际的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure><p>第一行告诉Git忽略所有以“.o”或“.a”结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。第二行告诉Git忽略所有以波浪符（<code>~</code>）结尾的文件，许多文本编辑软件（比如Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略log，tmp或者pid目录，以及自动生成的文档等等。要养成一开始就设置好<code>.gitignore</code>文件的习惯，以免将来误提交这类无用的文件。</p><p>文件<code>.gitignore</code>的格式规范如下：</p><ul><li>所有空行或者以<code>#</code>开头的行都会被Git忽略。</li><li>可以使用标准的glob模式匹配，并且会在整个工作目录中递归的应用。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上感叹号（<code>!</code>）取反。</li></ul><p>所谓的glob模式是指所使用的简化了的正则表达式。星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code>匹配任何一个列在方括号中的字符（这个例子要么匹配一个a，要么匹配一个b，要么匹配一个c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如<code>[0-9]</code>表示匹配所有0到9的数字）。使用两个星号表示匹配任意中间目录，比如<code>a/**/z</code>可以匹配<code>a/z</code>,<code>a/b/z</code>或<code>a/b/c/z</code>等。</p><p>我们再看一个<code>.gitignore</code>文件的例子：</p><pre><code># no .a files*.a# but do track lib.a, even though you&apos;re ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf</code></pre><blockquote><p>GitHub有一个十分详细的针对数十种项目及语言的<code>.gitignore</code>文件列表，你可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> 找到它。</p></blockquote><h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p>如果<code>git status</code>命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用<code>git diff</code>命令。</p><p><strong>你可能通常会用<code>git diff</code>命令来回答这两个问题：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？</strong>尽管<code>git status</code>已经通过在相应栏下列出文件名的方式回答了这个问题，<code>git diff</code>将通过文件补丁的格式显示具体哪些行发生了改变。</p><p>假如此时你再次编辑<code>TINY.md</code>后不暂存，运行<code>git status</code>会看到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入<code>git diff</code>，<strong>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a&#x2F;TINY.md b&#x2F;TINY.md</span><br><span class="line">index 5818529..f0bfc69 100644</span><br><span class="line">--- a&#x2F;TINY.md</span><br><span class="line">+++ b&#x2F;TINY.md</span><br><span class="line">@@ -1,3 +1,3 @@</span><br><span class="line"> tiny data</span><br><span class="line"> modify this file, we add one new line</span><br><span class="line">-fix something</span><br><span class="line">+add one line for test</span><br></pre></td></tr></table></figure><p>若要查看已暂存的将要添加到下次提交里的内容，可以用<code>git diff --cached</code>命令（Git 1.6.1及更高版本还允许使用<code>git diff --staged</code>，效果是相同的，但更好记些），<strong>此命令是将目前已暂存的更改和上次提交的内容进行比较</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff --staged</span><br><span class="line">diff --git a&#x2F;README b&#x2F;README</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e69de29</span><br><span class="line">diff --git a&#x2F;TINY.md b&#x2F;TINY.md</span><br><span class="line">index f8f5ae1..5818529 100644</span><br><span class="line">--- a&#x2F;TINY.md</span><br><span class="line">+++ b&#x2F;TINY.md</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line"> tiny data</span><br><span class="line">+modify this file, we add one new line</span><br><span class="line">+fix something</span><br></pre></td></tr></table></figure><p>请注意，<code>git diff</code>本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。所以有时候你一下子暂存了所有更新过的文件后，运行<code>git diff</code>后却什么也没有，就是这个原因。</p><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>当你的暂存区域已经准备妥当便可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有<code>git add</code>过，否则提交的时候不会记录这些还没暂存起来的变化。这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用<code>git status</code>看下，是不是都已暂存起来了，然后再运行提交命令git commit：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>这种方式会启动默认的文本编辑器以便输入本次提交的说明，需要注意的是，如果输入的提交说明为空你的本次提交将会被中止。</p><p>更常用的方式是在<code>commit</code>命令后添加<code>-m</code>选项，将提交信息与命令放在同一行，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &#39;add README file and fix some bugs in TINY.md&#39;</span><br><span class="line">[master 10114de] add README file and fix some bugs in TINY.md</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><p>现在你已经创建了第一个提交！可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整SHA-1校验和是什么（10114de），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><p>请记住，<strong>提交时记录的是放在暂存区域的快照</strong>。任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给<code>git commit</code>加上<code>-a</code>选项，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过<code>git add</code>步骤：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line">$ git commit -a -m &#39;test the commit -a option&#39;</span><br><span class="line">[master 45f06e1] test the commit -a option</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>可以看到，提交之前不再需要<code>git add</code>文件<code>TINY.md</code>了。</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用<code>git rm</code>命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行<code>git status</code>时就会在“Changes not staged for commit”部分（也就是<strong>未暂存清单</strong>）看到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add&#x2F;rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    TINY.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>然后再运行<code>git rm</code>记录此次移除文件的操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">deleted:    TINY.md</span><br></pre></td></tr></table></figure><p>下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项<code>-f</code>（即force的首字母）。这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被Git恢复。</p><p>另外一种情况是，我们想把文件从暂存区域移除，但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，但是并不想让Git继续跟踪。当你忘记添加<code>.gitignore</code>文件，不小心把一个很大的日志文件或一堆<code>.a</code>这样的编译生成文件添加到暂存区时，这一做法尤其有用。为达到这一目的，使用<code>--cached</code>选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm --cached README</span><br></pre></td></tr></table></figure><p><code>git rm</code>命令后面可以列出文件或者目录的名字，也可以使用glob模式。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm log&#x2F;\*.log</span><br></pre></td></tr></table></figure><p>注意到星号<code>*</code>之前的反斜杠<code>\</code>，这是非常有必要的，<strong>因为除了拥有shell的文件模式扩展匹配方式，Git还有它自己的文件模式扩展匹配方式。</strong> 此命令会删除<code>log/</code>目录及其子目录下扩展名为<code>.log</code>的所有文件。</p><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>不像其它的VCS系统，Git并不显式跟踪文件移动操作。如果在Git中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过Git非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，可以放到以后再详细了解。</p><p>要在Git中对文件改名，可以这么做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure><p>此时查看状态信息，可以明白无误地看到关于重命名操作的说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git mv TINY.md MY-TOY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">renamed:    TINY.md -&gt; MY-TOY.md</span><br></pre></td></tr></table></figure><p>其实，运行<code>git mv</code>就相当于运行了下面三条命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mv TINY.md MY-TOY.md</span><br><span class="line">$ git rm TINY.md</span><br><span class="line">$ git add MY-TOY.md</span><br></pre></td></tr></table></figure><p>如此分开操作，Git也会意识到这是一次改名，所以不管何种方式结果都一样，但是<code>git mv</code>一个命令代替了第二种方式的三个命令，更加的轻便。<strong>更进一步，你可以使用任何你熟悉的工具来重命名文件，然后只需要记得在提交前，删除老的文件名并添加新的文件名。</strong></p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。完成这个任务最简单而又有效的工具是<code>git log</code>命令。</p><p>首先运行下面的命令获取用于演示的simplegit项目的源代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit-progit</span><br></pre></td></tr></table></figure><p>然后在此项目中运行<code>git log</code>，应该会看到下面的输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><p>默认不用任何参数的话，<code>git log</code>会按提交时间列出所有的更新，最近的更新排在最上面。正如你所看到的，这个命令会列出每个提交的SHA-1校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p><code>git log</code>有许多选项可以帮助你搜寻你所要找的提交， 接下来我们先来了解一些最常用的选项。</p><p>一个常用的选项是<code>-p</code>或者说是<code>--patch</code>，用来显示每次提交的内容差异（the patch output）。你也可以限制展示的提交条目数，例如可以加上<code>-2</code>来仅显示最近两次提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log -p -2</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">diff --git a&#x2F;Rakefile b&#x2F;Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a&#x2F;Rakefile</span><br><span class="line">+++ b&#x2F;Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require &#39;rake&#x2F;gempackagetask&#39;</span><br><span class="line"> spec &#x3D; Gem::Specification.new do |s|</span><br><span class="line">     s.platform  &#x3D;   Gem::Platform::RUBY</span><br><span class="line">     s.name      &#x3D;   &quot;simplegit&quot;</span><br><span class="line">-    s.version   &#x3D;   &quot;0.1.0&quot;</span><br><span class="line">+    s.version   &#x3D;   &quot;0.1.1&quot;</span><br><span class="line">     s.author    &#x3D;   &quot;Scott Chacon&quot;</span><br><span class="line">     s.email     &#x3D;   &quot;schacon@gmail.com&quot;</span><br><span class="line">     s.summary   &#x3D;   &quot;A simple gem for using Git in Ruby code.&quot;</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">diff --git a&#x2F;lib&#x2F;simplegit.rb b&#x2F;lib&#x2F;simplegit.rb</span><br><span class="line">index a0a60ae..47c6340 100644</span><br><span class="line">--- a&#x2F;lib&#x2F;simplegit.rb</span><br><span class="line">+++ b&#x2F;lib&#x2F;simplegit.rb</span><br><span class="line">@@ -18,8 +18,3 @@ class SimpleGit</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line">-</span><br><span class="line">-if $0 &#x3D;&#x3D; __FILE__</span><br><span class="line">-  git &#x3D; SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-end</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>该选项除了显示基本信息之外，还附带了每次<code>commit</code>的变化。当进行代码审查，或者快速浏览某个搭档提交的<code>commit</code>所带来的变化的时候，这个参数就非常有用了。你也可以为<code>git log</code>附带一系列的总结性选项。比如说，如果你想看到每次提交的简略的统计信息，你可以使用<code>--stat</code>选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --stat</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line"> lib&#x2F;simplegit.rb | 5 -----</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |  6 ++++++</span><br><span class="line"> Rakefile         | 23 +++++++++++++++++++++++</span><br><span class="line"> lib&#x2F;simplegit.rb | 25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+)</span><br></pre></td></tr></table></figure><p>正如你所看到的，<code>--stat</code>选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。在每次提交的最后还有一个总结。</p><p>另外一个常用的选项是<code>--pretty</code>。这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用。比如用<code>oneline</code>将每个提交放在一行显示，查看的提交数很大时非常有用。</p><p><code>git log</code>还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。例如之前看到的<code>-2</code>其实是<code>-&lt;n&gt;</code>选项的写法，其中的n可以是任何整数，表示仅显示最近的若干条提交；另外还有按照时间作限制的选项，比如<code>--since</code>和<code>--until</code>也很有用，还可以给出若干搜索条件，列出符合的提交…</p><p><code>git log</code>的选项非常多，在这里不再一一介绍。总之，<code>git log</code>是一个功能非常齐全、可定制化程度非常高的、能满足你几乎所有查询方式的查看提交历史的命令。</p><h2 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h2><p>在任何一个阶段，你都有可能想要撤消某些操作。这里，我们将会学习几个撤消你所做修改的基本工具。<strong>注意，有些撤消操作是不可逆的，这是在使用Git的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</strong></p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有<code>--amend</code>选项的提交命令尝试重新提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>这个命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p><p>运行该命令后会启动文本编辑器，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &#39;initial commit&#39;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><p>接下来再来学习一下如何操作暂存区域与工作目录中已修改的文件。这些命令在修改文件状态的同时，也会提示如何撤消操作。</p><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>如果你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了<code>git add *</code>暂存了它们两个。如何只取消暂存两个中的一个呢？<code>git status</code>命令提示了你：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README</span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>在“Changes to be committed”文字正下方，提示使用<code>git reset HEAD &lt;file&gt;...</code>来取消暂存。所以，我们可以这样来取消暂存<code>TINY.md</code>文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD TINY.md</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>可以看到<code>TINY.md</code>文件已经是修改未暂存的状态了。</p><h3 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h3><p>如果你并不想保留对<code>TINY.md</code>文件的修改怎么办？你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？幸运的是，<code>git status</code>也告诉了你应该如何做。在最后一个例子中，未暂存区域是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>它非常清楚地告诉了你如何撤消之前所做的修改。让我们来按照提示执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README</span><br></pre></td></tr></table></figure><p>可以看到关于<code>TINY.md</code>的修改已经被撤消了。</p><blockquote><p>请记住，在Git中任何<strong>已提交的</strong>东西几乎总是可以恢复的。甚至那些被删除的分支中的提交或使用<code>--amend</code>选项覆盖的提交也可以恢复。然而，任何你<strong>未提交的</strong>东西丢失后很可能再也找不到了。</p></blockquote><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>为了能在任意Git项目上协作，你需要知道如何管理自己的远程仓库。<strong>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。</strong> 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。在本章节中，将介绍一部分基础的远程管理技能。</p><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行<code>git remote</code>命令。它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到<code>origin</code>，这是Git给你克隆的仓库服务器的默认名字</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit</span><br><span class="line">Cloning into &#39;ticgit&#39;...</span><br><span class="line">remote: Enumerating objects: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0), pack-reused 1857</span><br><span class="line">Receiving objects: 100% (1857&#x2F;1857), 334.04 KiB | 36.00 KiB&#x2F;s, done.</span><br><span class="line">Resolving deltas: 100% (837&#x2F;837), done.</span><br><span class="line">$ cd ticgit</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>你也可以指定选项<code>-v</code>，会显示需要读写远程仓库使用的Git保存的简写与其对应的URL。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">originhttps:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (fetch)</span><br><span class="line">originhttps:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (push)</span><br></pre></td></tr></table></figure><p>如果你的远程仓库不止一个，该命令会将它们全部列出。例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd grit</span><br><span class="line">$ git remote -v</span><br><span class="line">bakkdoor  https:&#x2F;&#x2F;github.com&#x2F;bakkdoor&#x2F;grit (fetch)</span><br><span class="line">bakkdoor  https:&#x2F;&#x2F;github.com&#x2F;bakkdoor&#x2F;grit (push)</span><br><span class="line">cho45     https:&#x2F;&#x2F;github.com&#x2F;cho45&#x2F;grit (fetch)</span><br><span class="line">cho45     https:&#x2F;&#x2F;github.com&#x2F;cho45&#x2F;grit (push)</span><br><span class="line">defunkt   https:&#x2F;&#x2F;github.com&#x2F;defunkt&#x2F;grit (fetch)</span><br><span class="line">defunkt   https:&#x2F;&#x2F;github.com&#x2F;defunkt&#x2F;grit (push)</span><br><span class="line">koke      git:&#x2F;&#x2F;github.com&#x2F;koke&#x2F;grit.git (fetch)</span><br><span class="line">koke      git:&#x2F;&#x2F;github.com&#x2F;koke&#x2F;grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo&#x2F;grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo&#x2F;grit.git (push)</span><br></pre></td></tr></table></figure><p>这样我们可以轻松拉取其中任何一个用户的贡献。此外，我们有可能还会有某些远程仓库的推送权限，不过暂时不在此介绍。</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>运行<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加一个新的远程Git仓库，同时指定一个你可以轻松引用的简写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit</span><br><span class="line">$ git remote -v</span><br><span class="line">originhttps:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (fetch)</span><br><span class="line">originhttps:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (push)</span><br><span class="line">pbhttps:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit (fetch)</span><br><span class="line">pbhttps:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit (push)</span><br></pre></td></tr></table></figure><p>现在你可以在命令行中使用字符串<code>pb</code>来代替整个URL。例如，如果你想拉取Paul的仓库中有但你没有的信息，可以运行<code>git fetch pb</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch pb</span><br><span class="line">remote: Enumerating objects: 22, done.</span><br><span class="line">remote: Counting objects: 100% (22&#x2F;22), done.</span><br><span class="line">remote: Total 43 (delta 22), reused 22 (delta 22), pack-reused 21</span><br><span class="line">Unpacking objects: 100% (43&#x2F;43), done.</span><br><span class="line">From https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb&#x2F;master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb&#x2F;ticgit</span><br></pre></td></tr></table></figure><p>现在Paul的master分支可以在本地通过<code>pb/master</code>访问到——你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。</p><blockquote><p>关于什么是分支以及如何使用分支将会在 <a href="/2019/10/13/git-branching/" title="Git的杀手锏：分支模型（上）">Git的杀手锏：分支模型（上）</a> 中详细介绍</p></blockquote><h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>就如刚才所见，从远程仓库中获得数据，可以执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用<code>clone</code>命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以“origin”为简写。所以，<code>git fetch origin</code>会抓取克隆（或上一次抓取）后新推送的所有工作。<strong>必须注意<code>git fetch</code>命令会将数据拉取到你的本地仓库，但是它并不会自动合并或修改你当前的工作。</strong> 当准备好时你必须手动将其合并入你的工作。</p><p>如果你有一个分支设置为跟踪一个远程分支，可以使用<code>git pull</code>命令来自动的抓取然后合并远程分支到当前分支。这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code>命令会自动设置本地master分支跟踪克隆的远程仓库的master分支（或不管是什么名字的默认分支）。运行<code>git pull</code>通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。这个命令很简单：<code>git push [remote-name] [branch-name]</code>。当你想要将master分支推送到<code>origin</code>服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。阅读 <a href="/2019/10/13/git-branching/" title="Git的杀手锏：分支模型（上）">Git的杀手锏：分支模型（上）</a> 了解如何推送到远程仓库服务器的详细信息。</p><h3 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用<code>git remote show [remote-name]</code>命令。如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit</span><br><span class="line">  Push  URL: https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master tracked</span><br><span class="line">    ticgit tracked</span><br><span class="line">  Local branch configured for &#39;git pull&#39;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#39;git push&#39;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure><p>它同样会列出远程仓库的URL与跟踪分支的信息。这些信息非常有用，它告诉你正处于master分支，并且如果运行<code>git pull</code>，就会抓取所有的远程引用，然后将远程master分支合并到本地master分支。它也会列出拉取到的所有远程引用。</p><p>这是一个经常遇到的简单例子。如果你是Git的重度使用者，那么还可以通过<code>git remote show</code>看到更多的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  URL: https:&#x2F;&#x2F;github.com&#x2F;my-org&#x2F;complex-project</span><br><span class="line">  Fetch URL: https:&#x2F;&#x2F;github.com&#x2F;my-org&#x2F;complex-project</span><br><span class="line">  Push  URL: https:&#x2F;&#x2F;github.com&#x2F;my-org&#x2F;complex-project</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                           tracked</span><br><span class="line">    dev-branch                       tracked</span><br><span class="line">    markdown-strip                   tracked</span><br><span class="line">    issue-43                         new (next fetch will store in remotes&#x2F;origin)</span><br><span class="line">    issue-45                         new (next fetch will store in remotes&#x2F;origin)</span><br><span class="line">    refs&#x2F;remotes&#x2F;origin&#x2F;issue-11     stale (use &#39;git remote prune&#39; to remove)</span><br><span class="line">  Local branches configured for &#39;git pull&#39;:</span><br><span class="line">    dev-branch merges with remote dev-branch</span><br><span class="line">    master     merges with remote master</span><br><span class="line">  Local refs configured for &#39;git push&#39;:</span><br><span class="line">    dev-branch                     pushes to dev-branch                     (up to date)</span><br><span class="line">    markdown-strip                 pushes to markdown-strip                 (up to date)</span><br><span class="line">    master                         pushes to master                         (up to date)</span><br></pre></td></tr></table></figure><p>这个命令列出了当你在特定的分支上执行<code>git push</code>会自动地推送到哪一个远程分支。它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行<code>git pull</code>时哪些分支会自动合并。</p><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>如果想要重命名引用的名字可以运行<code>git remote rename</code>去修改一个远程仓库的简写名。例如，想要将<code>pb</code>重命名为<code>paul</code>，可以用<code>git remote rename</code>这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>值得注意的是这同样也会修改你的远程分支名字。那些过去引用<code>pb/master</code>的现在会引用<code>paul/master</code>。</p><p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用<code>git remote rm</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>像其他版本控制系统（VCS）一样，Git可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。在本章节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。</p><h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p>在Git中列出已有的标签是非常简单直观的。只需要输入<code>git tag</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br></pre></td></tr></table></figure><p>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。</p><p>你也可以使用特定的模式查找标签。例如，Git自身的源代码仓库包含标签的数量超过500个。如果只对1.8.5系列感兴趣，可以运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -l &#39;v1.8.5*&#39;</span><br><span class="line">v1.8.5</span><br><span class="line">v1.8.5-rc0</span><br><span class="line">v1.8.5-rc1</span><br><span class="line">v1.8.5-rc2</span><br><span class="line">v1.8.5-rc3</span><br><span class="line">v1.8.5.1</span><br><span class="line">v1.8.5.2</span><br><span class="line">v1.8.5.3</span><br><span class="line">v1.8.5.4</span><br><span class="line">v1.8.5.5</span><br></pre></td></tr></table></figure><blockquote><p>注：如果你只是想要列出全部的标签，<code>-l</code>或者<code>--list</code>选项可以省略；但是如果是希望用特定的模式查找标签，<code>-l</code>或<code>--list</code>选项则是必须的</p></blockquote><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。</p><p>然而，附注标签是存储在Git数据库中的一个完整对象。它们是可以被校验的：其中包含打标签者的名字、电子邮件地址、日期时间，还有一个标签信息，并且可以使用GNU Privacy Guard （GPG）签名与验证。<strong>通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</strong></p><h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>在Git中创建一个附注标签是很简单的。最简单的方式是当你在运行<code>tag</code>命令时指定<code>-a</code>选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.4 -m &quot;my version 1.4&quot;</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure><p><code>-m</code>选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会运行编辑器要求你输入信息。</p><p>通过使用<code>git show</code>命令可以看到标签信息与对应的提交信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git show v1.4</span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>另一种给提交打标签的方式是使用轻量标签。<strong>轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。</strong> 创建轻量标签，不需要使用<code>-a</code>、<code>-s</code>或<code>-m</code>选项，只需要提供标签名字：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag v1.4-lw</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure><p>这时，如果在标签上运行<code>git show</code>，你不会看到额外的标签信息。命令只会显示出提交信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git show v1.4-lw</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><p>你也可以对过去的提交打标签。假设提交历史是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty&#x3D;oneline</span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#39;experiment&#39;</span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#39;experiment&#39;</span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></td></tr></table></figure><p>现在，假设在v1.2时你忘记给项目打标签，也就是在“updated rakefile”提交。你可以在之后补上标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.2 9fceb02</span><br></pre></td></tr></table></figure><h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>默认情况下，<code>git push</code>命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样——你可以运行<code>git push origin [tagname]</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.5</span><br><span class="line">Counting objects: 14, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12&#x2F;12), done.</span><br><span class="line">Writing objects: 100% (14&#x2F;14), 2.05 KiB | 0 bytes&#x2F;s, done.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon&#x2F;simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure><p>如果想要一次性推送很多标签，也可以使用带有<code>--tags</code>选项的<code>git push</code>命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1&#x2F;1), 160 bytes | 0 bytes&#x2F;s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon&#x2F;simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure><p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>要删除掉你本地仓库上的标签，可以使用命令<code>git tag -d &lt;tagname&gt;</code>。例如，可以使用下面的命令删除掉一个轻量级标签：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -d v1.4-lw</span><br><span class="line">Deleted tag &#39;v1.4-lw&#39; (was e7d5add)</span><br></pre></td></tr></table></figure><p><strong>应该注意的是上述命令并不会从任何远程仓库中移除这个标签</strong>，有两种方式可以从远程仓库中删除标签。</p><p>第一种方式是使用<code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code>来更新你的远程仓库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin :refs&#x2F;tags&#x2F;v1.4-lw</span><br><span class="line">To &#x2F;git@github.com:schacon&#x2F;simplegit.git</span><br><span class="line"> - [deleted]         v1.4-lw</span><br></pre></td></tr></table></figure><p>第二种删除远程仓库标签的方式更加直观：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用<code>git checkout</code>命令。但是这会使你的仓库处于“分离头指针（detacthed HEAD）”状态，这个状态有些不好的副作用：如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。</p><p>因此，如果你需要进行更改，比如说你正在修复旧版本的错误，这通常需要创建一个新分支来进行操作。</p><h2 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h2><p>有一个小技巧可以使你的Git体验更简单、容易、熟悉：<strong>别名</strong></p><p>Git并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的Git命令，可以通过<code>git config</code>来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>这意味着，当要输入<code>git commit</code>时，只需要输入<code>git ci</code>。随着你继续不断地使用Git，可能也会经常使用其他命令，此时不要犹豫，为它创建一个别名吧。</p><p>在创建你认为应该存在的命令时这个技术也会很有用。例如，为了解决取消暂存文件的易用性问题，可以向Git中添加你自己的取消暂存别名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.unstage &#39;reset HEAD --&#39;</span><br></pre></td></tr></table></figure><p>这会使下面的两个命令等价：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git unstage fileA</span><br><span class="line">$ git reset HEAD -- fileA</span><br></pre></td></tr></table></figure><p>这样看起来更清楚一些。通常也会添加一个<code>last</code>命令，像这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.last &#39;log -1 HEAD&#39;</span><br></pre></td></tr></table></figure><p>这样，可以轻松地看到最后一次提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit 66938dae3329c7aebe598c2246a8e6af90d04646</span><br><span class="line">Author: Josh Goebel &lt;dreamer3@example.com&gt;</span><br><span class="line">Date:   Tue Aug 26 19:48:51 2008 +0800</span><br><span class="line"></span><br><span class="line">    test for current head</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</span><br></pre></td></tr></table></figure><p>可以看出，Git只是简单地将别名替换为对应的命令。然而，你可能想要执行外部命令，而不是一个Git子命令。如果是那样的话，可以在命令前面加入!符号。如果你自己要写一些与Git仓库协作的工具的话，那会很有用。例如将<code>git visual</code>定义为<code>gitk</code>的别名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.visual &#39;!gitk&#39;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍的Git的内容的确不少，但是这些都是你学习Git务必要掌握的基础。随着你对Git的使用越来越多，你会发现Git的每一个命令都是精简而高效的，他们使得你对文件版本控制变得异常方便快捷。</p><p>Just do it!</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git Book</a></li><li><a href="https://git-scm.com/docs" target="_blank" rel="noopener">Git Documents</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是目前最流行的分布式版本控制系统，值得我们去学会使用并深入了解。本文将会介绍几个最基本的，也是最常用的命令，以后绝大多数时间里用到的可能也就是这几个命令，主要涉及Git的配置、Git仓库的获取、如何记录每次更新到Git仓库、提交历史的查看、Git的撤销操作、Git标签和Git别名等基础知识点，这些是你务必掌握的Git基础！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.yingzq.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.yingzq.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>What is Git</title>
    <link href="http://www.yingzq.com/2019/09/18/what-is-git/"/>
    <id>http://www.yingzq.com/2019/09/18/what-is-git/</id>
    <published>2019-09-18T14:19:30.000Z</published>
    <updated>2020-02-19T17:39:44.802Z</updated>
    
    <content type="html"><![CDATA[<p>相信写过代码的程序猿们都听说过Git的大名，哪怕是刚刚入门的小白，也在GitHub等代码托管网站<code>git clone</code>过他人的代码。那么什么是Git呢？本文将为你讲述Git的前世往生，看完本文，你应该会对版本控制、Git的诞生、Git基本概念和Git的基本特性有了一个初步的认识。</p><a id="more"></a><blockquote><p>注：本文只包含了Git的相关概念，不包含任何命令行代码。</p></blockquote><h2 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a>关于版本控制</h2><p>首先来了解一下什么是“版本控制”：<strong>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</strong>一般情况下是针对程序的源代码文件进行版本控制，但实际上你可以对任何类型的文件进行版本控制。</p><h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。</p><p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异（见图1）。</p><div align=center><img src="http://image.yingzq.com/img/20190919170521.png" width="350" alt="本地版本控制系统" /><p>图1：本地版本控制系统</p></div><p>其中最流行的一种叫做<a href="http://www.gnu.org/software/rcs/" target="_blank" rel="noopener">RCS</a>（Revision Control System），现今许多计算机系统上都还看得到它的踪影。甚至在流行的Mac OS X系统上安装了开发者工具包之后，也可以使用<code>rcs</code>命令。它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，便可以重新计算出各个版本的文件内容。</p><h3 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h3><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作呢？于是，集中化的版本控制系统（Centralized Version Control Systems，简称CVCS）应运而生。</p><p>这类系统，诸如CVS、Subversion以及Perforce等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法（见图2）。</p><div align=center><img src="http://image.yingzq.com/img/20190919215217.png" width="350" alt="集中化的版本控制系统" /><p>图2：集中化的版本控制系统</p></div><p>这种做法带来了许多好处，特别是相较于老式的本地VCS来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个CVCS要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p><h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>为了解决上述版本控制系统存在的问题，分布式版本控制系统（Distributed Version Control System，简称DVCS）诞生了。</p><p>在这类系统中，像Git、Mercurial、Bazaar以及Darcs等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份（见图3）。</p><div align=center><img src="http://image.yingzq.com/img/20190920092302.png" width="400" alt="分布式版本控制系统" /><p>图3：分布式版本控制系统</p></div><p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p><blockquote><p>小结：可以看出分布式版本控制系统相比于本地版本控制和集中化的版本控制有着非常明显的优点。<strong>Git就是一个典型的分布式版本控制系统（DVCS）。</strong></p></blockquote><h2 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h2><p>同生活中的许多伟大事物一样，Git诞生于一个极富纷争大举创新的年代。</p><p>1991年，22岁芬兰程序员Linus Torvalds（后文简称Linus）开源了Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><div align=center><img src="http://image.yingzq.com/img/20190921191553.png" width="400" alt="Linus" /><p>图4：Linus Torvalds</p></div><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p><p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p><p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。<br>实际情况是这样的：<strong>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！</strong>一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p><blockquote><p>小节：Linux的诞生是因为当时还是大学生的Linus觉得好玩编写并开源的；而Git的诞生则是因为Linux社区刚好需要，所以Linus花了两周简单写了一下并开源的，可能这就是大佬吧…</p></blockquote><h2 id="Git的基本特性"><a href="#Git的基本特性" class="headerlink" title="Git的基本特性"></a>Git的基本特性</h2><p>我们已经知道Git是一种分布式版本控制系统，那么Git与其他的版本控制系统的差异是什么？自身的的特性又是什么呢？</p><h3 id="Git直接记录快照，而非差异比较"><a href="#Git直接记录快照，而非差异比较" class="headerlink" title="Git直接记录快照，而非差异比较"></a>Git直接记录快照，而非差异比较</h3><p>Git和其它版本控制系统（包括Subversion和近似工具）的主要差别在于Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（CVS、Subversion、Perforce、Bazaar等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异（见图5）。</p><div align=center><img src="http://image.yingzq.com/img/20190921212012.png" width="600" alt="存储每个文件与初始版本的差异" /><p>图5：存储每个文件与初始版本的差异</p></div><p>Git不按照以上方式对待或保存数据。反之，Git更像是把数据看作是对小型文件系统的一组快照（snapshot）。每次你提交更新，或在Git中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git不再重新存储该文件，而是只保留一个链接指向之前存储的文件（见图6）。Git对待数据更像是一个<strong>快照流</strong>。</p><div align=center><img src="http://image.yingzq.com/img/20191201185525.png" width="600" alt="存储项目随时间改变的快照" /><p>图6：存储项目随时间改变的快照</p></div><p>这是Git与几乎所有其它版本控制系统的重要区别。<strong>Git更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的VCS。</strong>如果你刚刚接触VCS和Git，可能对这句话感触并不深，但是随着你对Git的了解越来越深入，例如在研究Git分支的管理时，会发现这种方式对待数据所能获得的巨大益处。</p><h3 id="Git近乎所有操作都是本地执行"><a href="#Git近乎所有操作都是本地执行" class="headerlink" title="Git近乎所有操作都是本地执行"></a>Git近乎所有操作都是本地执行</h3><p>在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git在这方面会让你感到速度之神赐给了Git超凡的能量。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。</p><p>举个例子，要浏览项目的历史，Git不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><p>这也意味着你离线或者没有VPN时，几乎可以进行任何操作。如你在飞机或火车上想做些工作，你能愉快地提交，直到有网络连接时再上传。如你回家后VPN客户端不正常，你仍能工作。使用其它系统，做到如此是不可能或很费力的。比如，用Perforce，你没有连接服务器时几乎不能做什么事；用Subversion和CVS，你能修改文件，但不能向数据库提交修改（因为你的本地数据库离线了）。这看起来不是大问题，但是你可能会惊喜地发现它带来的巨大的不同。</p><h3 id="Git保证完整性"><a href="#Git保证完整性" class="headerlink" title="Git保证完整性"></a>Git保证完整性</h3><p>Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。这个功能建构在Git底层，是构成Git哲学不可或缺的部分。若你在传送过程中丢失信息或损坏文件，Git就能发现。</p><p>Git用以计算校验和的机制叫做<code>SHA-1</code>散列。这是一个由40个十六进制字符（0-9和a-f）组成的字符串，基于Git中文件的内容或目录结构计算出来。SHA-1哈希看起来是这样：</p><pre><code>24b9da6552252987aa493b52f8696cd6d3b00373</code></pre><h3 id="Git一般只添加数据"><a href="#Git一般只添加数据" class="headerlink" title="Git一般只添加数据"></a>Git一般只添加数据</h3><p>你执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。同别的VCS一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到Git中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><h3 id="Git文件有三种状态"><a href="#Git文件有三种状态" class="headerlink" title="Git文件有三种状态"></a>Git文件有三种状态</h3><p>请注意，如果你希望后面的学习过程更加顺利，这里将是关于Git你最需要记住的一点——<strong>对于任何一个文件，在Git内都只有三种状态：已修改（modified），已暂存（staged）和已提交（committed）。</strong></p><ul><li>已修改表示修改了文件，但还没保存到数据库中</li><li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li><li>已提交表示数据已经安全的保存在本地数据库中</li></ul><p>由此引入Git项目的三个工作区域的概念：工作目录、暂存区域以及Git仓库。</p><div align=center><img src="http://image.yingzq.com/img/20190923011749.png" width="550" alt="工作目录、暂存区域以及Git仓库" /><p>图7：工作目录、暂存区域以及Git仓库</p></div><p>工作目录是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。</p><p>Git仓库目录是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p><p>基本的Git工作流程如下：</p><ol><li>在工作目录中修改文件</li><li>暂存文件，将文件的快照放入暂存区域</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录</li></ol><p>如果Git目录中保存着特定版本的文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你应该已经对Git是什么、Git与你可能正在使用的集中式版本控制系统有何区别等问题有了基本的了解。对于Git的特性，本文也只是简单提及，它的分支管理、代码合并等功能更让人欲罢不能。如今Git已经成为了最流行的开源分布式版本控制系统，它值得你去深入探索研究!</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git Book</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰 Git教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信写过代码的程序猿们都听说过Git的大名，哪怕是刚刚入门的小白，也在GitHub等代码托管网站&lt;code&gt;git clone&lt;/code&gt;过他人的代码。那么什么是Git呢？本文将为你讲述Git的前世往生，看完本文，你应该会对版本控制、Git的诞生、Git基本概念和Git的基本特性有了一个初步的认识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.yingzq.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.yingzq.com/tags/Git/"/>
    
  </entry>
  
</feed>
