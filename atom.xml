<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yingzq&#39;s Blog</title>
  
  <subtitle>练习bug时长两年半的实习生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yingzq.com/"/>
  <updated>2019-10-22T09:25:03.615Z</updated>
  <id>http://www.yingzq.com/</id>
  
  <author>
    <name>应子强</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git的杀手锏：分支模型（下）</title>
    <link href="http://www.yingzq.com/2019/10/16/git-branching-part-two/"/>
    <id>http://www.yingzq.com/2019/10/16/git-branching-part-two/</id>
    <published>2019-10-16T05:12:25.000Z</published>
    <updated>2019-10-22T09:25:03.615Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="/2019/10/13/git-branching/" title="Git的杀手锏：分支模型（上）">Git的杀手锏：分支模型（上）</a>中，我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作。在本章我们继续来学习Git分支的工作流、远程分支和变基等内容。</p><a id="more"></a><h2 id="Git分支开发工作流"><a href="#Git分支开发工作流" class="headerlink" title="Git分支开发工作流"></a>Git分支开发工作流</h2><p>现在我们已经学会新建和合并分支，那么可以或者应该用它来做些什么呢？本节会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出这些典型的工作模式。</p><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>因为Git使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p><p>许多使用Git的开发者都喜欢使用这种方式来工作，比如只在<code>master</code>分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。他们还有一些名为<code>develop</code>或者<code>next</code>的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入<code>master</code>分支了。这样，在确保这些已完成的特性分支（短期分支，比如之前的<code>iss53</code>分支）能够通过所有测试，并且不会引入更多bug之后，就可以合并入主干分支中，等待下一次的发布。</p><p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p><div align="center"><img src="http://image.yingzq.com/img/20191021224943.png" width="800" alt="渐进稳定分支的线性图"><p>图1：渐进稳定分支的线性图</p></div><p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p><div align="center"><img src="http://image.yingzq.com/img/20191021225228.png" width="800" alt="渐进稳定分支的流水线视图"><p>图2：渐进稳定分支的流水线视图</p></div><p>你可以用这种方法维护不同层次的稳定性。一些大型项目还有一个<code>proposed</code>（建议）或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入<code>next</code>或者<code>master</code>分支。这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。<strong>再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</strong></p><h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p>特性分支对任何规模的项目都适用。特性分支是一种短期分支，它被用来实现单一特性或其相关工作。也许你从来没有在其他的版本控制系统上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。然而，在Git中一天之内多次创建、使用、合并、删除分支都很常见。</p><p>你已经在前文中创建的<code>iss53</code>和<code>hotfix</code>特性分支中看到过这种用法。你在特性分支（<code>iss53</code>和<code>hotfix</code>分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。<strong>这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。</strong> 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p><p>考虑这样一个例子，你在<code>master</code>分支上工作到<code>C1</code>，这时为了解决一个问题而新建<code>iss91</code>分支，在<code>iss91</code>分支上工作到<code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个<code>iss91v2</code>分支试图用另一种方法解决那个问题，接着你回到<code>master</code>分支工作了一会儿，你又冒出了一个不太确定的想法，你便在<code>C10</code>的时候新建一个<code>dumbidea</code>分支，并在上面做些实验。你的提交历史看起来像下面这个样子：</p><div align="center"><img src="http://image.yingzq.com/img/20191021232901.png" width="800" alt="拥有多个特性分支的提交历史"><p>图3：拥有多个特性分支的提交历史</p></div><p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在<code>iss91v2</code>分支中方案；另外，你将<code>dumbidea</code>分支拿给你的同事看过之后，结果发现这是个惊人之举。这时你可以抛弃<code>iss91</code>分支（即丢弃<code>C5</code>和<code>C6</code>提交），然后把另外两个分支合并入主干分支。最终你的提交历史看起来像下面这个样子：</p><div align="center"><img src="http://image.yingzq.com/img/20191021233532.png" width="800" alt="合并了dumbidea和iss91v2分支之后的提交历史"><p>图4：合并了dumbidea和iss91v2分支之后的提交历史</p></div><blockquote><p>更多有关分支工作流的细节可以参考 <a href="https://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows#ch05-distributed-git" target="_blank" rel="noopener">Distributed Workflows</a></p></blockquote><p>最后请牢记，当你做这么多操作的时候，这些分支全部都存于本地。当你新建和合并分支的时候，所有这一切都只发生在你本地的Git版本库中，没有与服务器发生交互。</p><h2 id="Git远程分支"><a href="#Git远程分支" class="headerlink" title="Git远程分支"></a>Git远程分支</h2><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。你可以通过<code>git ls-remote [remote]</code>来显式地获得远程引用的完整列表，或者通过<code>git remote show [remote]</code>获得远程分支的更多信息。然而，一个更常见的做法是利用远程跟踪分支。</p><p>远程跟踪分支是远程分支状态的引用。它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p><p>它们以<code>&lt;remote&gt;/&lt;branch&gt;</code>形式命名。例如，如果你想要看你最后一次与远程仓库<code>origin</code>通信时<code>master</code>分支的状态，你可以查看<code>origin/master</code>分支。你与同事合作解决一个问题并且他们推送了一个<code>iss53</code>分支，你可能有自己的本地<code>iss53</code>分支；但是在服务器上的分支会指向<code>origin/iss53</code>的提交。</p><p>这可能有一点儿难以理解，让我们来看一个例子。假设你的网络里有一个在<code>git.ourcompany.com</code>的Git服务器。如果你从这里克隆，Git的<code>clone</code>命令会为你自动将其命名为<code>origin</code>，拉取它的所有数据，创建一个指向它的<code>master</code>分支的指针，并且在本地将其命名为<code>origin/master</code>。Git也会给你一个与<code>origin</code>的<code>master</code>分支在指向同一个地方的本地<code>master</code>分支，这样你就有工作的基础。</p><blockquote><p><strong>注意：“origin” 并无特殊含义</strong><br>远程仓库名字 “origin” 与分支名字 “master” 一样，在Git中并没有任何特别的含义一样。同时 “master” 是当你运行<code>git init</code>时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行<code>git clone</code>时默认的远程仓库名字。如果你运行<code>git clone -o booyah</code>，那么你默认的远程分支名字将会是<code>booyah/master</code>。</p></blockquote><div align="center"><img src="http://image.yingzq.com/img/20191022002503.png" width="750" alt="克隆之后的服务器与本地仓库"><p>图5：克隆之后的服务器与本地仓库</p></div><p>如果你在本地的<code>master</code>分支做了一些工作，与此同时，其他人推送提交到<code>git.ourcompany.com</code>并更新了它的<code>master</code>分支，那么你的提交历史将向不同的方向前进。另外，只要你不与<code>origin</code>服务器连接，你的<code>origin/master</code>指针就不会移动。</p><div align="center"><img src="http://image.yingzq.com/img/20191022142139.png" width="750" alt="本地与远程的工作可以分叉"><p>图6：本地与远程的工作可以分叉</p></div><p>如果要同步你的工作，运行<code>git fetch &lt;remote&gt;</code>命令（在本例中是<code>git fetch origin</code>）。这个命令查找 “origin” 是哪一个服务器（在本例中是<code>git.ourcompany.com</code>），从中抓取本地没有的数据，并且更新本地数据库，移动<code>origin/master</code>指针指向更新后的位置。</p><div align="center"><img src="http://image.yingzq.com/img/20191022142624.png" width="750" alt="git fetch更新远程仓库引用"><p>图7：git fetch更新远程仓库引用</p></div><p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部Git服务器，仅用于你小组的开发工作。这个服务器位于<code>git.team1.ourcompany.com</code>。你可以运行<code>git remote add</code>命令添加一个新的远程仓库引用到当前的项目。将这个远程仓库命名为<code>teamone</code>，将其作为整个URL的缩写。</p><div align="center"><img src="http://image.yingzq.com/img/20191022143333.png" width="750" alt="添加另一个远程仓库"><p>图8：添加另一个远程仓库</p></div><p>现在，可以运行<code>git fetch teamone</code>来抓取远程仓库<code>teamone</code>有而本地没有的数据。因为那台服务器上现有的数据是<code>origin</code>服务器上的一个子集，所以Git并不会抓取数据而是会设置远程跟踪分支<code>teamone/master</code>指向<code>teamone</code>的<code>master</code>分支。</p><div align="center"><img src="http://image.yingzq.com/img/20191022143611.png" width="750" alt="远程跟踪分支teamone/master"><p>图9：远程跟踪分支teamone/master</p></div><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p><p>如果希望和别人一起在名为<code>serverfix</code>的分支上工作，你可以像推送第一个分支那样推送它。运行<code>git push &lt;remote&gt; &lt;branch&gt;</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure><p>这里有些工作被简化了。Git自动将<code>serverfix</code>分支名字展开为<code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的<code>serverfix</code>分支来更新远程仓库上的<code>serverfix</code>分支。” 你也可以运行<code>git push origin serverfix:serverfix</code>，它会做同样的事——也就是说 “推送本地的<code>serverfix</code>分支，将其作为远程仓库的<code>serverfix</code>分支”。你也可以通过这种格式来推送本地分支到一个命名不相同的远程分支，例如你并不想让远程仓库上的分支叫做<code>serverfix</code>，可以运行<code>git push origin serverfix:awesomebranch</code>来将本地的<code>serverfix</code>分支推送到远程仓库上的<code>awesomebranch</code>分支。</p><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支<code>origin/serverfix</code>，指向服务器的<code>serverfix</code>分支的引用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</span><br></pre></td></tr></table></figure><p><strong>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本。换句话说，这种情况下，不会有一个新的<code>serverfix</code>分支，只有一个不可以修改的<code>origin/serverfix</code>指针。</strong></p><p>可以运行<code>git merge origin/serverfix</code>将这些工作合并到当前所在的分支。如果想要在自己的<code>serverfix</code>分支上工作，可以将其建立在远程跟踪分支之上：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b serverfix origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &apos;serverfix&apos;</span><br></pre></td></tr></table></figure><p>这会给你一个用于工作的本地分支，并且起点位于<code>origin/serverfix</code>。</p><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。跟踪分支是与远程分支有直接关系的本地分支。如果在一个跟踪分支上输入<code>git pull</code>，Git能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪<code>origin/master</code>的<code>master</code>分支。然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪<code>master</code>分支。最简单的实例就是像之前看到的那样，运行<code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。这是一个十分常用的操作所以Git提供了<code>--track</code>快捷方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &apos;serverfix&apos;</span><br></pre></td></tr></table></figure><p>事实上，这个命令实在是太常用了，所以有一个快捷方式中的快捷方式。如果您试图检出的分支满足(a)名称不存在(b)有且仅有一个远程分支名称和它完全匹配，Git将为您创建跟踪分支：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &apos;serverfix&apos;</span><br></pre></td></tr></table></figure><p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地使用原始版本的命令增加一个不同名字的本地分支：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &apos;sf&apos;</span><br></pre></td></tr></table></figure><p>现在，本地分支<code>sf</code>会自动从<code>origin/serverfix</code>拉取。</p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用<code>-u</code>或<code>--set-upstream-to</code>选项运行<code>git branch</code>来显式地设置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -u origin/serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：上游快捷方式</strong><br>当设置好跟踪分支后，可以通过<code>@{upstream}</code>或<code>@{u}</code>快捷方式来引用它。所以在<code>master</code>分支时并且它正在跟踪<code>origin/master</code>时，如果愿意的话可以使用<code>git merge @{u}</code>来取代<code>git merge origin/master</code>。</p></blockquote><p>如果想要查看设置的所有跟踪分支，可以使用<code>git branch</code>的<code>-vv</code>选项。这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure><p>这里可以看到<code>iss53</code>分支正在跟踪<code>origin/iss53</code>并且 “ahead” 是2，意味着本地有两个提交还没有推送到服务器上。也能看到<code>master</code>分支正在跟踪<code>origin/master</code>分支并且是最新的。接下来可以看到<code>serverfix</code>分支正在跟踪<code>teamone</code>服务器上的<code>server-fix-good</code>分支并且领先3落后1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。最后看到<code>testing</code>分支并没有跟踪任何远程分支。</p><p><strong>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。</strong>如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。可以像这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch --all; git branch -vv</span><br></pre></td></tr></table></figure><h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>当<code>git fetch</code>命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。它只会获取数据然后让你自己合并。然而，有一个命令叫作<code>git pull</code>在大多数情况下它的含义是一个<code>git fetch</code>紧接着一个<code>git merge</code>命令。如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过<code>clone</code>或<code>checkout</code>命令为你创建的，<code>git pull</code>都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p><p>由于<code>git pull</code>的魔法经常令人困惑所以通常单独显式地使用<code>fetch</code>与<code>merge</code>命令会更好一些。</p><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>假设你已经通过远程分支做完所有的工作了，也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的<code>master</code>分支（或任何其他稳定代码分支）。可以运行带有<code>--delete</code>选项的<code>git push</code>命令来删除一个远程分支。例如想要从服务器上删除<code>serverfix</code>分支，运行下面的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure><p>基本上这个命令做的只是从服务器上移除这个指针。Git服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p><h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在Git中整合来自不同分支的修改主要有两种方法：<code>merge</code>以及<code>rebase</code>。在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p><h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h3><p>考虑之前遇到的情况，开发任务分叉到了两个不同分支，又各自提交了更新。</p><div align="center"><img src="http://image.yingzq.com/img/20191022154849.png" width="750" alt="分叉的提交历史"><p>图10：分叉的提交历史</p></div><p>之前介绍过，整合分支最容易的方法是<code>merge</code>命令。它会把两个分支的最新快照（<code>C3</code>和<code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交），如下图所示：</p><div align="center"><img src="http://image.yingzq.com/img/20191022155124.png" width="750" alt="通过合并操作来整合分叉了的历史"><p>图11：通过合并操作来整合分叉了的历史</p></div><p>其实，还有一种方法：你可以提取在<code>C4</code>中引入的补丁和修改，然后在<code>C3</code>的基础上应用一次。在Git中，这种操作就叫做 <strong>变基</strong>。 你可以使用<code>rebase</code>命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p>在上面这个例子中，运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支<code>experiment</code>、变基操作的目标基底分支<code>master</code>）的最近共同祖先<code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底<code>C3</code>，最后以此将之前另存为临时文件的修改依序应用。</p><div align="center"><img src="http://image.yingzq.com/img/20191022161447.png" width="750" alt="将C4中的修改变基到C3上"><p>图12：将C4中的修改变基到C3上</p></div><p>现在回到<code>master</code>分支，进行一次快进合并。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge experiment</span><br></pre></td></tr></table></figure><div align="center"><img src="http://image.yingzq.com/img/20191022161720.png" width="750" alt="master分支的快进合并"><p>图13：master分支的快进合并</p></div><p>此时，<code>C4&#39;</code>指向的快照就和上面使用<code>merge</code>命令的例子中<code>C5</code>指向的快照一模一样了。这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁，例如向某个其他人维护的项目贡献代码时。在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到<code>origin/master</code>上，然后再向主项目提交修改。这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p><strong>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</strong></p><h3 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。</p><p>就像下图的例子：</p><div align="center"><img src="http://image.yingzq.com/img/20191022162427.png" width="800" alt="从一个特性分支里再分出一个特性分支的提交历史"><p>图14：从一个特性分支里再分出一个特性分支的提交历史</p></div><p>你创建了一个特性分支<code>server</code>，为服务端添加了一些功能，提交了<code>C3</code>和<code>C4</code>。然后从<code>C3</code>上创建了特性分支<code>client</code>，为客户端添加了一些功能，提交了<code>C8</code>和<code>C9</code>。最后，你回到<code>server</code>分支，又提交了<code>C10</code>。</p><p>假设你希望将<code>client</code>中的修改合并到主分支并发布，但暂时并不想合并<code>server</code>中的修改，因为它们还需要经过更全面的测试。这时，你就可以使用<code>git rebase</code>命令的<code>--onto</code>选项，选中在<code>client</code>分支里但不在<code>server</code>分支里的修改（即<code>C8</code>和<code>C9</code>），将它们在<code>master</code>分支上重放：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rebase --onto master server client</span><br></pre></td></tr></table></figure><p>以上命令的意思是：“取出<code>client</code>分支，找出处于<code>client</code>分支和<code>server</code>分支的共同祖先之后的修改，然后把它们在<code>master</code>分支上重放一遍”。这理解起来有一点复杂，不过效果非常酷。</p><div align="center"><img src="http://image.yingzq.com/img/20191022164831.png" width="800" alt="截取特性分支上的另一个特性分支，然后变基到其他分支"><p>图15：截取特性分支上的另一个特性分支，然后变基到其他分支</p></div><p>现在可以快进合并<code>master</code>分支了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge client</span><br></pre></td></tr></table></figure><div align="center"><img src="http://image.yingzq.com/img/20191022165050.png" width="800" alt="快进合并master分支，使之包含来自client分支的修改"><p>图16：快进合并master分支，使之包含来自client分支的修改</p></div><p>接下来你决定将<code>server</code>分支中的修改也整合进来。使用<code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code>命令可以直接将特性分支（即本例中的<code>server</code>）变基到目标分支（即<code>master</code>）上。这样做能省去你先切换到<code>server</code>分支，再对其执行变基命令的多个步骤：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rebase master server</span><br></pre></td></tr></table></figure><p>这样，<code>server</code>中的代码便被“续”到了<code>master</code>后面，如下图所示：</p><div align="center"><img src="http://image.yingzq.com/img/20191022170242.png" width="800" alt="将server中的修改变基到master上"><p>图17：将server中的修改变基到master上</p></div><p>然后就可以快进合并主分支<code>master</code>了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge server</span><br></pre></td></tr></table></figure><p>至此，<code>client</code>和<code>server</code>分支中的修改都已经整合到主分支里了，你可以删除这两个分支</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d client</span><br><span class="line">$ git branch -d server</span><br></pre></td></tr></table></figure><p>最终提交历史会变成下图中的样子：</p><div align="center"><img src="http://image.yingzq.com/img/20191022170702.png" width="800" alt="最终的提交历史"><p>图18：最终的提交历史</p></div><h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p>奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p><p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p><p><strong>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。</strong>如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用<code>git rebase</code>命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p><h3 id="变基-vs-合并"><a href="#变基-vs-合并" class="headerlink" title="变基 vs. 合并"></a>变基 vs. 合并</h3><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。它是针对历史的文档，本身就有价值，不能乱改。从这个角度看来，改变提交历史是一种亵渎，你使用 <strong>谎言</strong> 掩盖了实际发生过的事情。如果由合并产生的提交历史是一团糟怎么办？既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p><p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。持这一观点的人会使用<code>rebase</code>及<code>filter-branch</code>等工具来编写故事，怎么方便后来的读者就怎么写。</p><p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。Git是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p><p><strong>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们已经讲完了Git分支与合并的基础知识。你现在应该能自如地创建并切换至新分支、在不同分支之间切换以及合并本地分支。你现在应该也能通过推送你的分支至共享服务以分享它们、使用共享分支与他人协作以及在共享之前使用变基操作合并你的分支。同时通过这些例子，我们也能真真切切的感受到Git分支模型的强大，说分支模型是Git的杀手锏一点也不为过！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;/2019/10/13/git-branching/&quot; title=&quot;Git的杀手锏：分支模型（上）&quot;&gt;Git的杀手锏：分支模型（上）&lt;/a&gt;中，我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作。在本章我们继续来学习Git分支的工作流、远程分支和变基等内容。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://www.yingzq.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git的杀手锏：分支模型（上）</title>
    <link href="http://www.yingzq.com/2019/10/13/git-branching/"/>
    <id>http://www.yingzq.com/2019/10/13/git-branching/</id>
    <published>2019-10-13T04:11:55.000Z</published>
    <updated>2019-10-21T14:48:46.238Z</updated>
    
    <content type="html"><![CDATA[<p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。与许多其它版本控制系统不同，Git鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。理解和精通这一特性，你便会意识到Git是如此的强大而又独特，并且从此真正改变你的开发方式。</p><a id="more"></a><blockquote><p>正如文章题目，这也是Git能在众多版本控制系统脱颖而出的“杀手锏”</p></blockquote><h2 id="初识Git分支"><a href="#初识Git分支" class="headerlink" title="初识Git分支"></a>初识Git分支</h2><h3 id="Git分支简介"><a href="#Git分支简介" class="headerlink" title="Git分支简介"></a>Git分支简介</h3><p>在 <a href="/2019/09/18/what-is-git/" title="What is Git">What is Git</a> 中，我们了解到<strong>Git保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照</strong>，这和其他版本控制系统很是不同，那么为什么Git要这样做呢？</p><p>在进行提交操作时，Git会保存一个提交对象（commit object）。知道了Git保存数据的方式，我们可以很自然的想到<strong>该提交对象会包含一个指向暂存内容快照的指针</strong>。但不仅仅是这样，<strong>该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针</strong>。</p><blockquote><p>首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象</p></blockquote><p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和（使用SHA-1哈希算法），然后会把当前版本的文件快照保存到Git仓库中（Git使用blob对象来保存它们），最终将校验和加入到暂存区域等待提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m &apos;The initial commit of my project&apos;</span><br></pre></td></tr></table></figure><p>当使用<code>git commit</code>进行提交操作时，Git会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在Git仓库中这些校验和保存为树对象。随后，Git便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git就可以在需要的时候重现此次保存的快照。</p><p>现在，Git仓库中有五个对象：三个blob对象（保存着文件快照）、一个树对象（记录着目录结构和blob对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p><div align="center"><img src="http://image.yingzq.com/img/20191016150929.png" width="750" alt="首次提交对象及其树结构"><p>图1：首次提交对象及其树结构</p></div><p>如果做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p><div align="center"><img src="http://image.yingzq.com/img/20191016151756.png" width="750" alt="提交对象及其父对象"><p>图2：提交对象及其父对象</p></div><p><strong>Git的分支，其实本质上仅仅是指向提交对象的轻量级可移动指针。</strong>Git的默认分支名字是<code>master</code>。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的<code>master</code>分支。它会在每次的提交操作中自动向前移动。</p><blockquote><p>Git的<code>master</code>分支并不是一个特殊分支。它就跟其它分支完全没有区别。之所以几乎每一个仓库都有<code>master</code>分支，是因为<code>git init</code>命令默认创建它，并且大多数人都懒得去改动它。</p></blockquote><div align="center"><img src="http://image.yingzq.com/img/20191018152124.png" width="750" alt="分支及其提交历史"><p>图3：分支及其提交历史</p></div><h3 id="Git分支创建"><a href="#Git分支创建" class="headerlink" title="Git分支创建"></a>Git分支创建</h3><p>Git创建新分支很简单，因为Git只是为你创建了一个可以移动的新的指针。例如创建一个<code>testing</code>分支，你需要使用<code>git branch</code>命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure><p>这会在当前所在的提交对象上创建一个指针。</p><div align="center"><img src="http://image.yingzq.com/img/20191018153630.png" width="750" alt="两个指向相同提交历史的分支"><p>图4：两个指向相同提交历史的分支</p></div><p>那么，Git又是怎么知道当前在哪一个分支上呢？也很简单，它有一个名为<code>HEAD</code>的特殊指针。请注意它和许多其它版本控制系统（如Subversion或CVS）里的<code>HEAD</code>概念完全不同。在Git中，它是一个指针，指向当前所在的本地分支。在本例中，你仍然在<code>master</code>分支上。 <strong>因为<code>git branch</code>命令仅仅创建一个新分支，并不会自动切换到新分支中去</strong>。</p><div align="center"><img src="http://image.yingzq.com/img/20191020185042.png" width="750" alt="HEAD指向当前所在的分支"><p>图5：HEAD指向当前所在的分支</p></div><p>你可以简单地使用<code>git log</code>命令查看各个分支当前所指的对象。提供这一功能的参数是<code>--decorate</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --oneline --decorate</span><br><span class="line">f30ab (HEAD -&gt; master, testing) add feature #32 - ability to add new</span><br><span class="line">34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><p>可以看到，当前 “master” 和 “testing” 分支均指向校验和以<code>f30ab</code>开头的提交对象。</p><h3 id="Git分支切换"><a href="#Git分支切换" class="headerlink" title="Git分支切换"></a>Git分支切换</h3><p>要切换到一个已存在的分支，你需要使用<code>git checkout</code>命令。我们现在切换到新创建的<code>testing</code>分支去：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure><p>这样<code>HEAD</code>就指向<code>testing</code>分支了。</p><div align="center"><img src="http://image.yingzq.com/img/20191021113753.png" width="750" alt="HEAD指向当前所在的分支"><p>图6：HEAD指向当前所在的分支</p></div><p>那么，这样的实现方式会给我们带来什么好处呢？现在不妨再提交一次：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m &apos;made a change&apos;</span><br></pre></td></tr></table></figure><div align="center"><img src="http://image.yingzq.com/img/20191021143629.png" width="800" alt="HEAD分支随着提交操作自动向前移动"><p>图7：HEAD分支随着提交操作自动向前移动</p></div><p>这就有意思了，你的<code>testing</code>分支向前移动了，但是<code>master</code>分支却没有，它仍然指向运行<code>git checkout</code>时所指的对象。现在我们切换回 master 分支看看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><div align="center"><img src="http://image.yingzq.com/img/20191021144113.png" width="800" alt="检出时HEAD随之移动"><p>图8：检出时HEAD随之移动</p></div><p>这条命令做了两件事。一是使<code>HEAD</code>指回<code>master</code>分支，二是将工作目录恢复成<code>master</code>分支所指向的快照内容。也就是说，你现在做修改的话，项目将始于一个较旧的版本。本质上来讲，这就是忽略<code>testing</code>分支所做的修改，以便于向另一个方向进行开发。</p><blockquote><p><strong>注意：分支切换会改变你工作目录中的文件</strong><br>在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果Git不能干净利落地完成这个任务，它将禁止切换分支。</p></blockquote><p>我们不妨再稍微做些修改并提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m &apos;made other changes&apos;</span><br></pre></td></tr></table></figure><p>现在，这个项目的提交历史已经产生了分叉。因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回<code>master</code>分支进行了另外一些工作。上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。而所有这些工作，你需要的命令只有<code>branch</code>、<code>checkout</code>和<code>commit</code>。</p><div align="center"><img src="http://image.yingzq.com/img/20191021150106.png" width="800" alt="项目分叉历史"><p>图9：项目分叉历史</p></div><p>你可以简单地使用<code>git log</code>命令查看分叉历史。运行<code>git log --oneline --decorate --graph --all</code>，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --oneline --decorate --graph --all</span><br><span class="line">* c2b9e (HEAD -&gt; master) made other changes</span><br><span class="line">| * 87ab2 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><p>由于Git的分支实质上仅是包含所指对象校验和（长度为40的SHA-1值字符串）的文件，所以它的创建和销毁都异常高效。创建一个新分支就相当于往一个文件中写入41个字节（40个字符和1个换行符），如此的简单能不快吗？</p><p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。<strong>而在Git中，任何规模的项目都能在瞬间创建新分支。</strong> 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（即共同祖先）也是同样的简单和高效。这些高效的特性使得Git鼓励开发人员频繁地创建和使用分支。</p><p>接下来，让我们看看你为什么应该这样做。</p><blockquote><p><strong>注意：Git可以创建分支并同时切换到该分支</strong><br>创建一个分支并希望同时切换到该分支是很常见的，这可以通过<code>git checkout -b &lt;newbranchname&gt;</code>一条命令即可完成！</p></blockquote><h2 id="Git分支新建与合并"><a href="#Git分支新建与合并" class="headerlink" title="Git分支新建与合并"></a>Git分支新建与合并</h2><p>让我们来看一个简单的Git分支新建与合并的例子，实际工作中你可能会用到类似的工作流。你将经历如下步骤：</p><ol><li>开发某个网站。</li><li>为实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。你将按照如下方式来处理：</p><ol><li>切换到你的线上分支（production branch）。</li><li>为这个紧急任务新建一个分支，并在其中修复它。</li><li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li><li>切换回你最初工作的分支上，继续工作。</li></ol><h3 id="分支新建"><a href="#分支新建" class="headerlink" title="分支新建"></a>分支新建</h3><p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p><div align="center"><img src="http://image.yingzq.com/img/20191021160941.png" width="750" alt="一个简单提交历史"><p>图10：一个简单提交历史</p></div><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。想要新建一个分支并同时切换到那个分支上，你可以运行一个带有<code>-b</code>参数的<code>git checkou</code>命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch &quot;iss53&quot;</span><br></pre></td></tr></table></figure><p>它是下面两条命令的简写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure><div align="center"><img src="http://image.yingzq.com/img/20191021161457.png" width="750" alt="创建一个新分支指针"><p>图11：创建一个新分支指针</p></div><p>你继续在 #53 问题上工作，并且做了一些提交。在此过程中，<code>iss53</code>分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的<code>HEAD</code>指针指向了<code>iss53</code>分支）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &apos;added a new footer [issue 53]&apos;</span><br></pre></td></tr></table></figure><div align="center"><img src="http://image.yingzq.com/img/20191021163741.png" width="750" alt="iss53分支随着工作的进展向前推进"><p>图12：iss53分支随着工作的进展向前推进</p></div><p>现在你接到那个电话，有个紧急问题等待你来解决。有了Git的帮助，你不必把这个紧急问题和<code>iss53</code>的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。你所要做的仅仅是切换回<code>master</code>分支！</p><p>但是，在你这么做之前，<strong>要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止Git切换到该分支</strong>。最好的方法是，在你切换分支之前，保持好一个干净的状态。有一些方法可以绕过这个问题，即保存进度（stashing）和修补提交（commit amending）。</p><p>现在，我们假设你已经把你的修改全部提交了，这时你可以切换回<code>master</code>分支了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。请牢记：<strong>当你切换分支的时候，Git会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。Git会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</strong></p><p>接下来，你要修复这个紧急问题。让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br><span class="line">Switched to a new branch &apos;hotfix&apos;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &apos;fixed the broken email address&apos;</span><br><span class="line">[hotfix 1fb7853] fixed the broken email address</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><div align="center"><img src="http://image.yingzq.com/img/20191021191514.png" width="750" alt="基于master分支的紧急问题分支hotfix branch"><p>图13：基于master分支的紧急问题分支hotfix branch</p></div><p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的<code>master</code>分支来部署到线上。你可以使用<code>git merge</code>命令来达到上述目的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>在合并的时候，你应该注意到了“快进（fast-forward）”这个词。由于当前<code>master</code>分支所指向的提交是你当前提交（有关<code>hotfix</code>的提交）的直接上游，所以Git只是简单的将指针向前移动。<strong>换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做“快进（fast-forward）”。</strong></p><div align="center"><img src="http://image.yingzq.com/img/20191021192025.png" width="750" alt="master被快进到hotfix"><p>图14：master被快进到hotfix</p></div><p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。然而，你应该先删除<code>hotfix</code>分支，因为<code>master</code>分支已经指向了同一个位置，所以你已经不再需要它了。你可以使用带<code>-d</code>选项的<code>git branch</code>命令来删除分支：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure><p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（<code>iss53</code>分支）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout iss53</span><br><span class="line">Switched to branch &quot;iss53&quot;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &apos;finished the new footer [issue 53]&apos;</span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><div align="center"><img src="http://image.yingzq.com/img/20191021192515.png" width="800" alt="继续在iss53分支上的工作"><p>图15：继续在iss53分支上的工作</p></div><p>注意到你在<code>hotfix</code>分支上所做的工作并没有包含到<code>iss53</code>分支中。如果你需要拉取<code>hotfix</code>所做的修改，你可以使用<code>git merge master</code>命令将<code>master</code>分支合并入<code>iss53</code>分支，或者你也可以等到<code>iss53</code>分支完成其使命，再将其合并回<code>master</code>分支。</p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>假设你已经修正了 #53 问题，并且打算将你的工作合并入<code>master</code>分支。为此，你需要合并<code>iss53</code>分支到<code>master</code>分支，这和之前你合并<code>hotfix</code>分支所做的工作差不多。你只需要检出到你想合并入的分支，然后运行<code>git merge</code>命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">$ git merge iss53</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>这和你之前合并<code>hotfix</code>分支的时候看起来有一点不一样。在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。因为<code>master</code>分支所在提交并不是<code>iss53</code>分支所在提交的直接祖先，Git不得不做一些额外的工作。出现这种情况的时候，Git会使用两个分支的末端所指的快照（C4和C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。</p><div align="center"><img src="http://image.yingzq.com/img/20191021194612.png" width="800" alt="一次典型合并中所用到的三个快照"><p>图16：一次典型合并中所用到的三个快照</p></div><p><strong>和之前将分支指针向前推进所不同的是，Git将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。</strong>这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p><div align="center"><img src="http://image.yingzq.com/img/20191021195914.png" width="800" alt="一个合并提交"><p>图17：一个合并提交</p></div><p>需要指出的是，Git会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的CVS系统或者Subversion（1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。Git的这个优势使其在合并操作上比其他系统要简单很多。</p><p>既然你的修改已经合并进来了，你已经不再需要<code>iss53</code>分支了。现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d iss53</span><br></pre></td></tr></table></figure><h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>有时候合并操作不会如此顺利。如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git就没法干净的合并它们。如果你对 #53 问题的修改和有关<code>hotfix</code>的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>此时Git做了合并，但是没有自动地创建一个新的合并提交。Git会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用<code>git status</code>命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。Git会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>这表示<code>HEAD</code>所指示的版本（也就是你的<code>master</code>分支所在的位置，因为你在运行<code>merge</code>命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code>的上半部分），而<code>iss53</code>分支所指示的版本在<code>=======</code>的下半部分。为了解决冲突，你必须选择使用由<code>=======</code>分割的两部分中的一个，或者你也可以自行合并这些内容。例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>这些行被完全删除了。在你解决了所有文件里的冲突之后，对每个文件使用<code>git add</code>命令来将其标记为冲突已解决。一旦暂存这些原本有冲突的文件，Git就会将它们标记为冲突已解决。</p><p>如果你想使用图形化工具来解决冲突，你可以运行<code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git mergetool</span><br><span class="line"></span><br><span class="line">This message is displayed because &apos;merge.tool&apos; is not configured.</span><br><span class="line">See &apos;git mergetool --tool-help&apos; or &apos;git help config&apos; for more details.</span><br><span class="line">&apos;git mergetool&apos; will now attempt to use one of the following tools:</span><br><span class="line">tortoisemerge emerge vimdiff</span><br><span class="line">Merging:</span><br><span class="line">README</span><br><span class="line"></span><br><span class="line">Normal merge conflict for &apos;README&apos;:</span><br><span class="line">  &#123;local&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br><span class="line">Hit return to start merge resolution tool (vimdiff):</span><br></pre></td></tr></table></figure><p>如果你想使用除默认工具（在这里Git使用<code>vimdiff</code>做为默认的合并工具）外的其他合并工具，你可以在“下列工具中（one of the following tools）”这句后面看到所有支持的合并工具。然后输入你喜欢的工具名字就可以了。</p><blockquote><p>如果你需要更加高级的工具来解决复杂的合并冲突，可以参考 <a href="https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging#_advanced_merging" target="_blank" rel="noopener">Git Tools - Advanced Merging</a></p></blockquote><p>等你退出合并工具之后，Git会询问刚才的合并是否成功。如果你回答是，Git会暂存那些文件以表明冲突已解决：你可以再次运行<code>git status</code>来确认所有的合并冲突都已被解决：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use &quot;git commit&quot; to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">    modified:   index.html</span><br></pre></td></tr></table></figure><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入<code>git commit</code>来完成合并提交。默认情况下提交信息看起来像下面这个样子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Merge branch &apos;iss53&apos;</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">    index.html</span><br><span class="line">#</span><br><span class="line"># It looks like you may be committing a merge.</span><br><span class="line"># If this is not correct, please remove the file</span><br><span class="line">#.git/MERGE_HEAD</span><br><span class="line"># and try again.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># All conflicts fixed but you are still merging.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#modified:   index.html</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p><h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p><p><code>git branch</code>命令不只是可以创建与删除分支。如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>注意<code>master</code>分支前的<code>*</code>字符：它代表现在检出的那一个分支（也就是说，当前<code>HEAD</code>指针所指向的分支）。这意味着如果在这时候提交，<code>master</code>分支将会随着新的工作向前移动。如果需要查看每一个分支的最后一次提交，可以运行<code>git branch -v</code>命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &apos;iss53&apos;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure><p><code>--merged</code>与<code>--no-merged</code>这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。如果要查看哪些分支已经合并到当前分支，可以运行<code>git branch --merged</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>因为之前已经合并了<code>iss53</code>分支，所以现在看到它在列表中。在这个列表中分支名字前没有<code>*</code>号的分支通常可以使用<code>git branch -d</code>删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p><p>查看所有包含未合并工作的分支，可以运行<code>git branch --no-merged</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --no-merged</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>这里显示了其他分支。因为它包含了还未合并的工作，尝试使用<code>git branch -d</code>命令删除它时会失败：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d testing</span><br><span class="line">error: The branch &apos;testing&apos; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &apos;git branch -D testing&apos;.</span><br></pre></td></tr></table></figure><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用<code>-D</code>选项强制删除它。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作，难以置信的轻量分支模型也正是Git在众多版本控制系统中脱颖而出的杀手锏！</p><p>但是至此关于Git分支的内容还未结束，我们还没充分了解到Git分支的工作流、Git远程分支等内容，限于篇幅将在 <a href="/2019/10/16/git-branching-part-two/" title="Git的杀手锏：分支模型（下）">Git的杀手锏：分支模型（下）</a>继续讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。与许多其它版本控制系统不同，Git鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。理解和精通这一特性，你便会意识到Git是如此的强大而又独特，并且从此真正改变你的开发方式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://www.yingzq.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>请务必掌握的Git基础</title>
    <link href="http://www.yingzq.com/2019/10/01/git-basics/"/>
    <id>http://www.yingzq.com/2019/10/01/git-basics/</id>
    <published>2019-10-01T05:03:38.000Z</published>
    <updated>2019-10-02T03:13:04.992Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前最流行的分布式版本控制系统，值得我们去学会使用并深入了解。本文将会介绍几个最基本的，也是最常用的命令，以后绝大多数时间里用到的可能也就是这几个命令，主要涉及Git的配置、Git仓库的获取、如何记录每次更新到Git仓库、提交历史的查看、Git的撤销操作、Git标签和Git别名等基础知识点，这些是你务必掌握的Git基础！</p><a id="more"></a><h2 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h2><p>在开始阅读前，有几个需要注意的点：</p><ol><li>如果你没听说过Git或者还不了解Git是什么，请参阅文章 <a href="/2019/09/18/what-is-git/" title="What is Git">What is Git</a> 。</li><li>Git有多种使用方式，包括原生的和GUI模式，在这里推荐先使用并熟悉命令行模式，<strong>因为如果你学会了在命令行下如何操作，那么你在操作GUI软件时应该也不会遇到什么困难，但是，反之则不成立。</strong></li></ol><h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>在不同平台上Git安装的方式有一定差异，在这里不详细介绍。值得注意的是，虽然Git具有很好的向后兼容性，但是还是建议大家最好将它升级到最新的版本。</p><p>例如在Ubuntu系统中，可通过如下指令来安装最新稳定版本的Git：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p>在mac系统中则可通过Homebrew来安装最新版本的Git：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure><p>更多的安装指导可查看 <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" target="_blank" rel="noopener">Installing Git</a> 和 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官方下载界面</a> 。</p><p>安装完成后，输入指令<code>git --version</code>，返回正常的版本信息则证明已成功安装Git：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.21.0</span><br></pre></td></tr></table></figure><blockquote><p>注：因为Git的安装是非常方便快捷的，官网也有清晰的指导，所以这一章节讲的非常简略。</p></blockquote><h2 id="初次使用Git前的配置"><a href="#初次使用Git前的配置" class="headerlink" title="初次使用Git前的配置"></a>初次使用Git前的配置</h2><p>在第一次使用一个新编辑器的时候，你会倾向于把字体大小、界面还有需要的插件等统一配置一下，这样在你以后使用这个编辑器的时候，编辑器便会默认载入这些配置，非常的方便。</p><p>Git中也有类似的机制。Git自带一个<code>git config</code>的工具来帮助设置控制Git外观和行为的配置变量，这些变量存储在三个不同的位置：</p><ol><li><code>etc/gitconfig</code>文件: 包含系统上每一个用户及他们仓库的通用配置。如果使用带有<code>--system</code>选项的<code>git config</code>时，它会从此文件读写配置变量。</li><li><code>~/.gitconfig</code>或<code>~/.config/git/config</code>文件：只针对当前用户。可以传递<code>--global</code>选项让Git读写此文件。</li><li>当前使用仓库的Git目录中的config文件（也就是<code>.git/config</code>）：针对该仓库。可以传递<code>--local</code>选项让Git读写此文件，但是其实这个选项是默认的，因此可以省略。</li></ol><p>每一个级别覆盖上一级别的配置，例如<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。</p><p>在Windows系统中，Git会查找<code>$HOME</code>目录下（一般情况下是 C:\Users\$USER）的<code>.gitconfig</code>文件。Git同样也会寻找<code>/etc/gitconfig</code>文件，但只限于MSys的根目录下，即安装Git时所选的目标位置。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>首先你需要设置自己的用户名称和邮箱，这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改（换句话说，不设置用户信息无法进行<code>git commit</code>操作）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;YingZiqiang&quot;</span><br><span class="line">$ git config --global user.email yingzq0116@163.com</span><br></pre></td></tr></table></figure><p>再次强调，如果使用了<code>--global</code>选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有<code>--global</code>选项的命令来配置。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>当Git需要你输入信息时会调用默认的文本编辑器。如果未配置，Git会使用操作系统默认的文本编辑器，通常是Vim。如果你想使用不同的文本编辑器，例如Emacs，可以这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global core.editor emacs</span><br></pre></td></tr></table></figure><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>如果想要检查你的配置，可以使用<code>git config --list</code>命令来列出所有Git当时能找到的配置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name=YingZiqiang</span><br><span class="line">user.email=88629850@qq.com</span><br><span class="line">push.default=simple</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有时候会看到重复的变量名，因为Git可能会从多个配置文件中读取同一个配置变量。这种情况下，<strong>Git会使用它找到的每一个变量的最后一个配置</strong>。</p><p>可以通过输入<code>git config &lt;key&gt;</code>来检查Git的某一项配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">YingZiqiang</span><br></pre></td></tr></table></figure><p>如果你想确认某配置变量的最终决定权的来源，可以输入<code>git config --show-origin &lt;key&gt;</code>查询：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --show-origin user.name</span><br><span class="line">file:/Users/yingzq/.gitconfigYingZiqiang</span><br></pre></td></tr></table></figure><h2 id="Git帮助"><a href="#Git帮助" class="headerlink" title="Git帮助"></a>Git帮助</h2><p>若你使用Git时需要获取帮助，有三种方法可以找到Git命令的使用手册：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure><p>例如，要想获得config命令的手册，执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help config</span><br></pre></td></tr></table></figure><p>另外，如果你不想查看一个Git命令完整的使用手册，仅仅是想要快速查看某些参数的用法，可以通过<code>-h</code>选项来获得一个更加简洁的帮助界面，例如查看<code>git add</code>命令的参数信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add -h</span><br></pre></td></tr></table></figure><blockquote><p>注：你可以随时随地可以使用这些命令而无需联网</p></blockquote><h2 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h2><p>有两种取得Git项目仓库的方法。第一种是在现有项目或目录下导入所有文件到Git中；第二种是从一个服务器克隆一个现有的Git仓库。</p><h3 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h3><p>如果你打算使用Git来对现有的项目进行管理，你只需要进入该项目目录并输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>该命令将创建一个名为<code>.git</code>的子目录，这个子目录含有你初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p><p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化Git仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。你可通过<code>git add</code>命令来实现对指定文件的跟踪，然后执行<code>git commit</code>提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add *.py</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m &apos;initial project version&apos;</span><br></pre></td></tr></table></figure><p>稍后会逐一解释每一条指令的意思。现在，你已经得到了一个实际维护（或者说是跟踪）着若干个文件的Git仓库。</p><h3 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h3><p>如果你想获得一份已经存在了的Git仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到<code>git clone</code>命令。</p><p>克隆仓库的命令格式是<code>git clone [url]</code>。比如，要克隆一个叫“TensorFlow-Examples”的库，可以用下面的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/aymericdamien/TensorFlow-Examples</span><br></pre></td></tr></table></figure><p>这会在当前目录下创建一个名为“TensorFlow-Examples”的目录，并在这个目录下初始化一个<code>.git</code>文件夹，并从远程仓库拉取下所有数据放入<code>.git</code>文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的“TensorFlow-Examples”文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/aymericdamien/TensorFlow-Examples my-tf-examples</span><br></pre></td></tr></table></figure><p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为“my-tf-examples”。</p><p>Git支持多种数据传输协议。上面的例子使用的是<code>https://</code>协议，不过你也可以使用<code>git://</code>协议或者使用例如<code>user@server:path/to/repo.git</code>的SSH传输协议。</p><blockquote><p>注：Git克隆的是该Git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。当你执行<code>git clone</code>命令的时候，默认配置下远程Git仓库中的每一个文件的每一个版本都将被拉取下来。</p></blockquote><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>现在我们手上有了一个真实项目的Git仓库，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p><p><strong>工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。</strong>已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p><div align="center"><img src="http://image.yingzq.com/img/20190927165926.png" width="600" alt="文件的状态变化周期"><p>图1：文件的状态变化周期</p></div><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>要查看哪些文件处于什么状态，可以用<code>git status</code>命令。如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则Git会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是“master”，这是默认的分支名。在这里不用担心不明白分支是什么，这一部分会在 <a href="/2019/10/13/git-branching/" title="Git的杀手锏：分支模型（上）">Git的杀手锏：分支模型（上）</a> 单独讲解。</p><p>如果在项目中创建一个新的<code>README</code>文件，如果之前并不存在这个文件，使用<code>git status</code>命令，你将看到一个新的未跟踪文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &apos;My Project&apos; &gt; README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>在状态报告中可以看到新建的<code>README</code>文件出现在“Untracked files”下面。未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。不过现在的例子中，我们确实想要跟踪管理README这个文件。</p><h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令<code>git add</code>开始跟踪一个文件。所以如果要跟踪<code>README</code>文件，运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure><p>此时再运行<code>git status</code>命令，会看到<code>README</code>文件已被跟踪，并处于暂存状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br></pre></td></tr></table></figure><p>只要在“Changes to be committed”这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用<code>git init</code>后就运行了<code>git add &lt;files&gt;</code>命令，开始跟踪当前目录下的文件。<strong><code>git add</code>命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</strong></p><h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>现在我们来修改一个已被跟踪的文件。如果你修改了一个名为<code>TINY.md</code>的已被跟踪的文件，然后运行<code>git status</code>命令，会看到下面内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>文件<code>TINY.md</code>出现在“Changes not staged for commit”这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行<code>git add</code>命令。<strong><code>git add</code>是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</strong> 现在让我们运行<code>git add</code>将<code>TINY.md</code>放到暂存区，然后再看看<code>git status</code>的输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。</p><p>这里再追加一个小问题，假设此时，你的<code>TINY.md</code>文件存在一些小瑕疵，于是你重新编辑该文件并存盘了，此时运行<code>git status</code>会发生什么呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>怎么回事？现在<code>TINY.md</code>文件同时出现在暂存区和非暂存区。这怎么可能呢？实际上Git只不过暂存了你运行<code>git add</code>命令时的版本，如果你现在提交，<code>TINY.md</code>的版本是你最后一次运行<code>git add</code>命令时的那个版本，而不是你运行<code>git commit</code>时，在工作目录中的当前版本。 所以，运行了<code>git add</code>之后又作了修订的文件，需要重新运行<code>git add</code>把最新版本重新暂存起来：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p><code>git status</code>命令的输出十分详细，但其用语有些繁琐。如果你使用<code>git status -s</code>命令或<code>git status --short</code>命令，你将得到一种更为紧凑的格式输出。运行<code>git status -s</code>，状态报告输出如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">A  README</span><br><span class="line">M  TINY.md</span><br></pre></td></tr></table></figure><p>新添加的未跟踪文件前面有<code>??</code>标记，新添加到暂存区中的文件前面有<code>A</code>标记，修改过的文件前面有<code>M</code>标记。<strong>其中<code>M</code>有两个可以出现的位置，出现在右边的<code>M</code>表示该文件被修改了但是还没放入暂存区，出现在靠左边的<code>M</code>表示该文件被修改了并放入了暂存区。</strong></p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为<code>.gitignore</code>的文件，列出要忽略的文件模式。来看一个实际的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure><p>第一行告诉Git忽略所有以“.o”或“.a”结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。第二行告诉Git忽略所有以波浪符（<code>~</code>）结尾的文件，许多文本编辑软件（比如Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略log，tmp或者pid目录，以及自动生成的文档等等。要养成一开始就设置好<code>.gitignore</code>文件的习惯，以免将来误提交这类无用的文件。</p><p>文件<code>.gitignore</code>的格式规范如下：</p><ul><li>所有空行或者以<code>#</code>开头的行都会被Git忽略。</li><li>可以使用标准的glob模式匹配，并且会在整个工作目录中递归的应用。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上感叹号（<code>!</code>）取反。</li></ul><p>所谓的glob模式是指所使用的简化了的正则表达式。星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code>匹配任何一个列在方括号中的字符（这个例子要么匹配一个a，要么匹配一个b，要么匹配一个c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如<code>[0-9]</code>表示匹配所有0到9的数字）。使用两个星号表示匹配任意中间目录，比如<code>a/**/z</code>可以匹配<code>a/z</code>,<code>a/b/z</code>或<code>a/b/c/z</code>等。</p><p>我们再看一个<code>.gitignore</code>文件的例子：</p><pre><code># no .a files*.a# but do track lib.a, even though you&apos;re ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf</code></pre><blockquote><p>GitHub有一个十分详细的针对数十种项目及语言的<code>.gitignore</code>文件列表，你可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> 找到它。</p></blockquote><h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p>如果<code>git status</code>命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用<code>git diff</code>命令。</p><p><strong>你可能通常会用<code>git diff</code>命令来回答这两个问题：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？</strong>尽管<code>git status</code>已经通过在相应栏下列出文件名的方式回答了这个问题，<code>git diff</code>将通过文件补丁的格式显示具体哪些行发生了改变。</p><p>假如此时你再次编辑<code>TINY.md</code>后不暂存，运行<code>git status</code>会看到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入<code>git diff</code>，<strong>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/TINY.md b/TINY.md</span><br><span class="line">index 5818529..f0bfc69 100644</span><br><span class="line">--- a/TINY.md</span><br><span class="line">+++ b/TINY.md</span><br><span class="line">@@ -1,3 +1,3 @@</span><br><span class="line"> tiny data</span><br><span class="line"> modify this file, we add one new line</span><br><span class="line">-fix something</span><br><span class="line">+add one line for test</span><br></pre></td></tr></table></figure><p>若要查看已暂存的将要添加到下次提交里的内容，可以用<code>git diff --cached</code>命令（Git 1.6.1及更高版本还允许使用<code>git diff --staged</code>，效果是相同的，但更好记些），<strong>此命令是将目前已暂存的更改和上次提交的内容进行比较</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff --staged</span><br><span class="line">diff --git a/README b/README</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e69de29</span><br><span class="line">diff --git a/TINY.md b/TINY.md</span><br><span class="line">index f8f5ae1..5818529 100644</span><br><span class="line">--- a/TINY.md</span><br><span class="line">+++ b/TINY.md</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line"> tiny data</span><br><span class="line">+modify this file, we add one new line</span><br><span class="line">+fix something</span><br></pre></td></tr></table></figure><p>请注意，<code>git diff</code>本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。所以有时候你一下子暂存了所有更新过的文件后，运行<code>git diff</code>后却什么也没有，就是这个原因。</p><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>当你的暂存区域已经准备妥当便可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有<code>git add</code>过，否则提交的时候不会记录这些还没暂存起来的变化。这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用<code>git status</code>看下，是不是都已暂存起来了，然后再运行提交命令git commit：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>这种方式会启动默认的文本编辑器以便输入本次提交的说明，需要注意的是，如果输入的提交说明为空你的本次提交将会被中止。</p><p>更常用的方式是在<code>commit</code>命令后添加<code>-m</code>选项，将提交信息与命令放在同一行，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &apos;add README file and fix some bugs in TINY.md&apos;</span><br><span class="line">[master 10114de] add README file and fix some bugs in TINY.md</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><p>现在你已经创建了第一个提交！可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整SHA-1校验和是什么（10114de），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><p>请记住，<strong>提交时记录的是放在暂存区域的快照</strong>。任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给<code>git commit</code>加上<code>-a</code>选项，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过<code>git add</code>步骤：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">$ git commit -a -m &apos;test the commit -a option&apos;</span><br><span class="line">[master 45f06e1] test the commit -a option</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>可以看到，提交之前不再需要<code>git add</code>文件<code>TINY.md</code>了。</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用<code>git rm</code>命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行<code>git status</code>时就会在“Changes not staged for commit”部分（也就是<strong>未暂存清单</strong>）看到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    TINY.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>然后再运行<code>git rm</code>记录此次移除文件的操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">deleted:    TINY.md</span><br></pre></td></tr></table></figure><p>下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项<code>-f</code>（即force的首字母）。这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被Git恢复。</p><p>另外一种情况是，我们想把文件从暂存区域移除，但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，但是并不想让Git继续跟踪。当你忘记添加<code>.gitignore</code>文件，不小心把一个很大的日志文件或一堆<code>.a</code>这样的编译生成文件添加到暂存区时，这一做法尤其有用。为达到这一目的，使用<code>--cached</code>选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm --cached README</span><br></pre></td></tr></table></figure><p><code>git rm</code>命令后面可以列出文件或者目录的名字，也可以使用glob模式。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm log/\*.log</span><br></pre></td></tr></table></figure><p>注意到星号<code>*</code>之前的反斜杠<code>\</code>，这是非常有必要的，<strong>因为除了拥有shell的文件模式扩展匹配方式，Git还有它自己的文件模式扩展匹配方式。</strong> 此命令会删除<code>log/</code>目录及其子目录下扩展名为<code>.log</code>的所有文件。</p><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>不像其它的VCS系统，Git并不显式跟踪文件移动操作。如果在Git中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过Git非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，可以放到以后再详细了解。</p><p>要在Git中对文件改名，可以这么做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure><p>此时查看状态信息，可以明白无误地看到关于重命名操作的说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git mv TINY.md MY-TOY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">renamed:    TINY.md -&gt; MY-TOY.md</span><br></pre></td></tr></table></figure><p>其实，运行<code>git mv</code>就相当于运行了下面三条命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mv TINY.md MY-TOY.md</span><br><span class="line">$ git rm TINY.md</span><br><span class="line">$ git add MY-TOY.md</span><br></pre></td></tr></table></figure><p>如此分开操作，Git也会意识到这是一次改名，所以不管何种方式结果都一样，但是<code>git mv</code>一个命令代替了第二种方式的三个命令，更加的轻便。<strong>更进一步，你可以使用任何你熟悉的工具来重命名文件，然后只需要记得在提交前，删除老的文件名并添加新的文件名。</strong></p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。完成这个任务最简单而又有效的工具是<code>git log</code>命令。</p><p>首先运行下面的命令获取用于演示的simplegit项目的源代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/schacon/simplegit-progit</span><br></pre></td></tr></table></figure><p>然后在此项目中运行<code>git log</code>，应该会看到下面的输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><p>默认不用任何参数的话，<code>git log</code>会按提交时间列出所有的更新，最近的更新排在最上面。正如你所看到的，这个命令会列出每个提交的SHA-1校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p><code>git log</code>有许多选项可以帮助你搜寻你所要找的提交， 接下来我们先来了解一些最常用的选项。</p><p>一个常用的选项是<code>-p</code>或者说是<code>--patch</code>，用来显示每次提交的内容差异（the patch output）。你也可以限制展示的提交条目数，例如可以加上<code>-2</code>来仅显示最近两次提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log -p -2</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require &apos;rake/gempackagetask&apos;</span><br><span class="line"> spec = Gem::Specification.new do |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   &quot;simplegit&quot;</span><br><span class="line">-    s.version   =   &quot;0.1.0&quot;</span><br><span class="line">+    s.version   =   &quot;0.1.1&quot;</span><br><span class="line">     s.author    =   &quot;Scott Chacon&quot;</span><br><span class="line">     s.email     =   &quot;schacon@gmail.com&quot;</span><br><span class="line">     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index a0a60ae..47c6340 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -18,8 +18,3 @@ class SimpleGit</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line">-</span><br><span class="line">-if $0 == __FILE__</span><br><span class="line">-  git = SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-end</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>该选项除了显示基本信息之外，还附带了每次<code>commit</code>的变化。当进行代码审查，或者快速浏览某个搭档提交的<code>commit</code>所带来的变化的时候，这个参数就非常有用了。你也可以为<code>git log</code>附带一系列的总结性选项。比如说，如果你想看到每次提交的简略的统计信息，你可以使用<code>--stat</code>选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --stat</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb | 5 -----</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |  6 ++++++</span><br><span class="line"> Rakefile         | 23 +++++++++++++++++++++++</span><br><span class="line"> lib/simplegit.rb | 25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+)</span><br></pre></td></tr></table></figure><p>正如你所看到的，<code>--stat</code>选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。在每次提交的最后还有一个总结。</p><p>另外一个常用的选项是<code>--pretty</code>。这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用。比如用<code>oneline</code>将每个提交放在一行显示，查看的提交数很大时非常有用。</p><p><code>git log</code>还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。例如之前看到的<code>-2</code>其实是<code>-&lt;n&gt;</code>选项的写法，其中的n可以是任何整数，表示仅显示最近的若干条提交；另外还有按照时间作限制的选项，比如<code>--since</code>和<code>--until</code>也很有用，还可以给出若干搜索条件，列出符合的提交…</p><p><code>git log</code>的选项非常多，在这里不再一一介绍。总之，<code>git log</code>是一个功能非常齐全、可定制化程度非常高的、能满足你几乎所有查询方式的查看提交历史的命令。</p><h2 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h2><p>在任何一个阶段，你都有可能想要撤消某些操作。这里，我们将会学习几个撤消你所做修改的基本工具。<strong>注意，有些撤消操作是不可逆的，这是在使用Git的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</strong></p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有<code>--amend</code>选项的提交命令尝试重新提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>这个命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p><p>运行该命令后会启动文本编辑器，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &apos;initial commit&apos;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><p>接下来再来学习一下如何操作暂存区域与工作目录中已修改的文件。这些命令在修改文件状态的同时，也会提示如何撤消操作。</p><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>如果你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了<code>git add *</code>暂存了它们两个。如何只取消暂存两个中的一个呢？<code>git status</code>命令提示了你：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README</span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>在“Changes to be committed”文字正下方，提示使用<code>git reset HEAD &lt;file&gt;...</code>来取消暂存。所以，我们可以这样来取消暂存<code>TINY.md</code>文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD TINY.md</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>可以看到<code>TINY.md</code>文件已经是修改未暂存的状态了。</p><h3 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h3><p>如果你并不想保留对<code>TINY.md</code>文件的修改怎么办？你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？幸运的是，<code>git status</code>也告诉了你应该如何做。在最后一个例子中，未暂存区域是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>它非常清楚地告诉了你如何撤消之前所做的修改。让我们来按照提示执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README</span><br></pre></td></tr></table></figure><p>可以看到关于<code>TINY.md</code>的修改已经被撤消了。</p><blockquote><p>请记住，在Git中任何<strong>已提交的</strong>东西几乎总是可以恢复的。甚至那些被删除的分支中的提交或使用<code>--amend</code>选项覆盖的提交也可以恢复。然而，任何你<strong>未提交的</strong>东西丢失后很可能再也找不到了。</p></blockquote><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>为了能在任意Git项目上协作，你需要知道如何管理自己的远程仓库。<strong>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。</strong> 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。在本章节中，将介绍一部分基础的远程管理技能。</p><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行<code>git remote</code>命令。它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到<code>origin</code>，这是Git给你克隆的仓库服务器的默认名字</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/schacon/ticgit</span><br><span class="line">Cloning into &apos;ticgit&apos;...</span><br><span class="line">remote: Enumerating objects: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0), pack-reused 1857</span><br><span class="line">Receiving objects: 100% (1857/1857), 334.04 KiB | 36.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (837/837), done.</span><br><span class="line">$ cd ticgit</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>你也可以指定选项<code>-v</code>，会显示需要读写远程仓库使用的Git保存的简写与其对应的URL。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure><p>如果你的远程仓库不止一个，该命令会将它们全部列出。例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd grit</span><br><span class="line">$ git remote -v</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (push)</span><br><span class="line">cho45     https://github.com/cho45/grit (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure><p>这样我们可以轻松拉取其中任何一个用户的贡献。此外，我们有可能还会有某些远程仓库的推送权限，不过暂时不在此介绍。</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>运行<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加一个新的远程Git仓库，同时指定一个你可以轻松引用的简写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit</span><br><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure><p>现在你可以在命令行中使用字符串<code>pb</code>来代替整个URL。例如，如果你想拉取Paul的仓库中有但你没有的信息，可以运行<code>git fetch pb</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch pb</span><br><span class="line">remote: Enumerating objects: 22, done.</span><br><span class="line">remote: Counting objects: 100% (22/22), done.</span><br><span class="line">remote: Total 43 (delta 22), reused 22 (delta 22), pack-reused 21</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure><p>现在Paul的master分支可以在本地通过<code>pb/master</code>访问到——你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。</p><blockquote><p>关于什么是分支以及如何使用分支将会在 <a href="/2019/10/13/git-branching/" title="Git的杀手锏：分支模型（上）">Git的杀手锏：分支模型（上）</a> 中详细介绍</p></blockquote><h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>就如刚才所见，从远程仓库中获得数据，可以执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用<code>clone</code>命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以“origin”为简写。所以，<code>git fetch origin</code>会抓取克隆（或上一次抓取）后新推送的所有工作。<strong>必须注意<code>git fetch</code>命令会将数据拉取到你的本地仓库，但是它并不会自动合并或修改你当前的工作。</strong> 当准备好时你必须手动将其合并入你的工作。</p><p>如果你有一个分支设置为跟踪一个远程分支，可以使用<code>git pull</code>命令来自动的抓取然后合并远程分支到当前分支。这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code>命令会自动设置本地master分支跟踪克隆的远程仓库的master分支（或不管是什么名字的默认分支）。运行<code>git pull</code>通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。这个命令很简单：<code>git push [remote-name] [branch-name]</code>。当你想要将master分支推送到<code>origin</code>服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。阅读 <a href="/2019/10/13/git-branching/" title="Git的杀手锏：分支模型（上）">Git的杀手锏：分支模型（上）</a> 了解如何推送到远程仓库服务器的详细信息。</p><h3 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用<code>git remote show [remote-name]</code>命令。如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master tracked</span><br><span class="line">    ticgit tracked</span><br><span class="line">  Local branch configured for &apos;git pull&apos;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &apos;git push&apos;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure><p>它同样会列出远程仓库的URL与跟踪分支的信息。这些信息非常有用，它告诉你正处于master分支，并且如果运行<code>git pull</code>，就会抓取所有的远程引用，然后将远程master分支合并到本地master分支。它也会列出拉取到的所有远程引用。</p><p>这是一个经常遇到的简单例子。如果你是Git的重度使用者，那么还可以通过<code>git remote show</code>看到更多的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  URL: https://github.com/my-org/complex-project</span><br><span class="line">  Fetch URL: https://github.com/my-org/complex-project</span><br><span class="line">  Push  URL: https://github.com/my-org/complex-project</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                           tracked</span><br><span class="line">    dev-branch                       tracked</span><br><span class="line">    markdown-strip                   tracked</span><br><span class="line">    issue-43                         new (next fetch will store in remotes/origin)</span><br><span class="line">    issue-45                         new (next fetch will store in remotes/origin)</span><br><span class="line">    refs/remotes/origin/issue-11     stale (use &apos;git remote prune&apos; to remove)</span><br><span class="line">  Local branches configured for &apos;git pull&apos;:</span><br><span class="line">    dev-branch merges with remote dev-branch</span><br><span class="line">    master     merges with remote master</span><br><span class="line">  Local refs configured for &apos;git push&apos;:</span><br><span class="line">    dev-branch                     pushes to dev-branch                     (up to date)</span><br><span class="line">    markdown-strip                 pushes to markdown-strip                 (up to date)</span><br><span class="line">    master                         pushes to master                         (up to date)</span><br></pre></td></tr></table></figure><p>这个命令列出了当你在特定的分支上执行<code>git push</code>会自动地推送到哪一个远程分支。它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行<code>git pull</code>时哪些分支会自动合并。</p><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>如果想要重命名引用的名字可以运行<code>git remote rename</code>去修改一个远程仓库的简写名。例如，想要将<code>pb</code>重命名为<code>paul</code>，可以用<code>git remote rename</code>这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>值得注意的是这同样也会修改你的远程分支名字。那些过去引用<code>pb/master</code>的现在会引用<code>paul/master</code>。</p><p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用<code>git remote rm</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>像其他版本控制系统（VCS）一样，Git可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。在本章节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。</p><h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p>在Git中列出已有的标签是非常简单直观的。只需要输入<code>git tag</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br></pre></td></tr></table></figure><p>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。</p><p>你也可以使用特定的模式查找标签。例如，Git自身的源代码仓库包含标签的数量超过500个。如果只对1.8.5系列感兴趣，可以运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -l &apos;v1.8.5*&apos;</span><br><span class="line">v1.8.5</span><br><span class="line">v1.8.5-rc0</span><br><span class="line">v1.8.5-rc1</span><br><span class="line">v1.8.5-rc2</span><br><span class="line">v1.8.5-rc3</span><br><span class="line">v1.8.5.1</span><br><span class="line">v1.8.5.2</span><br><span class="line">v1.8.5.3</span><br><span class="line">v1.8.5.4</span><br><span class="line">v1.8.5.5</span><br></pre></td></tr></table></figure><blockquote><p>注：如果你只是想要列出全部的标签，<code>-l</code>或者<code>--list</code>选项可以省略；但是如果是希望用特定的模式查找标签，<code>-l</code>或<code>--list</code>选项则是必须的</p></blockquote><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。</p><p>然而，附注标签是存储在Git数据库中的一个完整对象。它们是可以被校验的：其中包含打标签者的名字、电子邮件地址、日期时间，还有一个标签信息，并且可以使用GNU Privacy Guard （GPG）签名与验证。<strong>通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</strong></p><h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>在Git中创建一个附注标签是很简单的。最简单的方式是当你在运行<code>tag</code>命令时指定<code>-a</code>选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.4 -m &quot;my version 1.4&quot;</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure><p><code>-m</code>选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会运行编辑器要求你输入信息。</p><p>通过使用<code>git show</code>命令可以看到标签信息与对应的提交信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git show v1.4</span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>另一种给提交打标签的方式是使用轻量标签。<strong>轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。</strong> 创建轻量标签，不需要使用<code>-a</code>、<code>-s</code>或<code>-m</code>选项，只需要提供标签名字：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag v1.4-lw</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure><p>这时，如果在标签上运行<code>git show</code>，你不会看到额外的标签信息。命令只会显示出提交信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git show v1.4-lw</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><p>你也可以对过去的提交打标签。假设提交历史是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &apos;experiment&apos;</span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &apos;experiment&apos;</span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></td></tr></table></figure><p>现在，假设在v1.2时你忘记给项目打标签，也就是在“updated rakefile”提交。你可以在之后补上标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.2 9fceb02</span><br></pre></td></tr></table></figure><h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>默认情况下，<code>git push</code>命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样——你可以运行<code>git push origin [tagname]</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.5</span><br><span class="line">Counting objects: 14, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), done.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure><p>如果想要一次性推送很多标签，也可以使用带有<code>--tags</code>选项的<code>git push</code>命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure><p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>要删除掉你本地仓库上的标签，可以使用命令<code>git tag -d &lt;tagname&gt;</code>。例如，可以使用下面的命令删除掉一个轻量级标签：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -d v1.4-lw</span><br><span class="line">Deleted tag &apos;v1.4-lw&apos; (was e7d5add)</span><br></pre></td></tr></table></figure><p><strong>应该注意的是上述命令并不会从任何远程仓库中移除这个标签</strong>，有两种方式可以从远程仓库中删除标签。</p><p>第一种方式是使用<code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code>来更新你的远程仓库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/v1.4-lw</span><br><span class="line">To /git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         v1.4-lw</span><br></pre></td></tr></table></figure><p>第二种删除远程仓库标签的方式更加直观：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用<code>git checkout</code>命令。但是这会使你的仓库处于“分离头指针（detacthed HEAD）”状态，这个状态有些不好的副作用：如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。</p><p>因此，如果你需要进行更改，比如说你正在修复旧版本的错误，这通常需要创建一个新分支来进行操作。</p><h2 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h2><p>有一个小技巧可以使你的Git体验更简单、容易、熟悉：<strong>别名</strong></p><p>Git并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的Git命令，可以通过<code>git config</code>来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>这意味着，当要输入<code>git commit</code>时，只需要输入<code>git ci</code>。随着你继续不断地使用Git，可能也会经常使用其他命令，此时不要犹豫，为它创建一个别名吧。</p><p>在创建你认为应该存在的命令时这个技术也会很有用。例如，为了解决取消暂存文件的易用性问题，可以向Git中添加你自己的取消暂存别名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.unstage &apos;reset HEAD --&apos;</span><br></pre></td></tr></table></figure><p>这会使下面的两个命令等价：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git unstage fileA</span><br><span class="line">$ git reset HEAD -- fileA</span><br></pre></td></tr></table></figure><p>这样看起来更清楚一些。通常也会添加一个<code>last</code>命令，像这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.last &apos;log -1 HEAD&apos;</span><br></pre></td></tr></table></figure><p>这样，可以轻松地看到最后一次提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit 66938dae3329c7aebe598c2246a8e6af90d04646</span><br><span class="line">Author: Josh Goebel &lt;dreamer3@example.com&gt;</span><br><span class="line">Date:   Tue Aug 26 19:48:51 2008 +0800</span><br><span class="line"></span><br><span class="line">    test for current head</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</span><br></pre></td></tr></table></figure><p>可以看出，Git只是简单地将别名替换为对应的命令。然而，你可能想要执行外部命令，而不是一个Git子命令。如果是那样的话，可以在命令前面加入!符号。如果你自己要写一些与Git仓库协作的工具的话，那会很有用。例如将<code>git visual</code>定义为<code>gitk</code>的别名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.visual &apos;!gitk&apos;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍的Git的内容的确不少，但是这些都是你学习Git务必要掌握的基础。随着你对Git的使用越来越多，你会发现Git的每一个命令都是精简而高效的，他们使得你对文件版本控制变得异常方便快捷。</p><p>Just do it!</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git Book</a></li><li><a href="https://git-scm.com/docs" target="_blank" rel="noopener">Git Documents</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是目前最流行的分布式版本控制系统，值得我们去学会使用并深入了解。本文将会介绍几个最基本的，也是最常用的命令，以后绝大多数时间里用到的可能也就是这几个命令，主要涉及Git的配置、Git仓库的获取、如何记录每次更新到Git仓库、提交历史的查看、Git的撤销操作、Git标签和Git别名等基础知识点，这些是你务必掌握的Git基础！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://www.yingzq.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Pandas入门</title>
    <link href="http://www.yingzq.com/2019/09/22/pandas-getting-started/"/>
    <id>http://www.yingzq.com/2019/09/22/pandas-getting-started/</id>
    <published>2019-09-22T12:54:20.000Z</published>
    <updated>2019-09-24T03:11:19.037Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="Machine Learning" scheme="http://www.yingzq.com/tags/Machine-Learning/"/>
    
      <category term="Python" scheme="http://www.yingzq.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>NumPy入门</title>
    <link href="http://www.yingzq.com/2019/09/22/numpy-getting-started/"/>
    <id>http://www.yingzq.com/2019/09/22/numpy-getting-started/</id>
    <published>2019-09-22T12:53:26.000Z</published>
    <updated>2019-09-24T03:11:21.860Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="Machine Learning" scheme="http://www.yingzq.com/tags/Machine-Learning/"/>
    
      <category term="Python" scheme="http://www.yingzq.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>The Annotated Transformer</title>
    <link href="http://www.yingzq.com/2019/09/22/the-annotated-transformer/"/>
    <id>http://www.yingzq.com/2019/09/22/the-annotated-transformer/</id>
    <published>2019-09-22T08:22:27.000Z</published>
    <updated>2019-09-22T14:18:32.888Z</updated>
    
    <content type="html"><![CDATA[<p>将要进行…</p><a id="more"></a><p>2017年6月Google发表论文<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">“Attention is All You Need”</a>，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将要进行…&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NLP" scheme="http://www.yingzq.com/tags/NLP/"/>
    
      <category term="Transformer" scheme="http://www.yingzq.com/tags/Transformer/"/>
    
      <category term="Deep Learning" scheme="http://www.yingzq.com/tags/Deep-Learning/"/>
    
      <category term="PyTorch" scheme="http://www.yingzq.com/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>What is Git</title>
    <link href="http://www.yingzq.com/2019/09/18/what-is-git/"/>
    <id>http://www.yingzq.com/2019/09/18/what-is-git/</id>
    <published>2019-09-18T14:19:30.000Z</published>
    <updated>2019-09-27T14:31:21.764Z</updated>
    
    <content type="html"><![CDATA[<p>相信写过代码的程序猿们都听说过Git的大名，哪怕是刚刚入门的小白，也在GitHub等代码托管网站<code>git clone</code>过他人的代码。那么什么是Git呢？本文将为你讲述Git的前世往生，看完本文，你应该会对版本控制、Git的诞生、Git基本概念和Git的基本特性有了一个初步的认识。</p><a id="more"></a><blockquote><p>注：本文只包含了Git的相关概念，不包含任何命令行代码。</p></blockquote><h2 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a>关于版本控制</h2><p>首先来了解一下什么是“版本控制”：<strong>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</strong>一般情况下是针对程序的源代码文件进行版本控制，但实际上你可以对任何类型的文件进行版本控制。</p><h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。</p><p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异（见图1）。</p><div align="center"><img src="http://image.yingzq.com/img/20190919170521.png" width="350" alt="本地版本控制系统"><p>图1：本地版本控制系统</p></div><p>其中最流行的一种叫做<a href="http://www.gnu.org/software/rcs/" target="_blank" rel="noopener">RCS</a>（Revision Control System），现今许多计算机系统上都还看得到它的踪影。甚至在流行的Mac OS X系统上安装了开发者工具包之后，也可以使用<code>rcs</code>命令。它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，便可以重新计算出各个版本的文件内容。</p><h3 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h3><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作呢？于是，集中化的版本控制系统（Centralized Version Control Systems，简称CVCS）应运而生。</p><p>这类系统，诸如CVS、Subversion以及Perforce等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法（见图2）。</p><div align="center"><img src="http://image.yingzq.com/img/20190919215217.png" width="350" alt="集中化的版本控制系统"><p>图2：集中化的版本控制系统</p></div><p>这种做法带来了许多好处，特别是相较于老式的本地VCS来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个CVCS要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p><h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>为了解决上述版本控制系统存在的问题，分布式版本控制系统（Distributed Version Control System，简称DVCS）诞生了。</p><p>在这类系统中，像Git、Mercurial、Bazaar以及Darcs等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份（见图3）。</p><div align="center"><img src="http://image.yingzq.com/img/20190920092302.png" width="400" alt="分布式版本控制系统"><p>图3：分布式版本控制系统</p></div><p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p><blockquote><p>小结：可以看出分布式版本控制系统相比于本地版本控制和集中化的版本控制有着非常明显的优点。<strong>Git就是一个典型的分布式版本控制系统（DVCS）。</strong></p></blockquote><h2 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h2><p>同生活中的许多伟大事物一样，Git诞生于一个极富纷争大举创新的年代。</p><p>1991年，22岁芬兰程序员Linus Torvalds（后文简称Linus）开源了Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><div align="center"><img src="http://image.yingzq.com/img/20190921191553.png" width="400" alt="Linus"><p>图4：Linus Torvalds</p></div><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p><p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p><p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。<br>实际情况是这样的：<strong>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！</strong>一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p><blockquote><p>小节：Linux的诞生是因为当时还是大学生的Linus觉得好玩编写并开源的；而Git的诞生则是因为Linux社区刚好需要，所以Linus花了两周简单写了一下并开源的，可能这就是大佬吧…</p></blockquote><h2 id="Git的基本特性"><a href="#Git的基本特性" class="headerlink" title="Git的基本特性"></a>Git的基本特性</h2><p>我们已经知道Git是一种分布式版本控制系统，那么Git与其他的版本控制系统的差异是什么？自身的的特性又是什么呢？</p><h3 id="Git直接记录快照，而非差异比较"><a href="#Git直接记录快照，而非差异比较" class="headerlink" title="Git直接记录快照，而非差异比较"></a>Git直接记录快照，而非差异比较</h3><p>Git和其它版本控制系统（包括Subversion和近似工具）的主要差别在于Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（CVS、Subversion、Perforce、Bazaar等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异（见图5）。</p><div align="center"><img src="http://image.yingzq.com/img/20190921212012.png" width="600" alt="存储每个文件与初始版本的差异"><p>图5：存储每个文件与初始版本的差异</p></div><p>Git不按照以上方式对待或保存数据。反之，Git更像是把数据看作是对小型文件系统的一组快照（snapshot）。每次你提交更新，或在Git中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git不再重新存储该文件，而是只保留一个链接指向之前存储的文件（见图6）。Git对待数据更像是一个<strong>快照流</strong>。</p><div align="center"><img src="http://image.yingzq.com/img/20190921212823.png" width="600" alt="存储项目随时间改变的快照"><p>图6：存储项目随时间改变的快照</p></div><p>这是Git与几乎所有其它版本控制系统的重要区别。<strong>Git更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的VCS。</strong>如果你刚刚接触VCS和Git，可能对这句话感触并不深，但是随着你对Git的了解越来越深入，例如在研究Git分支的管理时，会发现这种方式对待数据所能获得的巨大益处。</p><h3 id="Git近乎所有操作都是本地执行"><a href="#Git近乎所有操作都是本地执行" class="headerlink" title="Git近乎所有操作都是本地执行"></a>Git近乎所有操作都是本地执行</h3><p>在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git在这方面会让你感到速度之神赐给了Git超凡的能量。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。</p><p>举个例子，要浏览项目的历史，Git不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><p>这也意味着你离线或者没有VPN时，几乎可以进行任何操作。如你在飞机或火车上想做些工作，你能愉快地提交，直到有网络连接时再上传。如你回家后VPN客户端不正常，你仍能工作。使用其它系统，做到如此是不可能或很费力的。比如，用Perforce，你没有连接服务器时几乎不能做什么事；用Subversion和CVS，你能修改文件，但不能向数据库提交修改（因为你的本地数据库离线了）。这看起来不是大问题，但是你可能会惊喜地发现它带来的巨大的不同。</p><h3 id="Git保证完整性"><a href="#Git保证完整性" class="headerlink" title="Git保证完整性"></a>Git保证完整性</h3><p>Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。这个功能建构在Git底层，是构成Git哲学不可或缺的部分。若你在传送过程中丢失信息或损坏文件，Git就能发现。</p><p>Git用以计算校验和的机制叫做<code>SHA-1</code>散列。这是一个由40个十六进制字符（0-9和a-f）组成的字符串，基于Git中文件的内容或目录结构计算出来。SHA-1哈希看起来是这样：</p><pre><code>24b9da6552252987aa493b52f8696cd6d3b00373</code></pre><h3 id="Git一般只添加数据"><a href="#Git一般只添加数据" class="headerlink" title="Git一般只添加数据"></a>Git一般只添加数据</h3><p>你执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。同别的VCS一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到Git中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><h3 id="Git文件有三种状态"><a href="#Git文件有三种状态" class="headerlink" title="Git文件有三种状态"></a>Git文件有三种状态</h3><p>请注意，如果你希望后面的学习过程更加顺利，这里将是关于Git你最需要记住的一点——<strong>对于任何一个文件，在Git内都只有三种状态：已修改（modified），已暂存（staged）和已提交（committed）。</strong></p><ul><li>已修改表示修改了文件，但还没保存到数据库中</li><li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li><li>已提交表示数据已经安全的保存在本地数据库中</li></ul><p>由此引入Git项目的三个工作区域的概念：工作目录、暂存区域以及Git仓库。</p><div align="center"><img src="http://image.yingzq.com/img/20190923011749.png" width="550" alt="工作目录、暂存区域以及Git仓库"><p>图7：工作目录、暂存区域以及Git仓库</p></div><p>工作目录是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。</p><p>Git仓库目录是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p><p>基本的Git工作流程如下：</p><ol><li>在工作目录中修改文件</li><li>暂存文件，将文件的快照放入暂存区域</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录</li></ol><p>如果Git目录中保存着特定版本的文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你应该已经对Git是什么、Git与你可能正在使用的集中式版本控制系统有何区别等问题有了基本的了解。对于Git的特性，本文也只是简单提及，它的分支管理、代码合并等功能更让人欲罢不能。如今Git已经成为了最流行的开源分布式版本控制系统，它值得你去深入探索研究!</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git Book</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰 Git教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信写过代码的程序猿们都听说过Git的大名，哪怕是刚刚入门的小白，也在GitHub等代码托管网站&lt;code&gt;git clone&lt;/code&gt;过他人的代码。那么什么是Git呢？本文将为你讲述Git的前世往生，看完本文，你应该会对版本控制、Git的诞生、Git基本概念和Git的基本特性有了一个初步的认识。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://www.yingzq.com/tags/Git/"/>
    
  </entry>
  
</feed>
