<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yingzq&#39;s Blog</title>
  
  <subtitle>练习bug时长两年半的实习生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yingzq.com/"/>
  <updated>2019-10-02T03:13:04.992Z</updated>
  <id>http://www.yingzq.com/</id>
  
  <author>
    <name>应子强</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>请务必掌握的Git基础</title>
    <link href="http://www.yingzq.com/2019/10/01/git-basics/"/>
    <id>http://www.yingzq.com/2019/10/01/git-basics/</id>
    <published>2019-10-01T05:03:38.000Z</published>
    <updated>2019-10-02T03:13:04.992Z</updated>
    
    <content type="html"><![CDATA[<p>Git是目前最流行的分布式版本控制系统，值得我们去学会使用并深入了解。本文将会介绍几个最基本的，也是最常用的命令，以后绝大多数时间里用到的可能也就是这几个命令，主要涉及Git的配置、Git仓库的获取、如何记录每次更新到Git仓库、提交历史的查看、Git的撤销操作、Git标签和Git别名等基础知识点，这些是你务必掌握的Git基础！</p><a id="more"></a><h2 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h2><p>在开始阅读前，有几个需要注意的点：</p><ol><li>如果你没听说过Git或者还不了解Git是什么，请参阅文章 <a href="/2019/09/18/what-is-git/" title="What is Git">What is Git</a> 。</li><li>Git有多种使用方式，包括原生的和GUI模式，在这里推荐先使用并熟悉命令行模式，<strong>因为如果你学会了在命令行下如何操作，那么你在操作GUI软件时应该也不会遇到什么困难，但是，反之则不成立。</strong></li></ol><h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>在不同平台上Git安装的方式有一定差异，在这里不详细介绍。值得注意的是，虽然Git具有很好的向后兼容性，但是还是建议大家最好将它升级到最新的版本。</p><p>例如在Ubuntu系统中，可通过如下指令来安装最新稳定版本的Git：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p>在mac系统中则可通过Homebrew来安装最新版本的Git：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure><p>更多的安装指导可查看 <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" target="_blank" rel="noopener">Installing Git</a> 和 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官方下载界面</a> 。</p><p>安装完成后，输入指令<code>git --version</code>，返回正常的版本信息则证明已成功安装Git：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.21.0</span><br></pre></td></tr></table></figure><blockquote><p>注：因为Git的安装是非常方便快捷的，官网也有清晰的指导，所以这一章节讲的非常简略。</p></blockquote><h2 id="初次使用Git前的配置"><a href="#初次使用Git前的配置" class="headerlink" title="初次使用Git前的配置"></a>初次使用Git前的配置</h2><p>在第一次使用一个新编辑器的时候，你会倾向于把字体大小、界面还有需要的插件等统一配置一下，这样在你以后使用这个编辑器的时候，编辑器便会默认载入这些配置，非常的方便。</p><p>Git中也有类似的机制。Git自带一个<code>git config</code>的工具来帮助设置控制Git外观和行为的配置变量，这些变量存储在三个不同的位置：</p><ol><li><code>etc/gitconfig</code>文件: 包含系统上每一个用户及他们仓库的通用配置。如果使用带有<code>--system</code>选项的<code>git config</code>时，它会从此文件读写配置变量。</li><li><code>~/.gitconfig</code>或<code>~/.config/git/config</code>文件：只针对当前用户。可以传递<code>--global</code>选项让Git读写此文件。</li><li>当前使用仓库的Git目录中的config文件（也就是<code>.git/config</code>）：针对该仓库。可以传递<code>--local</code>选项让Git读写此文件，但是其实这个选项是默认的，因此可以省略。</li></ol><p>每一个级别覆盖上一级别的配置，例如<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。</p><p>在Windows系统中，Git会查找<code>$HOME</code>目录下（一般情况下是 C:\Users\$USER）的<code>.gitconfig</code>文件。Git同样也会寻找<code>/etc/gitconfig</code>文件，但只限于MSys的根目录下，即安装Git时所选的目标位置。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>首先你需要设置自己的用户名称和邮箱，这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改（换句话说，不设置用户信息无法进行<code>git commit</code>操作）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;YingZiqiang&quot;</span><br><span class="line">$ git config --global user.email yingzq0116@163.com</span><br></pre></td></tr></table></figure><p>再次强调，如果使用了<code>--global</code>选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有<code>--global</code>选项的命令来配置。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>当Git需要你输入信息时会调用默认的文本编辑器。如果未配置，Git会使用操作系统默认的文本编辑器，通常是Vim。如果你想使用不同的文本编辑器，例如Emacs，可以这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global core.editor emacs</span><br></pre></td></tr></table></figure><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>如果想要检查你的配置，可以使用<code>git config --list</code>命令来列出所有Git当时能找到的配置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name=YingZiqiang</span><br><span class="line">user.email=88629850@qq.com</span><br><span class="line">push.default=simple</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有时候会看到重复的变量名，因为Git可能会从多个配置文件中读取同一个配置变量。这种情况下，<strong>Git会使用它找到的每一个变量的最后一个配置</strong>。</p><p>可以通过输入<code>git config &lt;key&gt;</code>来检查Git的某一项配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">YingZiqiang</span><br></pre></td></tr></table></figure><p>如果你想确认某配置变量的最终决定权的来源，可以输入<code>git config --show-origin &lt;key&gt;</code>查询：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --show-origin user.name</span><br><span class="line">file:/Users/yingzq/.gitconfigYingZiqiang</span><br></pre></td></tr></table></figure><h2 id="Git帮助"><a href="#Git帮助" class="headerlink" title="Git帮助"></a>Git帮助</h2><p>若你使用Git时需要获取帮助，有三种方法可以找到Git命令的使用手册：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure><p>例如，要想获得config命令的手册，执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help config</span><br></pre></td></tr></table></figure><p>另外，如果你不想查看一个Git命令完整的使用手册，仅仅是想要快速查看某些参数的用法，可以通过<code>-h</code>选项来获得一个更加简洁的帮助界面，例如查看<code>git add</code>命令的参数信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add -h</span><br></pre></td></tr></table></figure><blockquote><p>注：你可以随时随地可以使用这些命令而无需联网</p></blockquote><h2 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h2><p>有两种取得Git项目仓库的方法。第一种是在现有项目或目录下导入所有文件到Git中；第二种是从一个服务器克隆一个现有的Git仓库。</p><h3 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h3><p>如果你打算使用Git来对现有的项目进行管理，你只需要进入该项目目录并输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>该命令将创建一个名为<code>.git</code>的子目录，这个子目录含有你初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p><p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化Git仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。你可通过<code>git add</code>命令来实现对指定文件的跟踪，然后执行<code>git commit</code>提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add *.py</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m &apos;initial project version&apos;</span><br></pre></td></tr></table></figure><p>稍后会逐一解释每一条指令的意思。现在，你已经得到了一个实际维护（或者说是跟踪）着若干个文件的Git仓库。</p><h3 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h3><p>如果你想获得一份已经存在了的Git仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到<code>git clone</code>命令。</p><p>克隆仓库的命令格式是<code>git clone [url]</code>。比如，要克隆一个叫“TensorFlow-Examples”的库，可以用下面的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/aymericdamien/TensorFlow-Examples</span><br></pre></td></tr></table></figure><p>这会在当前目录下创建一个名为“TensorFlow-Examples”的目录，并在这个目录下初始化一个<code>.git</code>文件夹，并从远程仓库拉取下所有数据放入<code>.git</code>文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的“TensorFlow-Examples”文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/aymericdamien/TensorFlow-Examples my-tf-examples</span><br></pre></td></tr></table></figure><p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为“my-tf-examples”。</p><p>Git支持多种数据传输协议。上面的例子使用的是<code>https://</code>协议，不过你也可以使用<code>git://</code>协议或者使用例如<code>user@server:path/to/repo.git</code>的SSH传输协议。</p><blockquote><p>注：Git克隆的是该Git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。当你执行<code>git clone</code>命令的时候，默认配置下远程Git仓库中的每一个文件的每一个版本都将被拉取下来。</p></blockquote><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>现在我们手上有了一个真实项目的Git仓库，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p><p><strong>工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。</strong>已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p><div align="center"><img src="http://image.yingzq.com/img/20190927165926.png" width="600" alt="文件的状态变化周期"><p>图1：文件的状态变化周期</p></div><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>要查看哪些文件处于什么状态，可以用<code>git status</code>命令。如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则Git会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是“master”，这是默认的分支名。在这里不用担心不明白分支是什么，这一部分会在 <a href="/2019/09/27/git-branching/" title="Git的杀手锏：分支模型">Git的杀手锏：分支模型</a> 单独讲解。</p><p>如果在项目中创建一个新的<code>README</code>文件，如果之前并不存在这个文件，使用<code>git status</code>命令，你将看到一个新的未跟踪文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &apos;My Project&apos; &gt; README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>在状态报告中可以看到新建的<code>README</code>文件出现在“Untracked files”下面。未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。不过现在的例子中，我们确实想要跟踪管理README这个文件。</p><h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令<code>git add</code>开始跟踪一个文件。所以如果要跟踪<code>README</code>文件，运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure><p>此时再运行<code>git status</code>命令，会看到<code>README</code>文件已被跟踪，并处于暂存状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br></pre></td></tr></table></figure><p>只要在“Changes to be committed”这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用<code>git init</code>后就运行了<code>git add &lt;files&gt;</code>命令，开始跟踪当前目录下的文件。<strong><code>git add</code>命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</strong></p><h3 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h3><p>现在我们来修改一个已被跟踪的文件。如果你修改了一个名为<code>TINY.md</code>的已被跟踪的文件，然后运行<code>git status</code>命令，会看到下面内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>文件<code>TINY.md</code>出现在“Changes not staged for commit”这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行<code>git add</code>命令。<strong><code>git add</code>是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</strong> 现在让我们运行<code>git add</code>将<code>TINY.md</code>放到暂存区，然后再看看<code>git status</code>的输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。</p><p>这里再追加一个小问题，假设此时，你的<code>TINY.md</code>文件存在一些小瑕疵，于是你重新编辑该文件并存盘了，此时运行<code>git status</code>会发生什么呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>怎么回事？现在<code>TINY.md</code>文件同时出现在暂存区和非暂存区。这怎么可能呢？实际上Git只不过暂存了你运行<code>git add</code>命令时的版本，如果你现在提交，<code>TINY.md</code>的版本是你最后一次运行<code>git add</code>命令时的那个版本，而不是你运行<code>git commit</code>时，在工作目录中的当前版本。 所以，运行了<code>git add</code>之后又作了修订的文件，需要重新运行<code>git add</code>把最新版本重新暂存起来：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p><code>git status</code>命令的输出十分详细，但其用语有些繁琐。如果你使用<code>git status -s</code>命令或<code>git status --short</code>命令，你将得到一种更为紧凑的格式输出。运行<code>git status -s</code>，状态报告输出如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">A  README</span><br><span class="line">M  TINY.md</span><br></pre></td></tr></table></figure><p>新添加的未跟踪文件前面有<code>??</code>标记，新添加到暂存区中的文件前面有<code>A</code>标记，修改过的文件前面有<code>M</code>标记。<strong>其中<code>M</code>有两个可以出现的位置，出现在右边的<code>M</code>表示该文件被修改了但是还没放入暂存区，出现在靠左边的<code>M</code>表示该文件被修改了并放入了暂存区。</strong></p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为<code>.gitignore</code>的文件，列出要忽略的文件模式。来看一个实际的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure><p>第一行告诉Git忽略所有以“.o”或“.a”结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。第二行告诉Git忽略所有以波浪符（<code>~</code>）结尾的文件，许多文本编辑软件（比如Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略log，tmp或者pid目录，以及自动生成的文档等等。要养成一开始就设置好<code>.gitignore</code>文件的习惯，以免将来误提交这类无用的文件。</p><p>文件<code>.gitignore</code>的格式规范如下：</p><ul><li>所有空行或者以<code>#</code>开头的行都会被Git忽略。</li><li>可以使用标准的glob模式匹配，并且会在整个工作目录中递归的应用。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上感叹号（<code>!</code>）取反。</li></ul><p>所谓的glob模式是指所使用的简化了的正则表达式。星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code>匹配任何一个列在方括号中的字符（这个例子要么匹配一个a，要么匹配一个b，要么匹配一个c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如<code>[0-9]</code>表示匹配所有0到9的数字）。使用两个星号表示匹配任意中间目录，比如<code>a/**/z</code>可以匹配<code>a/z</code>,<code>a/b/z</code>或<code>a/b/c/z</code>等。</p><p>我们再看一个<code>.gitignore</code>文件的例子：</p><pre><code># no .a files*.a# but do track lib.a, even though you&apos;re ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf</code></pre><blockquote><p>GitHub有一个十分详细的针对数十种项目及语言的<code>.gitignore</code>文件列表，你可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> 找到它。</p></blockquote><h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p>如果<code>git status</code>命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用<code>git diff</code>命令。</p><p><strong>你可能通常会用<code>git diff</code>命令来回答这两个问题：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？</strong>尽管<code>git status</code>已经通过在相应栏下列出文件名的方式回答了这个问题，<code>git diff</code>将通过文件补丁的格式显示具体哪些行发生了改变。</p><p>假如此时你再次编辑<code>TINY.md</code>后不暂存，运行<code>git status</code>会看到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   README</span><br><span class="line">modified:   TINY.md</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入<code>git diff</code>，<strong>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/TINY.md b/TINY.md</span><br><span class="line">index 5818529..f0bfc69 100644</span><br><span class="line">--- a/TINY.md</span><br><span class="line">+++ b/TINY.md</span><br><span class="line">@@ -1,3 +1,3 @@</span><br><span class="line"> tiny data</span><br><span class="line"> modify this file, we add one new line</span><br><span class="line">-fix something</span><br><span class="line">+add one line for test</span><br></pre></td></tr></table></figure><p>若要查看已暂存的将要添加到下次提交里的内容，可以用<code>git diff --cached</code>命令（Git 1.6.1及更高版本还允许使用<code>git diff --staged</code>，效果是相同的，但更好记些），<strong>此命令是将目前已暂存的更改和上次提交的内容进行比较</strong>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff --staged</span><br><span class="line">diff --git a/README b/README</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e69de29</span><br><span class="line">diff --git a/TINY.md b/TINY.md</span><br><span class="line">index f8f5ae1..5818529 100644</span><br><span class="line">--- a/TINY.md</span><br><span class="line">+++ b/TINY.md</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line"> tiny data</span><br><span class="line">+modify this file, we add one new line</span><br><span class="line">+fix something</span><br></pre></td></tr></table></figure><p>请注意，<code>git diff</code>本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。所以有时候你一下子暂存了所有更新过的文件后，运行<code>git diff</code>后却什么也没有，就是这个原因。</p><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>当你的暂存区域已经准备妥当便可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有<code>git add</code>过，否则提交的时候不会记录这些还没暂存起来的变化。这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用<code>git status</code>看下，是不是都已暂存起来了，然后再运行提交命令git commit：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>这种方式会启动默认的文本编辑器以便输入本次提交的说明，需要注意的是，如果输入的提交说明为空你的本次提交将会被中止。</p><p>更常用的方式是在<code>commit</code>命令后添加<code>-m</code>选项，将提交信息与命令放在同一行，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &apos;add README file and fix some bugs in TINY.md&apos;</span><br><span class="line">[master 10114de] add README file and fix some bugs in TINY.md</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><p>现在你已经创建了第一个提交！可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整SHA-1校验和是什么（10114de），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><p>请记住，<strong>提交时记录的是放在暂存区域的快照</strong>。任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p><h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给<code>git commit</code>加上<code>-a</code>选项，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过<code>git add</code>步骤：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">$ git commit -a -m &apos;test the commit -a option&apos;</span><br><span class="line">[master 45f06e1] test the commit -a option</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>可以看到，提交之前不再需要<code>git add</code>文件<code>TINY.md</code>了。</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用<code>git rm</code>命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行<code>git status</code>时就会在“Changes not staged for commit”部分（也就是<strong>未暂存清单</strong>）看到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    TINY.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>然后再运行<code>git rm</code>记录此次移除文件的操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">deleted:    TINY.md</span><br></pre></td></tr></table></figure><p>下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项<code>-f</code>（即force的首字母）。这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被Git恢复。</p><p>另外一种情况是，我们想把文件从暂存区域移除，但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，但是并不想让Git继续跟踪。当你忘记添加<code>.gitignore</code>文件，不小心把一个很大的日志文件或一堆<code>.a</code>这样的编译生成文件添加到暂存区时，这一做法尤其有用。为达到这一目的，使用<code>--cached</code>选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm --cached README</span><br></pre></td></tr></table></figure><p><code>git rm</code>命令后面可以列出文件或者目录的名字，也可以使用glob模式。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm log/\*.log</span><br></pre></td></tr></table></figure><p>注意到星号<code>*</code>之前的反斜杠<code>\</code>，这是非常有必要的，<strong>因为除了拥有shell的文件模式扩展匹配方式，Git还有它自己的文件模式扩展匹配方式。</strong> 此命令会删除<code>log/</code>目录及其子目录下扩展名为<code>.log</code>的所有文件。</p><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>不像其它的VCS系统，Git并不显式跟踪文件移动操作。如果在Git中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过Git非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，可以放到以后再详细了解。</p><p>要在Git中对文件改名，可以这么做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure><p>此时查看状态信息，可以明白无误地看到关于重命名操作的说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git mv TINY.md MY-TOY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">renamed:    TINY.md -&gt; MY-TOY.md</span><br></pre></td></tr></table></figure><p>其实，运行<code>git mv</code>就相当于运行了下面三条命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mv TINY.md MY-TOY.md</span><br><span class="line">$ git rm TINY.md</span><br><span class="line">$ git add MY-TOY.md</span><br></pre></td></tr></table></figure><p>如此分开操作，Git也会意识到这是一次改名，所以不管何种方式结果都一样，但是<code>git mv</code>一个命令代替了第二种方式的三个命令，更加的轻便。<strong>更进一步，你可以使用任何你熟悉的工具来重命名文件，然后只需要记得在提交前，删除老的文件名并添加新的文件名。</strong></p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。完成这个任务最简单而又有效的工具是<code>git log</code>命令。</p><p>首先运行下面的命令获取用于演示的simplegit项目的源代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/schacon/simplegit-progit</span><br></pre></td></tr></table></figure><p>然后在此项目中运行<code>git log</code>，应该会看到下面的输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><p>默认不用任何参数的话，<code>git log</code>会按提交时间列出所有的更新，最近的更新排在最上面。正如你所看到的，这个命令会列出每个提交的SHA-1校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p><code>git log</code>有许多选项可以帮助你搜寻你所要找的提交， 接下来我们先来了解一些最常用的选项。</p><p>一个常用的选项是<code>-p</code>或者说是<code>--patch</code>，用来显示每次提交的内容差异（the patch output）。你也可以限制展示的提交条目数，例如可以加上<code>-2</code>来仅显示最近两次提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log -p -2</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require &apos;rake/gempackagetask&apos;</span><br><span class="line"> spec = Gem::Specification.new do |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   &quot;simplegit&quot;</span><br><span class="line">-    s.version   =   &quot;0.1.0&quot;</span><br><span class="line">+    s.version   =   &quot;0.1.1&quot;</span><br><span class="line">     s.author    =   &quot;Scott Chacon&quot;</span><br><span class="line">     s.email     =   &quot;schacon@gmail.com&quot;</span><br><span class="line">     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line">diff --git a/lib/simplegit.rb b/lib/simplegit.rb</span><br><span class="line">index a0a60ae..47c6340 100644</span><br><span class="line">--- a/lib/simplegit.rb</span><br><span class="line">+++ b/lib/simplegit.rb</span><br><span class="line">@@ -18,8 +18,3 @@ class SimpleGit</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line"> end</span><br><span class="line">-</span><br><span class="line">-if $0 == __FILE__</span><br><span class="line">-  git = SimpleGit.new</span><br><span class="line">-  puts git.show</span><br><span class="line">-end</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>该选项除了显示基本信息之外，还附带了每次<code>commit</code>的变化。当进行代码审查，或者快速浏览某个搭档提交的<code>commit</code>所带来的变化的时候，这个参数就非常有用了。你也可以为<code>git log</code>附带一系列的总结性选项。比如说，如果你想看到每次提交的简略的统计信息，你可以使用<code>--stat</code>选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --stat</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary test code</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb | 5 -----</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |  6 ++++++</span><br><span class="line"> Rakefile         | 23 +++++++++++++++++++++++</span><br><span class="line"> lib/simplegit.rb | 25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+)</span><br></pre></td></tr></table></figure><p>正如你所看到的，<code>--stat</code>选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。在每次提交的最后还有一个总结。</p><p>另外一个常用的选项是<code>--pretty</code>。这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用。比如用<code>oneline</code>将每个提交放在一行显示，查看的提交数很大时非常有用。</p><p><code>git log</code>还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。例如之前看到的<code>-2</code>其实是<code>-&lt;n&gt;</code>选项的写法，其中的n可以是任何整数，表示仅显示最近的若干条提交；另外还有按照时间作限制的选项，比如<code>--since</code>和<code>--until</code>也很有用，还可以给出若干搜索条件，列出符合的提交…</p><p><code>git log</code>的选项非常多，在这里不再一一介绍。总之，<code>git log</code>是一个功能非常齐全、可定制化程度非常高的、能满足你几乎所有查询方式的查看提交历史的命令。</p><h2 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h2><p>在任何一个阶段，你都有可能想要撤消某些操作。这里，我们将会学习几个撤消你所做修改的基本工具。<strong>注意，有些撤消操作是不可逆的，这是在使用Git的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</strong></p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有<code>--amend</code>选项的提交命令尝试重新提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>这个命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p><p>运行该命令后会启动文本编辑器，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &apos;initial commit&apos;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><p>接下来再来学习一下如何操作暂存区域与工作目录中已修改的文件。这些命令在修改文件状态的同时，也会提示如何撤消操作。</p><h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>如果你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了<code>git add *</code>暂存了它们两个。如何只取消暂存两个中的一个呢？<code>git status</code>命令提示了你：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README</span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>在“Changes to be committed”文字正下方，提示使用<code>git reset HEAD &lt;file&gt;...</code>来取消暂存。所以，我们可以这样来取消暂存<code>TINY.md</code>文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD TINY.md</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>可以看到<code>TINY.md</code>文件已经是修改未暂存的状态了。</p><h3 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h3><p>如果你并不想保留对<code>TINY.md</code>文件的修改怎么办？你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？幸运的是，<code>git status</code>也告诉了你应该如何做。在最后一个例子中，未暂存区域是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   TINY.md</span><br></pre></td></tr></table></figure><p>它非常清楚地告诉了你如何撤消之前所做的修改。让我们来按照提示执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- TINY.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   README</span><br></pre></td></tr></table></figure><p>可以看到关于<code>TINY.md</code>的修改已经被撤消了。</p><blockquote><p>请记住，在Git中任何<strong>已提交的</strong>东西几乎总是可以恢复的。甚至那些被删除的分支中的提交或使用<code>--amend</code>选项覆盖的提交也可以恢复。然而，任何你<strong>未提交的</strong>东西丢失后很可能再也找不到了。</p></blockquote><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>为了能在任意Git项目上协作，你需要知道如何管理自己的远程仓库。<strong>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。</strong> 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。在本章节中，将介绍一部分基础的远程管理技能。</p><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行<code>git remote</code>命令。它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到<code>origin</code>，这是Git给你克隆的仓库服务器的默认名字</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/schacon/ticgit</span><br><span class="line">Cloning into &apos;ticgit&apos;...</span><br><span class="line">remote: Enumerating objects: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0), pack-reused 1857</span><br><span class="line">Receiving objects: 100% (1857/1857), 334.04 KiB | 36.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (837/837), done.</span><br><span class="line">$ cd ticgit</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>你也可以指定选项<code>-v</code>，会显示需要读写远程仓库使用的Git保存的简写与其对应的URL。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure><p>如果你的远程仓库不止一个，该命令会将它们全部列出。例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd grit</span><br><span class="line">$ git remote -v</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (push)</span><br><span class="line">cho45     https://github.com/cho45/grit (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure><p>这样我们可以轻松拉取其中任何一个用户的贡献。此外，我们有可能还会有某些远程仓库的推送权限，不过暂时不在此介绍。</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>运行<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加一个新的远程Git仓库，同时指定一个你可以轻松引用的简写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit</span><br><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure><p>现在你可以在命令行中使用字符串<code>pb</code>来代替整个URL。例如，如果你想拉取Paul的仓库中有但你没有的信息，可以运行<code>git fetch pb</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch pb</span><br><span class="line">remote: Enumerating objects: 22, done.</span><br><span class="line">remote: Counting objects: 100% (22/22), done.</span><br><span class="line">remote: Total 43 (delta 22), reused 22 (delta 22), pack-reused 21</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure><p>现在Paul的master分支可以在本地通过<code>pb/master</code>访问到——你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。</p><blockquote><p>关于什么是分支以及如何使用分支将会在 <a href="/2019/09/27/git-branching/" title="Git的杀手锏：分支模型">Git的杀手锏：分支模型</a> 中详细介绍</p></blockquote><h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>就如刚才所见，从远程仓库中获得数据，可以执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用<code>clone</code>命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以“origin”为简写。所以，<code>git fetch origin</code>会抓取克隆（或上一次抓取）后新推送的所有工作。<strong>必须注意<code>git fetch</code>命令会将数据拉取到你的本地仓库，但是它并不会自动合并或修改你当前的工作。</strong> 当准备好时你必须手动将其合并入你的工作。</p><p>如果你有一个分支设置为跟踪一个远程分支，可以使用<code>git pull</code>命令来自动的抓取然后合并远程分支到当前分支。这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code>命令会自动设置本地master分支跟踪克隆的远程仓库的master分支（或不管是什么名字的默认分支）。运行<code>git pull</code>通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。这个命令很简单：<code>git push [remote-name] [branch-name]</code>。当你想要将master分支推送到<code>origin</code>服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。阅读 <a href="/2019/09/27/git-branching/" title="Git的杀手锏：分支模型">Git的杀手锏：分支模型</a> 了解如何推送到远程仓库服务器的详细信息。</p><h3 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用<code>git remote show [remote-name]</code>命令。如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master tracked</span><br><span class="line">    ticgit tracked</span><br><span class="line">  Local branch configured for &apos;git pull&apos;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &apos;git push&apos;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure><p>它同样会列出远程仓库的URL与跟踪分支的信息。这些信息非常有用，它告诉你正处于master分支，并且如果运行<code>git pull</code>，就会抓取所有的远程引用，然后将远程master分支合并到本地master分支。它也会列出拉取到的所有远程引用。</p><p>这是一个经常遇到的简单例子。如果你是Git的重度使用者，那么还可以通过<code>git remote show</code>看到更多的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  URL: https://github.com/my-org/complex-project</span><br><span class="line">  Fetch URL: https://github.com/my-org/complex-project</span><br><span class="line">  Push  URL: https://github.com/my-org/complex-project</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                           tracked</span><br><span class="line">    dev-branch                       tracked</span><br><span class="line">    markdown-strip                   tracked</span><br><span class="line">    issue-43                         new (next fetch will store in remotes/origin)</span><br><span class="line">    issue-45                         new (next fetch will store in remotes/origin)</span><br><span class="line">    refs/remotes/origin/issue-11     stale (use &apos;git remote prune&apos; to remove)</span><br><span class="line">  Local branches configured for &apos;git pull&apos;:</span><br><span class="line">    dev-branch merges with remote dev-branch</span><br><span class="line">    master     merges with remote master</span><br><span class="line">  Local refs configured for &apos;git push&apos;:</span><br><span class="line">    dev-branch                     pushes to dev-branch                     (up to date)</span><br><span class="line">    markdown-strip                 pushes to markdown-strip                 (up to date)</span><br><span class="line">    master                         pushes to master                         (up to date)</span><br></pre></td></tr></table></figure><p>这个命令列出了当你在特定的分支上执行<code>git push</code>会自动地推送到哪一个远程分支。它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行<code>git pull</code>时哪些分支会自动合并。</p><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>如果想要重命名引用的名字可以运行<code>git remote rename</code>去修改一个远程仓库的简写名。例如，想要将<code>pb</code>重命名为<code>paul</code>，可以用<code>git remote rename</code>这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><p>值得注意的是这同样也会修改你的远程分支名字。那些过去引用<code>pb/master</code>的现在会引用<code>paul/master</code>。</p><p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用<code>git remote rm</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>像其他版本控制系统（VCS）一样，Git可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。在本章节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。</p><h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p>在Git中列出已有的标签是非常简单直观的。只需要输入<code>git tag</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br></pre></td></tr></table></figure><p>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。</p><p>你也可以使用特定的模式查找标签。例如，Git自身的源代码仓库包含标签的数量超过500个。如果只对1.8.5系列感兴趣，可以运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -l &apos;v1.8.5*&apos;</span><br><span class="line">v1.8.5</span><br><span class="line">v1.8.5-rc0</span><br><span class="line">v1.8.5-rc1</span><br><span class="line">v1.8.5-rc2</span><br><span class="line">v1.8.5-rc3</span><br><span class="line">v1.8.5.1</span><br><span class="line">v1.8.5.2</span><br><span class="line">v1.8.5.3</span><br><span class="line">v1.8.5.4</span><br><span class="line">v1.8.5.5</span><br></pre></td></tr></table></figure><blockquote><p>注：如果你只是想要列出全部的标签，<code>-l</code>或者<code>--list</code>选项可以省略；但是如果是希望用特定的模式查找标签，<code>-l</code>或<code>--list</code>选项则是必须的</p></blockquote><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。</p><p>然而，附注标签是存储在Git数据库中的一个完整对象。它们是可以被校验的：其中包含打标签者的名字、电子邮件地址、日期时间，还有一个标签信息，并且可以使用GNU Privacy Guard （GPG）签名与验证。<strong>通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</strong></p><h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>在Git中创建一个附注标签是很简单的。最简单的方式是当你在运行<code>tag</code>命令时指定<code>-a</code>选项：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.4 -m &quot;my version 1.4&quot;</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure><p><code>-m</code>选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会运行编辑器要求你输入信息。</p><p>通过使用<code>git show</code>命令可以看到标签信息与对应的提交信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git show v1.4</span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>另一种给提交打标签的方式是使用轻量标签。<strong>轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。</strong> 创建轻量标签，不需要使用<code>-a</code>、<code>-s</code>或<code>-m</code>选项，只需要提供标签名字：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag v1.4-lw</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure><p>这时，如果在标签上运行<code>git show</code>，你不会看到额外的标签信息。命令只会显示出提交信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git show v1.4-lw</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure><h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><p>你也可以对过去的提交打标签。假设提交历史是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &apos;experiment&apos;</span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &apos;experiment&apos;</span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></td></tr></table></figure><p>现在，假设在v1.2时你忘记给项目打标签，也就是在“updated rakefile”提交。你可以在之后补上标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.2 9fceb02</span><br></pre></td></tr></table></figure><h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>默认情况下，<code>git push</code>命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样——你可以运行<code>git push origin [tagname]</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.5</span><br><span class="line">Counting objects: 14, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), done.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure><p>如果想要一次性推送很多标签，也可以使用带有<code>--tags</code>选项的<code>git push</code>命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 1, done.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure><p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>要删除掉你本地仓库上的标签，可以使用命令<code>git tag -d &lt;tagname&gt;</code>。例如，可以使用下面的命令删除掉一个轻量级标签：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -d v1.4-lw</span><br><span class="line">Deleted tag &apos;v1.4-lw&apos; (was e7d5add)</span><br></pre></td></tr></table></figure><p><strong>应该注意的是上述命令并不会从任何远程仓库中移除这个标签</strong>，有两种方式可以从远程仓库中删除标签。</p><p>第一种方式是使用<code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code>来更新你的远程仓库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/v1.4-lw</span><br><span class="line">To /git@github.com:schacon/simplegit.git</span><br><span class="line"> - [deleted]         v1.4-lw</span><br></pre></td></tr></table></figure><p>第二种删除远程仓库标签的方式更加直观：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用<code>git checkout</code>命令。但是这会使你的仓库处于“分离头指针（detacthed HEAD）”状态，这个状态有些不好的副作用：如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。</p><p>因此，如果你需要进行更改，比如说你正在修复旧版本的错误，这通常需要创建一个新分支来进行操作。</p><h2 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h2><p>有一个小技巧可以使你的Git体验更简单、容易、熟悉：<strong>别名</strong></p><p>Git并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的Git命令，可以通过<code>git config</code>来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>这意味着，当要输入<code>git commit</code>时，只需要输入<code>git ci</code>。随着你继续不断地使用Git，可能也会经常使用其他命令，此时不要犹豫，为它创建一个别名吧。</p><p>在创建你认为应该存在的命令时这个技术也会很有用。例如，为了解决取消暂存文件的易用性问题，可以向Git中添加你自己的取消暂存别名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.unstage &apos;reset HEAD --&apos;</span><br></pre></td></tr></table></figure><p>这会使下面的两个命令等价：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git unstage fileA</span><br><span class="line">$ git reset HEAD -- fileA</span><br></pre></td></tr></table></figure><p>这样看起来更清楚一些。通常也会添加一个<code>last</code>命令，像这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.last &apos;log -1 HEAD&apos;</span><br></pre></td></tr></table></figure><p>这样，可以轻松地看到最后一次提交：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit 66938dae3329c7aebe598c2246a8e6af90d04646</span><br><span class="line">Author: Josh Goebel &lt;dreamer3@example.com&gt;</span><br><span class="line">Date:   Tue Aug 26 19:48:51 2008 +0800</span><br><span class="line"></span><br><span class="line">    test for current head</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</span><br></pre></td></tr></table></figure><p>可以看出，Git只是简单地将别名替换为对应的命令。然而，你可能想要执行外部命令，而不是一个Git子命令。如果是那样的话，可以在命令前面加入!符号。如果你自己要写一些与Git仓库协作的工具的话，那会很有用。例如将<code>git visual</code>定义为<code>gitk</code>的别名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.visual &apos;!gitk&apos;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍的Git的内容的确不少，但是这些都是你学习Git务必要掌握的基础。随着你对Git的使用越来越多，你会发现Git的每一个命令都是精简而高效的，他们使得你对文件版本控制变得异常方便快捷。</p><p>Just do it!</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git Book</a></li><li><a href="https://git-scm.com/docs" target="_blank" rel="noopener">Git Documents</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是目前最流行的分布式版本控制系统，值得我们去学会使用并深入了解。本文将会介绍几个最基本的，也是最常用的命令，以后绝大多数时间里用到的可能也就是这几个命令，主要涉及Git的配置、Git仓库的获取、如何记录每次更新到Git仓库、提交历史的查看、Git的撤销操作、Git标签和Git别名等基础知识点，这些是你务必掌握的Git基础！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://www.yingzq.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git的杀手锏：分支模型</title>
    <link href="http://www.yingzq.com/2019/09/27/git-branching/"/>
    <id>http://www.yingzq.com/2019/09/27/git-branching/</id>
    <published>2019-09-27T09:11:55.000Z</published>
    <updated>2019-10-01T14:49:27.210Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Pandas入门</title>
    <link href="http://www.yingzq.com/2019/09/22/pandas-getting-started/"/>
    <id>http://www.yingzq.com/2019/09/22/pandas-getting-started/</id>
    <published>2019-09-22T12:54:20.000Z</published>
    <updated>2019-09-24T03:11:19.037Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="Machine Learning" scheme="http://www.yingzq.com/tags/Machine-Learning/"/>
    
      <category term="Python" scheme="http://www.yingzq.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>NumPy入门</title>
    <link href="http://www.yingzq.com/2019/09/22/numpy-getting-started/"/>
    <id>http://www.yingzq.com/2019/09/22/numpy-getting-started/</id>
    <published>2019-09-22T12:53:26.000Z</published>
    <updated>2019-09-24T03:11:21.860Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="Machine Learning" scheme="http://www.yingzq.com/tags/Machine-Learning/"/>
    
      <category term="Python" scheme="http://www.yingzq.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>The Annotated Transformer</title>
    <link href="http://www.yingzq.com/2019/09/22/the-annotated-transformer/"/>
    <id>http://www.yingzq.com/2019/09/22/the-annotated-transformer/</id>
    <published>2019-09-22T08:22:27.000Z</published>
    <updated>2019-09-22T14:18:32.888Z</updated>
    
    <content type="html"><![CDATA[<p>将要进行…</p><a id="more"></a><p>2017年6月Google发表论文<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">“Attention is All You Need”</a>，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将要进行…&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NLP" scheme="http://www.yingzq.com/tags/NLP/"/>
    
      <category term="Transformer" scheme="http://www.yingzq.com/tags/Transformer/"/>
    
      <category term="Deep Learning" scheme="http://www.yingzq.com/tags/Deep-Learning/"/>
    
      <category term="PyTorch" scheme="http://www.yingzq.com/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>What is Git</title>
    <link href="http://www.yingzq.com/2019/09/18/what-is-git/"/>
    <id>http://www.yingzq.com/2019/09/18/what-is-git/</id>
    <published>2019-09-18T14:19:30.000Z</published>
    <updated>2019-09-27T14:31:21.764Z</updated>
    
    <content type="html"><![CDATA[<p>相信写过代码的程序猿们都听说过Git的大名，哪怕是刚刚入门的小白，也在GitHub等代码托管网站<code>git clone</code>过他人的代码。那么什么是Git呢？本文将为你讲述Git的前世往生，看完本文，你应该会对版本控制、Git的诞生、Git基本概念和Git的基本特性有了一个初步的认识。</p><a id="more"></a><blockquote><p>注：本文只包含了Git的相关概念，不包含任何命令行代码。</p></blockquote><h2 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a>关于版本控制</h2><p>首先来了解一下什么是“版本控制”：<strong>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</strong>一般情况下是针对程序的源代码文件进行版本控制，但实际上你可以对任何类型的文件进行版本控制。</p><h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。</p><p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异（见图1）。</p><div align="center"><img src="http://image.yingzq.com/img/20190919170521.png" width="350" alt="本地版本控制系统"><p>图1：本地版本控制系统</p></div><p>其中最流行的一种叫做<a href="http://www.gnu.org/software/rcs/" target="_blank" rel="noopener">RCS</a>（Revision Control System），现今许多计算机系统上都还看得到它的踪影。甚至在流行的Mac OS X系统上安装了开发者工具包之后，也可以使用<code>rcs</code>命令。它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，便可以重新计算出各个版本的文件内容。</p><h3 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h3><p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作呢？于是，集中化的版本控制系统（Centralized Version Control Systems，简称CVCS）应运而生。</p><p>这类系统，诸如CVS、Subversion以及Perforce等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法（见图2）。</p><div align="center"><img src="http://image.yingzq.com/img/20190919215217.png" width="350" alt="集中化的版本控制系统"><p>图2：集中化的版本控制系统</p></div><p>这种做法带来了许多好处，特别是相较于老式的本地VCS来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个CVCS要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p><h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>为了解决上述版本控制系统存在的问题，分布式版本控制系统（Distributed Version Control System，简称DVCS）诞生了。</p><p>在这类系统中，像Git、Mercurial、Bazaar以及Darcs等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份（见图3）。</p><div align="center"><img src="http://image.yingzq.com/img/20190920092302.png" width="400" alt="分布式版本控制系统"><p>图3：分布式版本控制系统</p></div><p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p><blockquote><p>小结：可以看出分布式版本控制系统相比于本地版本控制和集中化的版本控制有着非常明显的优点。<strong>Git就是一个典型的分布式版本控制系统（DVCS）。</strong></p></blockquote><h2 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h2><p>同生活中的许多伟大事物一样，Git诞生于一个极富纷争大举创新的年代。</p><p>1991年，22岁芬兰程序员Linus Torvalds（后文简称Linus）开源了Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><div align="center"><img src="http://image.yingzq.com/img/20190921191553.png" width="400" alt="Linus"><p>图4：Linus Torvalds</p></div><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p><p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p><p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。<br>实际情况是这样的：<strong>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！</strong>一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p><blockquote><p>小节：Linux的诞生是因为当时还是大学生的Linus觉得好玩编写并开源的；而Git的诞生则是因为Linux社区刚好需要，所以Linus花了两周简单写了一下并开源的，可能这就是大佬吧…</p></blockquote><h2 id="Git的基本特性"><a href="#Git的基本特性" class="headerlink" title="Git的基本特性"></a>Git的基本特性</h2><p>我们已经知道Git是一种分布式版本控制系统，那么Git与其他的版本控制系统的差异是什么？自身的的特性又是什么呢？</p><h3 id="Git直接记录快照，而非差异比较"><a href="#Git直接记录快照，而非差异比较" class="headerlink" title="Git直接记录快照，而非差异比较"></a>Git直接记录快照，而非差异比较</h3><p>Git和其它版本控制系统（包括Subversion和近似工具）的主要差别在于Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（CVS、Subversion、Perforce、Bazaar等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异（见图5）。</p><div align="center"><img src="http://image.yingzq.com/img/20190921212012.png" width="600" alt="存储每个文件与初始版本的差异"><p>图5：存储每个文件与初始版本的差异</p></div><p>Git不按照以上方式对待或保存数据。反之，Git更像是把数据看作是对小型文件系统的一组快照（snapshot）。每次你提交更新，或在Git中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git不再重新存储该文件，而是只保留一个链接指向之前存储的文件（见图6）。Git对待数据更像是一个<strong>快照流</strong>。</p><div align="center"><img src="http://image.yingzq.com/img/20190921212823.png" width="600" alt="存储项目随时间改变的快照"><p>图6：存储项目随时间改变的快照</p></div><p>这是Git与几乎所有其它版本控制系统的重要区别。<strong>Git更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的VCS。</strong>如果你刚刚接触VCS和Git，可能对这句话感触并不深，但是随着你对Git的了解越来越深入，例如在研究Git分支的管理时，会发现这种方式对待数据所能获得的巨大益处。</p><h3 id="Git近乎所有操作都是本地执行"><a href="#Git近乎所有操作都是本地执行" class="headerlink" title="Git近乎所有操作都是本地执行"></a>Git近乎所有操作都是本地执行</h3><p>在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git在这方面会让你感到速度之神赐给了Git超凡的能量。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。</p><p>举个例子，要浏览项目的历史，Git不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><p>这也意味着你离线或者没有VPN时，几乎可以进行任何操作。如你在飞机或火车上想做些工作，你能愉快地提交，直到有网络连接时再上传。如你回家后VPN客户端不正常，你仍能工作。使用其它系统，做到如此是不可能或很费力的。比如，用Perforce，你没有连接服务器时几乎不能做什么事；用Subversion和CVS，你能修改文件，但不能向数据库提交修改（因为你的本地数据库离线了）。这看起来不是大问题，但是你可能会惊喜地发现它带来的巨大的不同。</p><h3 id="Git保证完整性"><a href="#Git保证完整性" class="headerlink" title="Git保证完整性"></a>Git保证完整性</h3><p>Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。这个功能建构在Git底层，是构成Git哲学不可或缺的部分。若你在传送过程中丢失信息或损坏文件，Git就能发现。</p><p>Git用以计算校验和的机制叫做<code>SHA-1</code>散列。这是一个由40个十六进制字符（0-9和a-f）组成的字符串，基于Git中文件的内容或目录结构计算出来。SHA-1哈希看起来是这样：</p><pre><code>24b9da6552252987aa493b52f8696cd6d3b00373</code></pre><h3 id="Git一般只添加数据"><a href="#Git一般只添加数据" class="headerlink" title="Git一般只添加数据"></a>Git一般只添加数据</h3><p>你执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。同别的VCS一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到Git中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><h3 id="Git文件有三种状态"><a href="#Git文件有三种状态" class="headerlink" title="Git文件有三种状态"></a>Git文件有三种状态</h3><p>请注意，如果你希望后面的学习过程更加顺利，这里将是关于Git你最需要记住的一点——<strong>对于任何一个文件，在Git内都只有三种状态：已修改（modified），已暂存（staged）和已提交（committed）。</strong></p><ul><li>已修改表示修改了文件，但还没保存到数据库中</li><li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li><li>已提交表示数据已经安全的保存在本地数据库中</li></ul><p>由此引入Git项目的三个工作区域的概念：工作目录、暂存区域以及Git仓库。</p><div align="center"><img src="http://image.yingzq.com/img/20190923011749.png" width="550" alt="工作目录、暂存区域以及Git仓库"><p>图7：工作目录、暂存区域以及Git仓库</p></div><p>工作目录是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。</p><p>Git仓库目录是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p><p>基本的Git工作流程如下：</p><ol><li>在工作目录中修改文件</li><li>暂存文件，将文件的快照放入暂存区域</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录</li></ol><p>如果Git目录中保存着特定版本的文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你应该已经对Git是什么、Git与你可能正在使用的集中式版本控制系统有何区别等问题有了基本的了解。对于Git的特性，本文也只是简单提及，它的分支管理、代码合并等功能更让人欲罢不能。如今Git已经成为了最流行的开源分布式版本控制系统，它值得你去深入探索研究!</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git Book</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰 Git教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信写过代码的程序猿们都听说过Git的大名，哪怕是刚刚入门的小白，也在GitHub等代码托管网站&lt;code&gt;git clone&lt;/code&gt;过他人的代码。那么什么是Git呢？本文将为你讲述Git的前世往生，看完本文，你应该会对版本控制、Git的诞生、Git基本概念和Git的基本特性有了一个初步的认识。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="http://www.yingzq.com/tags/Git/"/>
    
  </entry>
  
</feed>
