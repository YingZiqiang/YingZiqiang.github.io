<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>一种处理回溯问题的通用方法 | yingzq&#39;s Blog | 练习bug时长两年半的实习生</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="数据结构与算法,算法设计技巧,Java,LeetCode">
    <meta name="description" content="LeetCode中很多问题是和回溯相关的，例如Subsets, Permutations, Combination Sum, Palindrome Partitioning, N-Queens等等，所以本文借助这些题目提取了一种较为通用的思考模式，或者说代码结构来帮助处理这些回溯的问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="一种处理回溯问题的通用方法">
<meta property="og:url" content="http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/index.html">
<meta property="og:site_name" content="yingzq&#39;s Blog">
<meta property="og:description" content="LeetCode中很多问题是和回溯相关的，例如Subsets, Permutations, Combination Sum, Palindrome Partitioning, N-Queens等等，所以本文借助这些题目提取了一种较为通用的思考模式，或者说代码结构来帮助处理这些回溯的问题。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-14T08:51:58.000Z">
<meta property="article:modified_time" content="2020-03-15T09:42:29.864Z">
<meta property="article:author" content="应子强">
<meta property="article:tag" content="数据结构与算法">
<meta property="article:tag" content="算法设计技巧">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="yingzq&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/avatar.jpg">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">应子强</h5>
          <a href="mailto:yingzq0116@163.com" title="yingzq0116@163.com" class="mail">yingzq0116@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签云
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-info-circle"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/YingZiqiang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">一种处理回溯问题的通用方法</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">一种处理回溯问题的通用方法</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-14T08:51:58.000Z" itemprop="datePublished" class="page-time">
  2020-03-14
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Subsets（子集）"><span class="post-toc-number">1.</span> <span class="post-toc-text">Subsets（子集）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Subsets-II（子集-II）"><span class="post-toc-number">2.</span> <span class="post-toc-text">Subsets II（子集 II）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Permutations（全排列）"><span class="post-toc-number">3.</span> <span class="post-toc-text">Permutations（全排列）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Permutations-II（全排列-II）"><span class="post-toc-number">4.</span> <span class="post-toc-text">Permutations II（全排列 II）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Combination-Sum（组合总和）"><span class="post-toc-number">5.</span> <span class="post-toc-text">Combination Sum（组合总和）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Combination-Sum-II（组合总和-II）"><span class="post-toc-number">6.</span> <span class="post-toc-text">Combination Sum II（组合总和 II）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Palindrome-Partitioning（分割回文串）"><span class="post-toc-number">7.</span> <span class="post-toc-text">Palindrome Partitioning（分割回文串）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Generate-Parentheses（括号生成）"><span class="post-toc-number">8.</span> <span class="post-toc-text">Generate Parentheses（括号生成）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#N-Queens（N皇后）"><span class="post-toc-number">9.</span> <span class="post-toc-text">N-Queens（N皇后）</span></a></li></ol>
        </nav>
    </aside>


<article id="post-a-general-approach-to-backtracking-questions"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">一种处理回溯问题的通用方法</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-03-14 16:51:58" datetime="2020-03-14T08:51:58.000Z"  itemprop="datePublished">2020-03-14</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>LeetCode中很多问题是和回溯相关的，例如Subsets, Permutations, Combination Sum, Palindrome Partitioning, N-Queens等等，所以本文借助这些题目提取了一种较为通用的思考模式，或者说代码结构来帮助处理这些回溯的问题。</p>
<a id="more"></a>

<blockquote>
<p>文章主要copy自LeetCode Discuss区的 <a href="https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)" target="_blank" rel="noopener">这篇文章</a> 。另外代码是用 <strong>Java</strong> 写的，但是个人认为语言并不是关键。</p>
</blockquote>
<h2 id="Subsets（子集）"><a href="#Subsets（子集）" class="headerlink" title="Subsets（子集）"></a>Subsets（子集）</h2><p><strong>链接</strong></p>
<p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">leetcode 78题</a></p>
<p><strong>题目</strong></p>
<p>给定一组<code>不含重复元素</code>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Arrays.sort(nums);  // 不需要排序</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res , List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, i + <span class="number">1</span>);  <span class="comment">// 不能重复使用元素，所以需要i+1</span></span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入的<code>nums</code>是<code>[1, 2, 3]</code>，那么该解法输出的结果顺序是：</p>
<p><code>[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]</code></p>
<h2 id="Subsets-II（子集-II）"><a href="#Subsets-II（子集-II）" class="headerlink" title="Subsets II（子集 II）"></a>Subsets II（子集 II）</h2><p><strong>链接</strong></p>
<p><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">LeetCode 90题</a></p>
<p><strong>题目</strong></p>
<p>给定一个可能<code>包含重复元素</code>的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">// 为了方便剔除重复元素，需要排序</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 剔除重复元素</span></span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入的<code>nums</code>是<code>[1, 2, 2]</code>，那么该解法输出的结果顺序是：</p>
<p><code>[[],[1],[1,2],[1,2,2],[2],[2,2]]</code></p>
<h2 id="Permutations（全排列）"><a href="#Permutations（全排列）" class="headerlink" title="Permutations（全排列）"></a>Permutations（全排列）</h2><p><strong>链接</strong></p>
<p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">LeetCode 46题</a></p>
<p><strong>题目</strong></p>
<p>给定一个<code>没有重复数字</code>的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Arrays.sort(nums); // 不含重复元素，不需要排序</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tempList.size() == nums.length) &#123;  <span class="comment">// 判断是否达到终止条件</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>; <span class="comment">// 判断是否访问过该元素</span></span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, visited);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题和Subsets不同的地方在于：本题的每个结果的长度都是<code>nums.length</code>，因此两者的终止条件有差异；另外，Subsets中是使用了<code>start</code>指针来表示目前可以访问元素的范围，也就是<code>start ~ nums.length-1</code>，但是Permutations无法这样做，因为元素访问顺序不同时是能够产生不同结果的，因此使用了<code>visited</code>数组来记录已访问的位置（用HashSet也是可以的）。</p>
<p>如果输入的<code>nums</code>是<code>[1, 2, 3]</code>，那么该解法输出的结果顺序是：</p>
<p><code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></p>
<h2 id="Permutations-II（全排列-II）"><a href="#Permutations-II（全排列-II）" class="headerlink" title="Permutations II（全排列 II）"></a>Permutations II（全排列 II）</h2><p><strong>链接</strong></p>
<p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">LeetCode 47题</a></p>
<p><strong>题目</strong></p>
<p>给定一个<code>可包含重复数字</code>的序列，返回所有不重复的全排列。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">// 需要排序，方便后续处理重复元素</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">boolean</span> [] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) <span class="keyword">continue</span>;  <span class="comment">// 剔除重复元素</span></span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, visited);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中最关键的部分在于<code>剔除重复元素</code>的步骤，当<code>i &gt; 0 &amp;&amp; nums[i] == nums[i-1]</code>时需要进行处理，其实在这里有两种方式都可以处理：</p>
<ol>
<li>当<code>i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !visited[i - 1]</code>时跳过，最终会只保留顺序生成的那一种情况，其余的全部剔除。</li>
<li>当<code>i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; visited[i - 1]</code>时跳过，最终会只保留逆序生成的那一种情况，其余的全部剔除。</li>
</ol>
<p>以第一种处理为例，当输入是<code>[1, 1, 2]</code>时，对应的输出顺序是：</p>
<p><code>[[1,1,2],[1,2,1],[2,1,1]]</code></p>
<h2 id="Combination-Sum（组合总和）"><a href="#Combination-Sum（组合总和）" class="headerlink" title="Combination Sum（组合总和）"></a>Combination Sum（组合总和）</h2><p><strong>链接</strong></p>
<p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">LeetCode 39题</a></p>
<p><strong>题目</strong></p>
<p>给定一个<code>无重复元素</code>的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以<code>无限制重复</code>被选取。</p>
<p>说明：</p>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Arrays.sort(nums);  // 无需排序</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, remain - nums[i], i); <span class="comment">// 因为可以重复使用元素，所以这里不是i+1</span></span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Combination-Sum-II（组合总和-II）"><a href="#Combination-Sum-II（组合总和-II）" class="headerlink" title="Combination Sum II（组合总和 II）"></a>Combination Sum II（组合总和 II）</h2><p><strong>链接</strong></p>
<p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">LeetCode 40题</a></p>
<p><strong>题目</strong></p>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中<code>只能使用一次</code>。</p>
<p>说明：</p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 剔除重复元素</span></span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(res, tempList, nums, remain - nums[i], i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Palindrome-Partitioning（分割回文串）"><a href="#Palindrome-Partitioning（分割回文串）" class="headerlink" title="Palindrome Partitioning（分割回文串）"></a>Palindrome Partitioning（分割回文串）</h2><p><strong>链接</strong></p>
<p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">LeetCode 131题</a></p>
<p><strong>题目</strong></p>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] valid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        valid = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(i) &amp;&amp; (i-j &lt;= <span class="number">2</span> || valid[j+<span class="number">1</span>][i-<span class="number">1</span>]))&#123;</span><br><span class="line">                    valid[j][i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; tempList, String s, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!valid[idx][i]) <span class="keyword">continue</span>;</span><br><span class="line">            String sub = s.substring(idx, i+<span class="number">1</span>);</span><br><span class="line">            tempList.add(sub);</span><br><span class="line">            backtrack(res, tempList, s, i+<span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：这段代码中前面关于构建<code>valid数组</code>的部分使用了动态规划，但是并不是本文的重点，只需要知道<code>valid[i][j]</code>表示<strong>字符串中 i 到 j 位置的元素能否构成回文</strong>即可。</p>
</blockquote>
<h2 id="Generate-Parentheses（括号生成）"><a href="#Generate-Parentheses（括号生成）" class="headerlink" title="Generate Parentheses（括号生成）"></a>Generate Parentheses（括号生成）</h2><p><strong>链接</strong></p>
<p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">LeetCode 22题</a></p>
<p><strong>题目</strong></p>
<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(res, <span class="keyword">new</span> StringBuilder(), n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; res, StringBuilder sb, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span>;  <span class="comment">// 右括号使用比左括号多，舍去</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">'('</span>);</span><br><span class="line">            backtrack(res, sb, left - <span class="number">1</span>, right);</span><br><span class="line">            sb.setLength(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">')'</span>);</span><br><span class="line">            backtrack(res, sb, left, right - <span class="number">1</span>);</span><br><span class="line">            sb.setLength(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和前面几题不同的是，这一题似乎没有<code>for循环</code>，这是因为在某个位置<code>k</code>，括号只有两种状态：<code>(</code>或者<code>)</code>，不需要循环，但是本质是一样的。</p>
<h2 id="N-Queens（N皇后）"><a href="#N-Queens（N皇后）" class="headerlink" title="N-Queens（N皇后）"></a>N-Queens（N皇后）</h2><p><strong>链接</strong></p>
<p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">LeetCode 51题</a></p>
<p><strong>题目</strong></p>
<p>设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入：4</span><br><span class="line"> 输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line"> 解释: 4 皇后问题存在如下两个不同的解法。</span><br><span class="line">[</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] cols, diag1, diag2;  <span class="comment">// 用于判断某位置的列以及两条对角线是否冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        cols = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];  <span class="comment">// 判断列是否冲突</span></span><br><span class="line">        diag1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n];  <span class="comment">// 判断 右上-&gt;左下 的对角线是否冲突，利用 x+y 是定值</span></span><br><span class="line">        diag2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n];  <span class="comment">// 判断 左上-&gt;右下 的对角线是否冲突，利用 x-y 是定值</span></span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; tempList, <span class="keyword">int</span> n, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;  <span class="comment">// 终止条件</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id1 = row - j + n, id2 = row + j;</span><br><span class="line">            <span class="keyword">if</span> (cols[j] || diag1[id1] || diag2[id2]) <span class="keyword">continue</span>;  <span class="comment">// 此位置有冲突，跳过</span></span><br><span class="line">            cols[j] = <span class="keyword">true</span>;</span><br><span class="line">            diag1[id1] = <span class="keyword">true</span>;</span><br><span class="line">            diag2[id2] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">            Arrays.fill(chars, <span class="string">'.'</span>);</span><br><span class="line">            chars[j] = <span class="string">'Q'</span>;</span><br><span class="line">            tempList.add(<span class="keyword">new</span> String(chars));</span><br><span class="line"></span><br><span class="line">            backtrack(res, tempList, n, row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            cols[j] = <span class="keyword">false</span>;</span><br><span class="line">            diag1[id1] = <span class="keyword">false</span>;</span><br><span class="line">            diag2[id2] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然代码长了很多，但是整体的思路是一样的，解决N皇后问题有两个地方值得注意：</p>
<ol>
<li>如何判断二维数组中两个元素是否在同一对角线，这一点在代码中已经解释。</li>
<li>因为每一行只能有一个皇后，所以回溯函数中的 <code>for循环</code> 是针对当前行的所有可能。</li>
</ol>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-03-15T09:42:29.864Z" itemprop="dateUpdated">2020-03-15 17:42:29</time>
</span><br>


        
        若有疑问或者本人有写的不对的地方, 欢迎留言或者直接邮箱反馈至yingzq0116@163.com, 非常感谢您的阅读~
        
    </div>
    
    <footer>
        <a href="http://www.yingzq.com">
            <img src="/img/avatar.jpg" alt="应子强">
            应子强
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/" rel="tag">算法设计技巧</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/&title=《一种处理回溯问题的通用方法》 — yingzq's Blog&pic=http://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/&title=《一种处理回溯问题的通用方法》 — yingzq's Blog&source=LeetCode中很多问题是和回溯相关的，例如Subsets, Permutations, Combination Sum, Palindrome Par..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《一种处理回溯问题的通用方法》 — yingzq's Blog&url=http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/&via=http://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/02/21/sword-finger-offer-notes-part-three/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">《剑指offer第二版》阅读笔记（三）</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'true' == 'true',
            appId: "mGqkrgTscxf4JdcqkEHkFCfs-gzGzoHsz",
            appKey: "PwU9oOfhNnWOKaMaOTqQpiNW",
            avatar: "mm",
            placeholder: "要不要说点什么？",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>应子强 &copy; 2019 - 2020</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">京ICP备19041830号</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/&title=《一种处理回溯问题的通用方法》 — yingzq's Blog&pic=http://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/&title=《一种处理回溯问题的通用方法》 — yingzq's Blog&source=LeetCode中很多问题是和回溯相关的，例如Subsets, Permutations, Combination Sum, Palindrome Par..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《一种处理回溯问题的通用方法》 — yingzq's Blog&url=http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/&via=http://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACu0lEQVR42u3aQZLbMAwEQP//08k1qcTaGYBc76F9ckmyxKaqSBjA6xV/fr357K9/Pv7n2ecnrj54eHh4h4b+763fHXkeSvKrBJPfBw8PD+97eM9L9vOt303B8/Gz+LfH8fDw8H4AL98qNlFuOx48PDy8n89L2LM0RL454eHh4X2W1yYXZoDNlddzLXh4eHiTqHW1QH/n9yv1PTw8PLx1Vf15wc2PbxINbZL3r2fh4eHhXeC1SYFNaWrTUJWHy3h4eHi3eUkqYc+YxcBtEuQ/3/Hw8PAu8No//3la9nmaToXg0XTj4eHhXeDlTQD5cJMrn6/Pr4kKYHh4eHiHeDmpfUybkN2Uvg68MTw8PLxRTqD+kx+kd9ty16mNJ+osw8PDw1vzZkt5vognAXqS8khC81c7r3h4eHglb9YWMFu492nf+ko8PDy8o7xPtQLkQXC7FUVNA3h4eHgL3mx7SJIIyaTMWhOGaV88PDy8Q7xNySo525bHNnmUL94YHh4e3iFesqDvd552m9lMZfQO8fDw8A7x2vamZLh5i8AsJRFtMHh4eHgXeHkSNr/F/uwmKMfDw8O7zWsbBWYNWMni3hbk6mQEHh4e3gXeLGDdhNqzLQEPDw/vU7xNuNy2CEQp19Gz3p7Fw8PDu8BrB5cMepO2ONV8gIeHh3ebl5emZqFt2wqQTHeRsMDDw8O7xmubrvKFO0/7bkLzqACGh4eHd5TXpnQ3gzvVghD9Cg8PD+8ob7bUtumAfApmG9Lb3+Lh4eFd4LVL7WzQeYphNq37jQQPDw+v5bW33gfTCa+t4H1R2cPDw8O7wNss6LN0w3CP2uRa8PDw8D7Ky4v9OabdBqLXgIeHh/cDePlA940Fedri1c4rHh4e3prXNpW2hbG2AJaf/YKKh4eHd4HX/r1PHtBOUE66ksLAw8PDS3m/ATEczxT4sPWSAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来练习bug!';
            clearTimeout(titleTime);
        } else {
            document.title = 'yingzq's Blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
