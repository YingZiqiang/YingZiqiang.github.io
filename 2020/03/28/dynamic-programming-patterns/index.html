<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>论动态规划常见的5种模式 | yingzq&#39;s Blog | 练习bug时长两年半的实习生</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="数据结构与算法,Java,LeetCode,算法设计技巧">
    <meta name="description" content="动态规划（dynamic programming，简称DP）一直是算法面试中最难的话题之一。DP的本质在于如何完整的刻化状态而又使状态不包含冗余信息，这是比较难的一点；另外，不同的DP问题之间似乎并不能用统一的模式来表示，所以往往在做了一些DP题之后遇到新的DP问题还是束手无策（泛化能力差~）。 本文copy自一篇LeetCode Discuss区大佬对DP模式的总结，原文将DP问题大致分成5种模">
<meta property="og:type" content="article">
<meta property="og:title" content="论动态规划常见的5种模式">
<meta property="og:url" content="https://www.yingzq.com/2020/03/28/dynamic-programming-patterns/index.html">
<meta property="og:site_name" content="yingzq&#39;s Blog">
<meta property="og:description" content="动态规划（dynamic programming，简称DP）一直是算法面试中最难的话题之一。DP的本质在于如何完整的刻化状态而又使状态不包含冗余信息，这是比较难的一点；另外，不同的DP问题之间似乎并不能用统一的模式来表示，所以往往在做了一些DP题之后遇到新的DP问题还是束手无策（泛化能力差~）。 本文copy自一篇LeetCode Discuss区大佬对DP模式的总结，原文将DP问题大致分成5种模">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://image.yingzq.com/img/20200401110438.png">
<meta property="og:image" content="http://image.yingzq.com/img/20200401172548.png">
<meta property="og:image" content="http://image.yingzq.com/img/20200402221334.png">
<meta property="og:image" content="http://image.yingzq.com/img/20200403105820.png">
<meta property="og:image" content="http://image.yingzq.com/img/20200403145410.png">
<meta property="og:image" content="http://image.yingzq.com/img/20200403205818.png">
<meta property="article:published_time" content="2020-03-28T02:27:48.000Z">
<meta property="article:modified_time" content="2020-04-04T09:33:16.059Z">
<meta property="article:author" content="应子强">
<meta property="article:tag" content="数据结构与算法">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="算法设计技巧">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://image.yingzq.com/img/20200401110438.png">
    
        <link rel="alternate" type="application/atom+xml" title="yingzq&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/avatar.jpg">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">应子强</h5>
          <a href="mailto:yingzq0116@163.com" title="yingzq0116@163.com" class="mail">yingzq0116@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签云
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-info-circle"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/YingZiqiang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">论动态规划常见的5种模式</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">论动态规划常见的5种模式</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-28T02:27:48.000Z" itemprop="datePublished" class="page-time">
  2020-03-28
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Minimum-Maximum-Path-to-Reach-a-Target"><span class="post-toc-number">1.</span> <span class="post-toc-text">Minimum (Maximum) Path to Reach a Target</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Statement"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Statement</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Approach"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">Approach</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Similar-Problems"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">Similar Problems</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用最小花费爬楼梯-Easy"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">使用最小花费爬楼梯 Easy</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最小路径和-Medium"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">最小路径和 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#零钱兑换-Medium"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">零钱兑换 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#下降路径最小和-Medium"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">下降路径最小和 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最低票价-Medium"><span class="post-toc-number">1.3.5.</span> <span class="post-toc-text">最低票价 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#只有两个键的键盘-Medium"><span class="post-toc-number">1.3.6.</span> <span class="post-toc-text">只有两个键的键盘 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#完全平方数-Medium"><span class="post-toc-number">1.3.7.</span> <span class="post-toc-text">完全平方数 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最后一块石头的重量-II-Medium"><span class="post-toc-number">1.3.8.</span> <span class="post-toc-text">最后一块石头的重量 II Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#三角形最小路径和-Medium"><span class="post-toc-number">1.3.9.</span> <span class="post-toc-text">三角形最小路径和 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#一和零-Medium"><span class="post-toc-number">1.3.10.</span> <span class="post-toc-text">一和零 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最大正方形-Medium"><span class="post-toc-number">1.3.11.</span> <span class="post-toc-text">最大正方形 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#地下城游戏-Hard"><span class="post-toc-number">1.3.12.</span> <span class="post-toc-text">地下城游戏 Hard</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Distinct-Ways"><span class="post-toc-number">2.</span> <span class="post-toc-text">Distinct Ways</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Statement-1"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">Statement</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Approach-1"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">Approach</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Similar-Problems-1"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">Similar Problems</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#爬楼梯-Easy"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">爬楼梯 Easy</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不同路径-Medium"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">不同路径 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不同路径-II-Medium"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">不同路径 II Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#掷骰子的N种方法-Medium"><span class="post-toc-number">2.3.4.</span> <span class="post-toc-text">掷骰子的N种方法 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#“马”在棋盘上的概率-Medium"><span class="post-toc-number">2.3.5.</span> <span class="post-toc-text">“马”在棋盘上的概率 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#目标和-Medium"><span class="post-toc-number">2.3.6.</span> <span class="post-toc-text">目标和 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#组合总和-Ⅳ-Medium"><span class="post-toc-number">2.3.7.</span> <span class="post-toc-text">组合总和 Ⅳ Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#骑士拨号器-Medium"><span class="post-toc-number">2.3.8.</span> <span class="post-toc-text">骑士拨号器 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#分割等和子集-Medium"><span class="post-toc-number">2.3.9.</span> <span class="post-toc-text">分割等和子集 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多米诺和托米诺平铺-Medium"><span class="post-toc-number">2.3.10.</span> <span class="post-toc-text">多米诺和托米诺平铺 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最长递增子序列的个数-Medium"><span class="post-toc-number">2.3.11.</span> <span class="post-toc-text">最长递增子序列的个数 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#出界的路径数-Medium"><span class="post-toc-number">2.3.12.</span> <span class="post-toc-text">出界的路径数 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#停在原地的方案数-Hard"><span class="post-toc-number">2.3.13.</span> <span class="post-toc-text">停在原地的方案数 Hard</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#统计元音字母序列的数目-Hard"><span class="post-toc-number">2.3.14.</span> <span class="post-toc-text">统计元音字母序列的数目 Hard</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Merging-Intervals"><span class="post-toc-number">3.</span> <span class="post-toc-text">Merging Intervals</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Statement-2"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">Statement</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Approach-2"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">Approach</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Similar-Problems-2"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">Similar Problems</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不同的二叉搜索树-Medium"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">不同的二叉搜索树 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多边形三角剖分的最低得分-Medium"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">多边形三角剖分的最低得分 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#猜数字大小-II-Medium"><span class="post-toc-number">3.3.3.</span> <span class="post-toc-text">猜数字大小 II Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#合并石头的最低成本-Hard"><span class="post-toc-number">3.3.4.</span> <span class="post-toc-text">合并石头的最低成本 Hard</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#戳气球-Hard"><span class="post-toc-number">3.3.5.</span> <span class="post-toc-text">戳气球 Hard</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#DP-on-Strings"><span class="post-toc-number">4.</span> <span class="post-toc-text">DP on Strings</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Statement-3"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">Statement</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Approach-3"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Approach</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Similar-Problems-3"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">Similar Problems</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最长公共子序列-Medium"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">最长公共子序列 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#两个字符串的最小ASCII删除和-Medium"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">两个字符串的最小ASCII删除和 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#回文子串-Medium"><span class="post-toc-number">4.3.3.</span> <span class="post-toc-text">回文子串 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最长回文子串-Medium"><span class="post-toc-number">4.3.4.</span> <span class="post-toc-text">最长回文子串 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最长回文子序列-Medium"><span class="post-toc-number">4.3.5.</span> <span class="post-toc-text">最长回文子序列 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最短公共超序列-Hard"><span class="post-toc-number">4.3.6.</span> <span class="post-toc-text">最短公共超序列 Hard</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#编辑距离-Hard"><span class="post-toc-number">4.3.7.</span> <span class="post-toc-text">编辑距离 Hard</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不同的子序列-Hard"><span class="post-toc-number">4.3.8.</span> <span class="post-toc-text">不同的子序列 Hard</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Decision-Making"><span class="post-toc-number">5.</span> <span class="post-toc-text">Decision Making</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Statement-4"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">Statement</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Approach-4"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">Approach</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Similar-Problems-4"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">Similar Problems</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#打家劫舍-Easy"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">打家劫舍 Easy</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#买卖股票的最佳时机-II-Easy"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">买卖股票的最佳时机 II Easy</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#买卖股票的最佳时机含手续费-Medium"><span class="post-toc-number">5.3.3.</span> <span class="post-toc-text">买卖股票的最佳时机含手续费 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最佳买卖股票时机含冷冻期-Medium"><span class="post-toc-number">5.3.4.</span> <span class="post-toc-text">最佳买卖股票时机含冷冻期 Medium</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#买卖股票的最佳时机-III-IV-Hard"><span class="post-toc-number">5.3.5.</span> <span class="post-toc-text">买卖股票的最佳时机 III&#x2F;IV Hard</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-dynamic-programming-patterns"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">论动态规划常见的5种模式</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-03-28 10:27:48" datetime="2020-03-28T02:27:48.000Z"  itemprop="datePublished">2020-03-28</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>动态规划（dynamic programming，简称DP）一直是算法面试中最难的话题之一。DP的本质在于如何完整的刻化状态而又使状态不包含冗余信息，这是比较难的一点；另外，不同的DP问题之间似乎并不能用统一的模式来表示，所以往往在做了一些DP题之后遇到新的DP问题还是束手无策（泛化能力差~）。</p>
<p>本文copy自一篇LeetCode Discuss区大佬对DP模式的总结，原文将DP问题大致分成5种模式，并给出了相应解决方案的思路，感觉让我获益匪浅，因此文本也将原文提到的题目列表基本实现了一遍（删掉了少量较复杂的题）。</p>
<p>原文作者对常见的DP问题分为5种模式（patterns）：</p>
<ul>
<li>Minimum (Maximum) Path to Reach a Target</li>
<li>Distinct Ways</li>
<li>Merging Intervals</li>
<li>DP on Strings</li>
<li>Decision Making</li>
</ul>
<p>下文分别对这5种模型进行讲解，说明一下，其中 “Statement” 代表 “此类模式问题的一般描述” ，”Approach” 代表 “此类问题的解题套路” ，”Similar Problems” 代表 “与此类模式相关的leetcode原题”，本文将给出相应的解答。</p>
<blockquote>
<p>注：原文链接 <a href="https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns" target="_blank" rel="noopener">Dynamic Programming Patterns</a> 。另外，原文的表达挺好的，所以原文大部分的英文表达做了保留，emmm，因此文章看起来可能是中英混杂的，但是不妨碍阅读。</p>
</blockquote>
<h2 id="Minimum-Maximum-Path-to-Reach-a-Target"><a href="#Minimum-Maximum-Path-to-Reach-a-Target" class="headerlink" title="Minimum (Maximum) Path to Reach a Target"></a>Minimum (Maximum) Path to Reach a Target</h2><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>Given a target find minimum (maximum) cost / path / sum to reach the target.</p>
<h3 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h3><p>Choose minimum (maximum) path among all possible paths before the current state, then add value for the current state.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">routes[i] &#x3D; min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]</span><br></pre></td></tr></table></figure>

<p>Generate optimal solutions for all values in the target and return the value for the target.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ways.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (ways[j] &lt;= i) &#123;</span><br><span class="line">           dp[i] = <span class="built_in">min</span>(dp[i], dp[i - ways[j]] + cost / path / sum) ;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>

<h3 id="Similar-Problems"><a href="#Similar-Problems" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p>列举如下：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a> <strong>Easy</strong></li>
<li><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">931. 下降路径最小和</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">983. 最低票价</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/2-keys-keyboard/" target="_blank" rel="noopener">650. 只有两个键的键盘</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/" target="_blank" rel="noopener">1049. 最后一块石头的重量 II</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">174. 地下城游戏</a> <strong>Hard</strong></li>
</ul>
<h4 id="使用最小花费爬楼梯-Easy"><a href="#使用最小花费爬楼梯-Easy" class="headerlink" title="使用最小花费爬楼梯 Easy"></a>使用最小花费爬楼梯 Easy</h4><p><strong>题目</strong></p>
<p>数组的每个索引做为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i] (索引从0开始)。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: cost &#x3D; [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br><span class="line"></span><br><span class="line">输入: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>cost 的长度将会在 [2, 1000]。</li>
<li>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</li>
</ul>
<p><strong>分析</strong></p>
<p>到达<code>dp[i]</code>位置的方式只有<code>dp[i-1]</code>和<code>dp[i-2]</code>，因此很容易得到状态转移方程：</p>
<p><code>dp[i] = min(dp[i-1], dp[i-2]) + cost[i]</code></p>
<p>另外在最后<code>i == n</code>的位置需要特殊处理，所以总体的状态转移方程如下：</p>
<p><code>dp[i] = min(dp[i-1], dp[i-2]) + (i == n ? 0 : cost[i])</code></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cost.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + (i == n ? <span class="number">0</span> : cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最小路径和-Medium"><a href="#最小路径和-Medium" class="headerlink" title="最小路径和 Medium"></a>最小路径和 Medium</h4><p><strong>题目</strong></p>
<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p><strong>分析</strong></p>
<p>直接得出状态转移方程<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code>。</p>
<p>从空间复杂度角度考虑，这题不需要开辟一个新的dp数组，直接把原数组当做dp数组用，即：</p>
<p><code>grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]</code> 。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            grid[i][j] += Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="零钱兑换-Medium"><a href="#零钱兑换-Medium" class="headerlink" title="零钱兑换 Medium"></a>零钱兑换 Medium</h4><p><strong>题目</strong></p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3</span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br><span class="line"></span><br><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<p>说明: 你可以认为每种硬币的数量是无限的。</p>
<p><strong>分析</strong></p>
<p>状态转移方程：<code>dp[i] = min(dp[i-coin_1], dp[i-coin_2], ... , dp[i-coin_k]) + 1</code>，另外要考虑不存在的情况。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[amount] == amount + <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="下降路径最小和-Medium"><a href="#下降路径最小和-Medium" class="headerlink" title="下降路径最小和 Medium"></a>下降路径最小和 Medium</h4><p><strong>题目</strong></p>
<p>给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。</p>
<p>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：12</span><br><span class="line">解释：</span><br><span class="line">可能的下降路径有：</span><br><span class="line">[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]</span><br><span class="line">[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]</span><br><span class="line">[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]</span><br><span class="line">其中和最小的下降路径是 [1,4,7]，所以答案是 12。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>状态转移方程：<code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + A[i][j]</code>。</p>
<p>同样，我们可以在原数组A上进行修改，但是这样就会产生边界问题，需要小心处理。</p>
<blockquote>
<p>注：如果是自己生成dp数组，我们可以进行套壳处理，这样就不用处理那么多的边界了，但是这里为了省空间还是在原数组上进行修改。</p>
</blockquote>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span> || A[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = A.length, n = A[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = A[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) min = Math.min(min, A[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n - <span class="number">1</span>) min = Math.min(min, A[i - <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">            A[i][j] = min + A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : A[m - <span class="number">1</span>]) &#123;</span><br><span class="line">        res = Math.min(res, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最低票价-Medium"><a href="#最低票价-Medium" class="headerlink" title="最低票价 Medium"></a>最低票价 Medium</h4><p><strong>题目</strong></p>
<p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p>
<p>火车票有三种不同的销售方式：</p>
<ul>
<li>一张为期一天的通行证售价为 costs[0] 美元；</li>
<li>一张为期七天的通行证售价为 costs[1] 美元；</li>
<li>一张为期三十天的通行证售价为 costs[2] 美元。</li>
</ul>
<p>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：days &#x3D; [1,4,6,7,8,20], costs &#x3D; [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 1 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 1 天生效。</span><br><span class="line">在第 3 天，你花了 costs[1] &#x3D; $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。</span><br><span class="line">在第 20 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;= days.length &lt;= 365</li>
<li>1 &lt;= days[i] &lt;= 365</li>
<li>days 按顺序严格递增</li>
<li>costs.length == 3</li>
<li>1 &lt;= costs[i] &lt;= 1000</li>
</ul>
<p><strong>分析</strong></p>
<p>状态转移方程：</p>
<ul>
<li>如果 i 不在 days中，<code>dp[i] = dp[i-1]</code></li>
<li>如果 i 在 days中，<code>dp[i] = min(dp[i-1]+costs[0], dp[i-7]+costs[1], dp[i-30]+costs[2])</code></li>
</ul>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastDay = days[days.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">boolean</span>[] dayIncluded = <span class="keyword">new</span> <span class="keyword">boolean</span>[lastDay + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> day : days) dayIncluded[day] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lastDay + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lastDay; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dayIncluded[i]) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = dp[i - <span class="number">1</span>] + costs[<span class="number">0</span>];</span><br><span class="line">        min = Math.min(min, dp[Math.max(<span class="number">0</span>, i - <span class="number">7</span>)] + costs[<span class="number">1</span>]);</span><br><span class="line">        min = Math.min(min, dp[Math.max(<span class="number">0</span>, i - <span class="number">30</span>)] + costs[<span class="number">2</span>]);</span><br><span class="line">        dp[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[lastDay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="只有两个键的键盘-Medium"><a href="#只有两个键的键盘-Medium" class="headerlink" title="只有两个键的键盘 Medium"></a>只有两个键的键盘 Medium</h4><p><strong>题目</strong></p>
<p>最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作：</p>
<ol>
<li>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。</li>
<li>Paste (粘贴) : 你可以粘贴你上一次复制的字符。</li>
</ol>
<p>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">最初, 我们只有一个字符 &#39;A&#39;。</span><br><span class="line">第 1 步, 我们使用 Copy All 操作。</span><br><span class="line">第 2 步, 我们使用 Paste 操作来获得 &#39;AA&#39;。</span><br><span class="line">第 3 步, 我们使用 Paste 操作来获得 &#39;AAA&#39;。</span><br></pre></td></tr></table></figure>

<p>说明: n 的取值范围是 [1, 1000] 。</p>
<p><strong>分析</strong></p>
<p>令C=Copy All，P=Paste。</p>
<p>如果 n 是一个质数，那么只能通过 CPPP… 来获得，其中包括 1个C 与 n-1个P，一共 n 次操作。<br>如果 n 是 一个合数，例如 n=15=5*3，那么我们可以先得到一个5，然后再进行 CPP 获得 15；或者先得到一个 3，然后进行 CPPPP 获得 15。此时的状态转移方程是：</p>
<p>$$dp[i] = min(dp[j_1]+(i/j_1), dp[j_2]+(i/j_2), … , dp[j_k]+(i/j_k))$$</p>
<p>其中$j_1, j_2, … , j_k$均可以被$i$整除。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[j] + (i / j));</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i / j] + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实上述代码并不是最优的，可以证明当$j$是合数$i$的最大因子时，<code>dp[i] = dp[j] + (i / j)</code>有最小结果，这部分不是重点，就不展开了，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i / <span class="number">2</span>; j &gt; <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = dp[j] + (i / j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完全平方数-Medium"><a href="#完全平方数-Medium" class="headerlink" title="完全平方数 Medium"></a>完全平方数 Medium</h4><p><strong>题目</strong></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3</span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>其实就是一个Coin Change问题，此时的coins就是小于i的所有完全平方数。</p>
<p>状态转移方程如下：<code>dp[i] = min(dp[i-1], dp[i-4], dp[i-9], ...) + 1</code></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最后一块石头的重量-II-Medium"><a href="#最后一块石头的重量-II-Medium" class="headerlink" title="最后一块石头的重量 II Medium"></a>最后一块石头的重量 II Medium</h4><p><strong>题目</strong></p>
<p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 x == y，那么两块石头都会被完全粉碎；</li>
<li>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</li>
</ul>
<p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;= stones.length &lt;= 30</li>
<li>1 &lt;= stones[i] &lt;= 1000</li>
</ul>
<p><strong>分析</strong></p>
<p>这个问题等价于将所有石头分成两组，并且这两组重量的差异值diff是最小的。</p>
<p>(1) S1 + S2  = S<br>(2) S1 - S2 = diff</p>
<p>==&gt; diff = S - 2 * S2  ==&gt; 最小化diff等价于最大化S2。</p>
<p>因此我们需要最大化 S2，其中 S2 的范围在0至S/2之间。（其实就是<strong>0-1背包问题</strong>）</p>
<p>这里多写一点。首先我们使用一个二维数组<code>dp[i][j]</code>表示如下含义：使用前 i 种已经出现的石头，在背包容量为 j 的情况下，能得到的最大值。我们有如下状态转移方程：</p>
<ul>
<li>如果stones[i] &gt; j，证明石头 i 放不下，因此<code>dp[i][j] = dp[i-1][j]</code></li>
<li>如果stones[i] &lt;= j，此时既可以放石头 i，也可以不放，有<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-stones[i]] + stones[i])</code></li>
</ul>
<p>上述更新过程只和上一行有关，因此我们可以对空间更进一步的优化：只使用一行，也就是使用一维的dp数组在每轮迭代中复用。但是我们注意到更新<code>dp[j]</code>的时候会用到<code>dp[j-stones[i]]</code>，先更新左边的值会出现问题，因此我们可以从右向左更新！</p>
<p>此时我们有如下状态转移方程：</p>
<ul>
<li>如果stones[i] &gt; j，<code>dp[j]不变</code></li>
<li>如果stones[i] &lt;= j，<code>dp[j] = max(dp[j], dp[j-stones[i]] + stones[i])</code></li>
</ul>
<blockquote>
<p>对于背包问题，在崔添翼大佬的 <a href="https://github.com/tianyicui/pack" target="_blank" rel="noopener">背包九讲</a> 中讲的非常棒，非常值得一看。为了方便可以在 <a href="http://image.yingzq.com/files/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2V2.pdf" target="_blank" rel="noopener">这里</a> 在线阅读。</p>
</blockquote>
<p><strong>Java代码</strong></p>
<p>使用二维dp数组的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) sum += stone;</span><br><span class="line">    <span class="keyword">int</span> n = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[stones.length + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= stones.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - <span class="number">2</span> * dp[stones.length][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一维dp数组的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) sum += stone;</span><br><span class="line">    <span class="keyword">int</span> n = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= stone; j--) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - stone] + stone);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - <span class="number">2</span> * dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三角形最小路径和-Medium"><a href="#三角形最小路径和-Medium" class="headerlink" title="三角形最小路径和 Medium"></a>三角形最小路径和 Medium</h4><p><strong>题目</strong></p>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p><strong>示例</strong></p>
<p>例如，给定三角形：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<p>说明：</p>
<p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<p><strong>分析</strong></p>
<p>首先先不考虑任何优化，我们自上而下的考虑，建立<code>dp[i][j]</code>，代表到达第 i 行、第 j 列位置的最小路径和。有如下转移方程：</p>
<p><code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]</code></p>
<p>最后的结果是最后一行的最小值，即<code>result = min(dp[last_row][j]), j = 0, 1, 2 ...</code>。</p>
<p>因为<code>dp[i][j]</code>只用到了<code>dp[i-1][j-1], dp[i-1][j]</code>，很容易想到的就只使用一维的dp数组：</p>
<p><code>dp[j] = min(dp[j-1], dp[j]) + triangle[i][j], j = i, i-1, ... , 0</code>。</p>
<p>另外，这一题其实自下而上的考虑更加简单，此时的状态转移方程为：</p>
<p><code>dp[j] = min(dp[j], dp[j+1]) + triangle[i][j], j = 0, 1, 2, ... , i</code></p>
<p>最后的结果就是<code>dp[0]</code>，即<code>result = dp[0]</code>。</p>
<blockquote>
<p>注意体会将二维dp数组优化为一维dp数组的时候， j 什么时候升序遍历，什么时候降序遍历。</p>
</blockquote>
<p><strong>Java代码</strong></p>
<p>自上而下使用二维dp数组的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + triangle.get(i).get(j);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + triangle.get(i).get(j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        res = Math.min(res, dp[n - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自上而下使用一维dp数组的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] += triangle.get(i).get(j);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>] + triangle.get(i).get(j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res = Math.min(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自下而上使用一维dp数组的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j + <span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还有一点可以优化：并不用建立dp数组，直接借助triangle的最后一行原地修改。</p>
</blockquote>
<h4 id="一和零-Medium"><a href="#一和零-Medium" class="headerlink" title="一和零 Medium"></a>一和零 Medium</h4><p><strong>题目</strong></p>
<p>在计算机界中，我们总是追求用有限的资源获取最大的收益。</p>
<p>现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。</p>
<p>你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。</p>
<p>注意:</p>
<ul>
<li>给定 0 和 1 的数量都不会超过 100。</li>
<li>给定字符串数组的长度不会超过 600。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: Array &#x3D; &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m &#x3D; 5, n &#x3D; 3</span><br><span class="line">输出: 4</span><br><span class="line">解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 &quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>仔细想想，其实就是一个 <strong>二维费用的0-1背包问题</strong> 。</p>
<p>令<code>dp[k][i][j]</code>代表：利用前 k 个字符串，i 个 0，j 个 1 所能组合出的最大字符串数量。</p>
<p>假设第 k 个字符串有 c_0 个 0，c_1 个 1，得出状态转移方程如下：</p>
<p><code>dp[k][i][j] = max(dp[k-1][i][j], dp[k-1][i - c_0][j - c_1] + 1)</code></p>
<p>同样的，和0-1背包问题一样，我们可以将三维的dp数组优化为二维，需要注意的是 <strong>i 和 j 均需要逆序遍历</strong>。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cnt = count(str);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= cnt[<span class="number">0</span>] &amp;&amp; j &gt;= cnt[<span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = Math.max(dp[i][j], dp[i - cnt[<span class="number">0</span>]][j - cnt[<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] count(String str) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            cnt[c - <span class="string">'0'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最大正方形-Medium"><a href="#最大正方形-Medium" class="headerlink" title="最大正方形 Medium"></a>最大正方形 Medium</h4><p><strong>题目</strong></p>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>令<code>dp[i][j]</code>表示以 (i, j) 为右下角的最大正方形的边长，得到状态转移方程：</p>
<p><code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>], Math.min(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">            maxSide = Math.max(maxSide, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="地下城游戏-Hard"><a href="#地下城游戏-Hard" class="headerlink" title="地下城游戏 Hard"></a>地下城游戏 Hard</h4><p><strong>题目</strong></p>
<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
<div align=left>
<img src="http://image.yingzq.com/img/20200401110438.png" width="220" />
</div>

<p>说明:</p>
<ul>
<li>骑士的健康点数没有上限。</li>
<li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li>
</ul>
<p><strong>分析</strong></p>
<p>如果从左上角迭代至右下角，在每个位置 (i, j) 需要记录：</p>
<ol>
<li>到达此位置的最小生命值</li>
<li>到达此位置还剩下的生命值（这里并不是取此时剩下的最大生命值，计算起来似乎还需要未来的状态）</li>
</ol>
<p>这似乎难以实现…</p>
<p>如果反向遍历，从右下角迭代至左上角，会发现只需要记录到达该位置的最小生命值。因为到达该位置还剩下的生命值一定是大于等于最小生命值的。</p>
<p>用<code>dp[i][j]</code>表示 (i, j) 所需要的最小生命值，可得到状态转移方程：</p>
<p><code>dp[i][j] = min(dp[i+1][j], dp[i][j+1]) + (-dungeon[i][j])</code></p>
<p>其中如果<code>dp[i][j] &lt;= 0</code>，令<code>dp[i][j] = 1</code>。</p>
<p>最后，可以原地进行修改降低空间复杂度。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dungeon == <span class="keyword">null</span> || dungeon.length == <span class="number">0</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = dungeon.length, n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">    dungeon[m - <span class="number">1</span>][n - <span class="number">1</span>] = dungeon[m - <span class="number">1</span>][n - <span class="number">1</span>] &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">1</span> - dungeon[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> need = dungeon[i + <span class="number">1</span>][n - <span class="number">1</span>] - dungeon[i][n - <span class="number">1</span>];</span><br><span class="line">        dungeon[i][n - <span class="number">1</span>] = need &lt;= <span class="number">0</span> ? <span class="number">1</span> : need;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> need = dungeon[m - <span class="number">1</span>][j + <span class="number">1</span>] - dungeon[m - <span class="number">1</span>][j];</span><br><span class="line">        dungeon[m - <span class="number">1</span>][j] = need &lt;= <span class="number">0</span> ? <span class="number">1</span> : need;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> need = Math.min(dungeon[i + <span class="number">1</span>][j], dungeon[i][j + <span class="number">1</span>]) - dungeon[i][j];</span><br><span class="line">            dungeon[i][j] = need &lt;= <span class="number">0</span> ? <span class="number">1</span> : need;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dungeon[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Distinct-Ways"><a href="#Distinct-Ways" class="headerlink" title="Distinct Ways"></a>Distinct Ways</h2><h3 id="Statement-1"><a href="#Statement-1" class="headerlink" title="Statement"></a>Statement</h3><p>Given a target find a number of distinct ways to reach the target.</p>
<h3 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach"></a>Approach</h3><p>Sum all possible ways to reach the current state.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">routes[i] &#x3D; routes[i-1] + routes[i-2], ... , + routes[i-k]</span><br></pre></td></tr></table></figure>

<p>Generate sum for all values in the target and return the value for the target.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ways.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (ways[j] &lt;= i) &#123;</span><br><span class="line">           dp[i] += dp[i - ways[j]];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note:</strong> Some questions point out the number of repetitions, in that case, add one more loop to simulate every repetition.</p>
</blockquote>
<h3 id="Similar-Problems-1"><a href="#Similar-Problems-1" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p>列举如下：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a> <strong>Easy</strong></li>
<li><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/" target="_blank" rel="noopener">1155. 掷骰子的N种方法</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/knight-probability-in-chessboard/" target="_blank" rel="noopener">688. “马”在棋盘上的概率</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494. 目标和</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. 组合总和 Ⅳ</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/knight-dialer/" target="_blank" rel="noopener">935. 骑士拨号器</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/domino-and-tromino-tiling/" target="_blank" rel="noopener">790. 多米诺和托米诺平铺</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/" target="_blank" rel="noopener">673. 最长递增子序列的个数</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/out-of-boundary-paths/" target="_blank" rel="noopener">576. 出界的路径数</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" target="_blank" rel="noopener">1269. 停在原地的方案数</a> <strong>Hard</strong></li>
<li><a href="https://leetcode-cn.com/problems/count-vowels-permutation/" target="_blank" rel="noopener">1220. 统计元音字母序列的数目</a> <strong>Hard</strong></li>
</ul>
<h4 id="爬楼梯-Easy"><a href="#爬楼梯-Easy" class="headerlink" title="爬楼梯 Easy"></a>爬楼梯 Easy</h4><p><strong>题目</strong></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p><strong>分析</strong></p>
<p>状态转移方程<code>dp[i] = dp[i-1] + dp[i-2]</code>。</p>
<p>其中空间可以优化为$O(1)$。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>, second = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = first;</span><br><span class="line">            first = second;</span><br><span class="line">            second = first + temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不同路径-Medium"><a href="#不同路径-Medium" class="headerlink" title="不同路径 Medium"></a>不同路径 Medium</h4><p><strong>题目</strong></p>
<p>一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p>
<p>问总共有多少条不同的路径？</p>
<p>提示：</p>
<ul>
<li>1 &lt;= m, n &lt;= 100</li>
<li>题目数据保证答案小于等于 2 * 10 ^ 9</li>
</ul>
<p><strong>分析</strong></p>
<p>首先考虑二维dp数组，有<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>。</p>
<p>很明显，可以优化为一维dp数组，有<code>dp[j] = dp[j] + dp[j-1], j = 1, 2, 3, ... , n</code>。</p>
<p>注意，这里 j 的遍历是升序，因为<code>dp[i][j]</code>用到的是<code>dp[i][j-1]</code>而不是<code>dp[i-1][j-1]</code>，类似于完全背包问题和0-1背包问题的区别。</p>
<blockquote>
<p>本题其实可以用排列组合来做，在这里就不探讨了。</p>
</blockquote>
<p><strong>Java代码</strong></p>
<p>使用二维dp数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一维dp数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不同路径-II-Medium"><a href="#不同路径-II-Medium" class="headerlink" title="不同路径 II Medium"></a>不同路径 II Medium</h4><p><strong>题目</strong></p>
<p>一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>说明：</p>
<ul>
<li>网格中的障碍物和空位置分别用 1 和 0 来表示。</li>
<li>m 和 n 的值均不超过 100。</li>
</ul>
<p><strong>分析</strong></p>
<p>解法其实和上一题很像，就不解释了。</p>
<p>有个优化的地方是，现在的输入是一个二维数组，所以可以直接在输入数组上进行操作，空间复杂度为$O(1)$。</p>
<p><strong>Java代码</strong></p>
<p>利用一维dp数组相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] row : obstacleGrid) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[j] == <span class="number">1</span>) dp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里dp数组建立 n 大小以及 n+1 大小都是可以的。</p>
</blockquote>
<p>原地更新相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> - grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) grid[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> grid[i][<span class="number">0</span>] = grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>) grid[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> grid[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) grid[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="掷骰子的N种方法-Medium"><a href="#掷骰子的N种方法-Medium" class="headerlink" title="掷骰子的N种方法 Medium"></a>掷骰子的N种方法 Medium</h4><p><strong>题目</strong></p>
<p>这里有 d 个一样的骰子，每个骰子上都有 f 个面，分别标号为 1, 2, …, f。</p>
<p>我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。</p>
<p>如果需要掷出的总点数为 target，请你计算出有多少种不同的组合情况（所有的组合情况总共有 f^d 种），模 10^9 + 7 后返回。</p>
<p><strong>分析</strong></p>
<p>直接给出状态转移方程<code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + ... dp[i-1][j-k], k = min(f, j)</code></p>
<p>很明显，可以空间压缩，只需要使用一维dp数组即可。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= f &amp;&amp; j &lt;= target; j++) dp[j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; d; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            dp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f &amp;&amp; k &lt;= j; k++) &#123;</span><br><span class="line">                dp[j] = (dp[j] + dp[j - k]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="“马”在棋盘上的概率-Medium"><a href="#“马”在棋盘上的概率-Medium" class="headerlink" title="“马”在棋盘上的概率 Medium"></a>“马”在棋盘上的概率 Medium</h4><p><strong>题目</strong></p>
<p>已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。</p>
<p>现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。</p>
<p>如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。</p>
<div align=left>
<img src="http://image.yingzq.com/img/20200401172548.png" width="230" />
</div>

<p>现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。</p>
<p>求移动结束后，“马” 仍留在棋盘上的概率。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3, 2, 0, 0</span><br><span class="line">输出: 0.0625</span><br><span class="line">解释:</span><br><span class="line">输入的数据依次为 N, K, r, c</span><br><span class="line">第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。</span><br><span class="line">对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。</span><br><span class="line">所以 “马” 在结束后仍在棋盘上的概率为 0.0625。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>假设<code>dp0[i][j]</code>表示 k - 1次移动后在 (i, j) 位置的路径数，<code>dp1[i][j]</code>则表示是 k 次移动后。</p>
<p>令<code>dirs = [[2,1], [2,-1], [-2,1], ...]</code>，有</p>
<p><code>dp1[i][j] = sum(dp0[i + dirs[k][0]][j + dirs[k][1]])</code></p>
<p>其中坐标必须都是有效的。另外，<code>dirs</code>数组有对称性，所以加号减号是等效的。</p>
<p>本题一共进行了 K 轮移动，使用<code>dp0</code>和<code>dp1</code>循环更新更加省空间。另外，为了防止值溢出的问题，这些数组都是<code>double类型</code>的。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">2</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">2</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">2</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">double</span>[][] dp0 = <span class="keyword">new</span> <span class="keyword">double</span>[N][N];</span><br><span class="line">        dp0[r][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> round = <span class="number">0</span>; round &lt; K; round++) &#123;</span><br><span class="line">            <span class="keyword">double</span>[][] dp1 = <span class="keyword">new</span> <span class="keyword">double</span>[N][N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                        <span class="keyword">int</span> oldRow = i + dir[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> oldCol = j + dir[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (!isValid(oldRow, oldCol, N)) <span class="keyword">continue</span>;</span><br><span class="line">                        dp1[i][j] += dp0[oldRow][oldCol];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp0 = dp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                cnt += dp0[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt / Math.pow(<span class="number">8</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; N &amp;&amp; j &lt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="目标和-Medium"><a href="#目标和-Medium" class="headerlink" title="目标和 Medium"></a>目标和 Medium</h4><p><strong>题目</strong></p>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ul>
<li>数组非空，且长度不会超过20。</li>
<li>初始的数组的和不会超过1000。</li>
<li>保证返回的最终结果能被32位整数存下</li>
</ul>
<p><strong>分析</strong></p>
<p>这是一道非常经典的题！</p>
<p>方法1：DFS</p>
<p>每个数有两种情况：+num 和 -num。所以对所有的情况进行遍历，在终止时判断<code>sum == target</code>，如果为true则<code>cnt++</code>，返回最终的cnt。</p>
<p>方法2：不假思索的DP</p>
<p>直接对这个问题建立状态转移方程：<code>dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]</code></p>
<p>可以进行空间压缩，使用两个一维数组来代替该二维dp数组。</p>
<p>方法3：略加变换的DP</p>
<p>写代码时会发现，方法2的写起来没那么舒服，可以转为如下方程：</p>
<p><code>dp[i][j + nums[i]] += dp[i - 1][j]</code>，<code>dp[i][j - nums[i]] += dp[i - 1][j]</code></p>
<p>方法4：转为0-1背包问题</p>
<p>令P表示添加了+号的集合，N表示添加了-号的集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum(P) - sum(N) &#x3D; target, sum(nums) &#x3D; sum(P) + sum(N) &#x3D;&#x3D;&gt;</span><br><span class="line">2 * sum(P) &#x3D; target + sum(nums)</span><br></pre></td></tr></table></figure>

<p>可以看出右边是个常数，因此这就是一个<strong>0-1背包问题</strong>！遇到这种题，可以先简单的进行数学推导，寻找原问题的等价问题，也许就能柳暗花明又一村。</p>
<p><strong>Java代码</strong></p>
<p>方法2代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span> (S &lt; -sum || S &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line">    dp[sum] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = -sum; j &lt;= sum; j++) &#123;</span><br><span class="line">            next[j + sum] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (j - num &gt;= -sum) next[j + sum] += dp[j - num + sum];</span><br><span class="line">            <span class="keyword">if</span> (j + num &lt;= sum) next[j + sum] += dp[j + num + sum];</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[S + sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法3代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span> (S &lt; -sum || S &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line">    dp[sum] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span> * sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                next[j + num] += dp[j];</span><br><span class="line">                next[j - num] += dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[S + sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法4代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span> (S &lt; -sum || S &gt; sum || (S + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = (S + sum) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= num; j--) &#123;</span><br><span class="line">            dp[j] += dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组合总和-Ⅳ-Medium"><a href="#组合总和-Ⅳ-Medium" class="headerlink" title="组合总和 Ⅳ Medium"></a>组合总和 Ⅳ Medium</h4><p><strong>题目</strong></p>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">target &#x3D; 4</span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line">因此输出为 7。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>完全背包问题。本题需要考虑顺序，即 (1,2) 和 (2,1) 属于两种情况，此时 nums 放外面，target 放里面进行循环。</p>
<p>延伸一下：如果是不考虑顺序，即 (1,2) 和(2,1) 属于一种情况，此时只需要把 target 放外面，nums 放里面进行循环即可。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= num) &#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="骑士拨号器-Medium"><a href="#骑士拨号器-Medium" class="headerlink" title="骑士拨号器 Medium"></a>骑士拨号器 Medium</h4><p><strong>题目</strong></p>
<p>国际象棋中的骑士可以按下图所示进行移动：</p>
<div align=left>
<img src="http://image.yingzq.com/img/20200402221334.png" width="380" />
</div>

<p>这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。</p>
<p>每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。</p>
<p>你能用这种方式拨出多少个不同的号码？</p>
<p>因为答案可能很大，所以输出答案模 10^9 + 7。</p>
<p><strong>分析</strong></p>
<p>同样是一个重复K次的问题，可以循环使用两个一维dp数组来代替二维的dp数组。</p>
<p>这里需要明白<code>dp[i]</code>的含义：拨码 k 次后 “骑士” 落在 i 位置的路径数。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knightDialer</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] moves = &#123;&#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>&#125;, &#123;&#125;,</span><br><span class="line">                     &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> round = <span class="number">1</span>; round &lt; N; round++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> pos : moves[i]) &#123;</span><br><span class="line">                next[i] += dp[pos];</span><br><span class="line">                next[i] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : dp) &#123;</span><br><span class="line">        res += count;</span><br><span class="line">        res %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分割等和子集-Medium"><a href="#分割等和子集-Medium" class="headerlink" title="分割等和子集 Medium"></a>分割等和子集 Medium</h4><p><strong>题目</strong></p>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:</p>
<ul>
<li>每个数组中的元素不会超过 100</li>
<li>数组的大小不会超过 200</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>经典的0-1背包问题。</p>
<p>建立一维 bool 类型 dp 数组，有状态转移方程：</p>
<p><code>dp[j] = dp[j] || dp[j - nums[i]]</code></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= num; j--) &#123;</span><br><span class="line">            dp[j] = dp[j] || dp[j - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多米诺和托米诺平铺-Medium"><a href="#多米诺和托米诺平铺-Medium" class="headerlink" title="多米诺和托米诺平铺 Medium"></a>多米诺和托米诺平铺 Medium</h4><p><strong>题目</strong></p>
<p>有两种形状的瓷砖：一种是 2x1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XX  &lt;- 多米诺</span><br><span class="line"></span><br><span class="line">XX  &lt;- &quot;L&quot; 托米诺</span><br><span class="line">X</span><br></pre></td></tr></table></figure>

<p>给定 N 的值，有多少种方法可以平铺 2 x N 的面板？返回值 mod 10^9 + 7。</p>
<p>（平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。）</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">下面列出了五种不同的方法，不同字母代表不同瓷砖：</span><br><span class="line">XYZ XXZ XYY XXY XYY</span><br><span class="line">XYZ YYZ XZZ XYY XXY</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>N 的范围是 [1, 1000]</li>
</ul>
<p><strong>分析</strong></p>
<p>直接贴一个图进行解释，图的来源是 LeetCode Discuss 区的 <a href="https://leetcode.com/problems/domino-and-tromino-tiling/discuss/116581/Detail-and-explanation-of-O(n)-solution-why-dpn2*dn-1%2Bdpn-3" target="_blank" rel="noopener">高票答案</a> 。</p>
<div align=left>
<img src="http://image.yingzq.com/img/20200403105820.png" width="700" />
</div>

<p>根据上图，得到状态转移方程：<code>dp[i] = 2 * dp[i-1] + dp[i-3]</code></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTilings</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">3</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">long</span> mod = (<span class="keyword">long</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i] = (<span class="number">2</span> * dp[i - <span class="number">1</span>] + dp[i - <span class="number">3</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于求<code>dp[i]</code>只需要<code>dp[i-1]</code>和<code>dp[i-3]</code>并且只使用一次，所以其实只需要$O(1)$的空间就可以了，具体代码就不贴了。</p>
</blockquote>
<h4 id="最长递增子序列的个数-Medium"><a href="#最长递增子序列的个数-Medium" class="headerlink" title="最长递增子序列的个数 Medium"></a>最长递增子序列的个数 Medium</h4><p><strong>题目</strong></p>
<p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</span><br></pre></td></tr></table></figure>

<p>注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。</p>
<p><strong>分析</strong></p>
<p>使用2个一维dp数组：<code>dp[i]</code>表示以 nums[i] 结尾的最大递增子序列的<code>长度</code>，<code>cnt[i]</code>表示以 nums[i] 结尾的最大递增子序列的<code>个数</code>。</p>
<p>其中<code>dp[i] = max(dp[j]) + 1, where 0 &lt;= j &lt; i &amp;&amp; nums[j] &lt; nums[i]</code>，是一个标准的 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">LIS问题</a> 。</p>
<p><code>cnt[i]</code>会随着<code>dp[i],dp[j]</code>情况的不同而变化，详情可以看代码。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    Arrays.fill(cnt, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] + <span class="number">1</span> == dp[i]) &#123;</span><br><span class="line">                    cnt[i] += cnt[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">                    cnt[i] = cnt[j];</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == maxLen) res += cnt[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = dp[i];</span><br><span class="line">            res = cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出界的路径数-Medium"><a href="#出界的路径数-Medium" class="headerlink" title="出界的路径数 Medium"></a>出界的路径数 Medium</h4><p><strong>题目</strong></p>
<p>给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动 N 次。找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 109 + 7 的值。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: m &#x3D; 2, n &#x3D; 2, N &#x3D; 2, i &#x3D; 0, j &#x3D; 0</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<div align=left>
<img src="http://image.yingzq.com/img/20200403145410.png" width="500" />
</div>

<p>说明:</p>
<ul>
<li>球一旦出界，就不能再被移动回网格内。</li>
<li>网格的长度和高度在 [1,50] 的范围内。</li>
<li>N 在 [0,50] 的范围内。</li>
</ul>
<p><strong>分析</strong></p>
<p>同样是一个重复进行 k 次试验的问题，可以循环使用两个二维的dp数组来降低空间复杂度。</p>
<p>每次移动后，如果出界则进行记录，否则<code>next[nr][nc] += dp[r][c]</code>。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> N, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> round = <span class="number">0</span>; round &lt; N; round++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] next = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[r][c] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nr = r + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> nc = c + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == m || nc == n) &#123;</span><br><span class="line">                        res = (res + dp[r][c]) % mod;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        next[nr][nc] = (next[nr][nc] + dp[r][c]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="停在原地的方案数-Hard"><a href="#停在原地的方案数-Hard" class="headerlink" title="停在原地的方案数 Hard"></a>停在原地的方案数 Hard</h4><p><strong>题目</strong></p>
<p>有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。</p>
<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>
<p>给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。</p>
<p>由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：steps &#x3D; 3, arrLen &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。</span><br><span class="line">向右，向左，不动</span><br><span class="line">不动，向右，向左</span><br><span class="line">向右，不动，向左</span><br><span class="line">不动，不动，不动</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;= steps &lt;= 500</li>
<li>1 &lt;= arrLen &lt;= 10^6</li>
</ul>
<p><strong>分析</strong></p>
<p>同样是一个重复 k 次试验的问题，可以循环使用两个一维dp数组来节省空间。</p>
<p>有<code>next[i] = dp[i-1] + dp[i] + dp[i+1]</code>。</p>
<p>需要注意的是本题的 arrLen可能会很大，steps 却不是很大。最后要求的是停在索引 0 处的方案，如果指针移动的太远，最后就回不来了，因此可以做一定的剪枝，即每次无需循环到 arrLen-1，只需要循环到<code>min(arrLen-1, remainSteps)</code>。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arrLen];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; steps; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[arrLen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Math.min(steps - k, arrLen - <span class="number">1</span>); i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> temp = dp[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) temp += dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; arrLen - <span class="number">1</span>) temp += dp[i + <span class="number">1</span>];</span><br><span class="line">            temp %= mod;</span><br><span class="line">            next[i] = (<span class="keyword">int</span>) temp;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="统计元音字母序列的数目-Hard"><a href="#统计元音字母序列的数目-Hard" class="headerlink" title="统计元音字母序列的数目 Hard"></a>统计元音字母序列的数目 Hard</h4><p><strong>题目</strong></p>
<p>给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：</p>
<p>字符串中的每个字符都应当是小写元音字母（’a’, ‘e’, ‘i’, ‘o’, ‘u’）<br>每个元音 ‘a’ 后面都只能跟着 ‘e’<br>每个元音 ‘e’ 后面只能跟着 ‘a’ 或者是 ‘i’<br>每个元音 ‘i’ 后面 不能 再跟着另一个 ‘i’<br>每个元音 ‘o’ 后面只能跟着 ‘i’ 或者是 ‘u’<br>每个元音 ‘u’ 后面只能跟着 ‘a’<br>由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：10</span><br><span class="line">解释：所有可能的字符串分别是：&quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; 和 &quot;ua&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>虽然是 Hard 题，但是还是很容易想到解法的：建立两个一维数组，不断的根据规则循环更新。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">5</span>];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> mod = <span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span>[] next = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">5</span>];</span><br><span class="line">        next[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">        next[<span class="number">1</span>] = (dp[<span class="number">0</span>] + dp[<span class="number">2</span>]) % mod;</span><br><span class="line">        next[<span class="number">2</span>] = (dp[<span class="number">0</span>] + dp[<span class="number">1</span>] + dp[<span class="number">3</span>] + dp[<span class="number">4</span>]) % mod;</span><br><span class="line">        next[<span class="number">3</span>] = (dp[<span class="number">2</span>] + dp[<span class="number">4</span>]) % mod;</span><br><span class="line">        next[<span class="number">4</span>] = dp[<span class="number">0</span>];</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> num : dp) res += num;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (res % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Merging-Intervals"><a href="#Merging-Intervals" class="headerlink" title="Merging Intervals"></a>Merging Intervals</h2><h3 id="Statement-2"><a href="#Statement-2" class="headerlink" title="Statement"></a>Statement</h3><p>Given a set of numbers find an optimal solution for a problem considering the current number and the best you can get from the left and right sides.</p>
<h3 id="Approach-2"><a href="#Approach-2" class="headerlink" title="Approach"></a>Approach</h3><p>Find all optimal solutions for every interval and return the best possible answer.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from i to j</span></span><br><span class="line">dp[i][j] = dp[i][k] + result[k] + dp[k+<span class="number">1</span>][j]</span><br></pre></td></tr></table></figure>

<p>Get the best from the left and right sides and add a solution for the current position.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; n; l++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - l; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + result[k] + dp[k+<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Similar-Problems-2"><a href="#Similar-Problems-2" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p>列举如下：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/" target="_blank" rel="noopener">1039. 多边形三角剖分的最低得分</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/" target="_blank" rel="noopener">375. 猜数字大小 II</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/" target="_blank" rel="noopener">1000. 合并石头的最低成本</a> <strong>Hard</strong></li>
<li><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a> <strong>Hard</strong></li>
</ul>
<h4 id="不同的二叉搜索树-Medium"><a href="#不同的二叉搜索树-Medium" class="headerlink" title="不同的二叉搜索树 Medium"></a>不同的二叉搜索树 Medium</h4><p><strong>题目</strong></p>
<p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>先定义两个函数：</p>
<p><code>G(n)</code>：长度为 n 的所有不同BST的总数。<br><code>F(i, n), 1 &lt;= i &lt;= n</code>：以 i 为根节点，长度为 n 的所有不同BST的总数。</p>
<p>可以得到<code>G(n) = sum(F(i, n)), 1 &lt;= i &lt;= n</code>，其中<code>F(i, n) = G(i-1) * G(n-i)</code>。</p>
<p>用一维dp数组来表示<code>G(n)</code>，便得到如下状态转移方程：</p>
<p><code>dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[0]</code></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多边形三角剖分的最低得分-Medium"><a href="#多边形三角剖分的最低得分-Medium" class="headerlink" title="多边形三角剖分的最低得分 Medium"></a>多边形三角剖分的最低得分 Medium</h4><p><strong>题目</strong></p>
<p>给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], …, A[N-1]。</p>
<p>假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。</p>
<p>返回多边形进行三角剖分后可以得到的最低分。</p>
<p><strong>示例</strong></p>
<div align=left>
<img src="http://image.yingzq.com/img/20200403205818.png" width="300" />
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,7,4,5]</span><br><span class="line">输出：144</span><br><span class="line">解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 &#x3D; 245，或 3*4*5 + 3*4*7 &#x3D; 144。最低分数为 144。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>3 &lt;= A.length &lt;= 50</li>
<li>1 &lt;= A[i] &lt;= 100</li>
</ul>
<p><strong>分析</strong></p>
<p>令<code>dp[i][j]</code>表示<code>A[i] ~ A[j]</code>所形成的三角形的最小面积，其中<code>A[i]</code>和<code>A[j]</code>之间一定是相连的。</p>
<p>得到状态转移方程：<code>dp[i][j] = min(dp[i][k] + dp[k][j] + A[i]*A[k]*A[j])</code></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">2</span>; d &lt; n; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - d; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + d;</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + A[i] * A[j] * A[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="猜数字大小-II-Medium"><a href="#猜数字大小-II-Medium" class="headerlink" title="猜数字大小 II Medium"></a>猜数字大小 II Medium</h4><p><strong>题目</strong></p>
<p>我们正在玩一个猜数游戏，游戏规则如下：</p>
<p>我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。</p>
<p>每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。</p>
<p>然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; 10, 我选择了8.</span><br><span class="line"></span><br><span class="line">第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。</span><br><span class="line">第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。</span><br><span class="line">第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。</span><br><span class="line"></span><br><span class="line">游戏结束。8 就是我选的数字。</span><br><span class="line"></span><br><span class="line">你最终要支付 5 + 7 + 9 &#x3D; 21 块钱。</span><br></pre></td></tr></table></figure>

<p>给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。</p>
<p><strong>分析</strong></p>
<p>首先，二分查找法并不是最优的选择，例如对于<code>[1,2,3,4,5], n = 5</code>，利用二分查找需要 <code>3 + 4 = 7</code>，但是其实第一次可以猜 4，这样最少只需要<code>4 + 2 = 6</code>。</p>
<p>令<code>dp[i][j]</code>代表在区间 (i, j) 中猜数字至少需要的现金。</p>
<p>状态转移方程：<code>dp[i][j] = min(k + max(dp[i][k-1], dp[k+1][j]))</code></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; n; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - d; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + d;</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], k + Math.max(dp[i][k - <span class="number">1</span>], dp[k + <span class="number">1</span>][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并石头的最低成本-Hard"><a href="#合并石头的最低成本-Hard" class="headerlink" title="合并石头的最低成本 Hard"></a>合并石头的最低成本 Hard</h4><p><strong>题目</strong></p>
<p>有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。</p>
<p>每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。</p>
<p>找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：stones &#x3D; [3,2,4,1], K &#x3D; 2</span><br><span class="line">输出：20</span><br><span class="line">解释：</span><br><span class="line">从 [3, 2, 4, 1] 开始。</span><br><span class="line">合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。</span><br><span class="line">合并 [4, 1]，成本为 5，剩下 [5, 5]。</span><br><span class="line">合并 [5, 5]，成本为 10，剩下 [10]。</span><br><span class="line">总成本 20，这是可能的最小值。</span><br><span class="line"></span><br><span class="line">输入：stones &#x3D; [3,2,4,1], K &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line">解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>首先该题贪婪算法是存在问题的，例如对于<code>[6,4,4,6]</code>，用贪婪算法的结果是42，其实最优是可以达到40的。</p>
<p>定义<code>dp[i][j]</code>代表将 <code>i ~ j</code> 位置的石头合并为最少堆的最低成本。</p>
<p>得出状态转移方程：<code>dp[i][j] = min(sum[i][j] + dp[i][k] + dp[k + 1][j]) (i &lt;= k &lt; j)</code></p>
<p><strong>总结下DP问题的4要素：</strong></p>
<ol>
<li>State：dp数组意味着什么</li>
<li>Function：状态转移方程</li>
<li>Init：初始值的设定</li>
<li>Answer：返回的答案是什么</li>
</ol>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mergeStones</span><span class="params">(<span class="keyword">int</span>[] stones, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = stones.length;</span><br><span class="line">    <span class="keyword">if</span> ((n - <span class="number">1</span>) % (K - <span class="number">1</span>) &gt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] prefix = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + stones[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = K; m &lt;= n; m++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + m - <span class="number">1</span>;</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid = i; mid &lt; j; mid += K - <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], dp[i][mid] + dp[mid + <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span> ((j - i) % (K - <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] += prefix[j + <span class="number">1</span>] - prefix[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TODO: 该题还是没能完全看懂，先留个坑。</p>
</blockquote>
<h4 id="戳气球-Hard"><a href="#戳气球-Hard" class="headerlink" title="戳气球 Hard"></a>戳气球 Hard</h4><p><strong>题目</strong></p>
<p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<p>说明:</p>
<ul>
<li>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。</li>
<li>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167</span><br><span class="line">解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins &#x3D;  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   &#x3D; 167</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>同样的，令<code>dp[i][j]</code>代表从<code>i ~ j</code>之间的气球戳破后能得到的最大硬币数量，这里不包括边界更好处理，即不包括 i 和 j 位置。</p>
<p>状态转移方程：<code>dp[i][j] = max(dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])</code></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] iNums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[iNums.length + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : iNums) <span class="keyword">if</span> (x &gt; <span class="number">0</span>) nums[n++] = x;</span><br><span class="line">    nums[<span class="number">0</span>] = nums[n++] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">2</span>; d &lt; n; d++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - d; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DP-on-Strings"><a href="#DP-on-Strings" class="headerlink" title="DP on Strings"></a>DP on Strings</h2><p>General problem statement for this pattern can vary but most of the time you are given two strings where lengths of those strings are not big.</p>
<h3 id="Statement-3"><a href="#Statement-3" class="headerlink" title="Statement"></a>Statement</h3><p>Given two strings <code>s1</code> and <code>s2</code>, return <code>some result</code>.</p>
<h3 id="Approach-3"><a href="#Approach-3" class="headerlink" title="Approach"></a>Approach</h3><p>Most of the problems on this pattern requires a solution that can be accepted in O(n^2) complexity.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i - indexing string s1</span></span><br><span class="line"><span class="comment">// j - indexing string s2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">       <span class="keyword">if</span> (s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">           dp[i][j] = <span class="comment">/*code*/</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           dp[i][j] = <span class="comment">/*code*/</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you are given one string s the approach may little vary.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; n; l++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - l; i++) &#123;</span><br><span class="line">       <span class="keyword">int</span> j = i + l;</span><br><span class="line">       <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">           dp[i][j] = <span class="comment">/*code*/</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           dp[i][j] = <span class="comment">/*code*/</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Similar-Problems-3"><a href="#Similar-Problems-3" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p>列举如下：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/" target="_blank" rel="noopener">712. 两个字符串的最小ASCII删除和</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/shortest-common-supersequence/" target="_blank" rel="noopener">1092. 最短公共超序列</a> <strong>Hard</strong></li>
<li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a> <strong>Hard</strong></li>
<li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">115. 不同的子序列</a> <strong>Hard</strong></li>
</ul>
<h4 id="最长公共子序列-Medium"><a href="#最长公共子序列-Medium" class="headerlink" title="最长公共子序列 Medium"></a>最长公共子序列 Medium</h4><p><strong>题目</strong></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列（longest common subsequence, LCS）。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot;</span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p>提示:</p>
<ul>
<li>1 &lt;= text1.length &lt;= 1000</li>
<li>1 &lt;= text2.length &lt;= 1000</li>
<li>输入的字符串只含有小写英文字符</li>
</ul>
<p><strong>分析</strong></p>
<p><code>dp[i][j]</code>表示 text1 长度为 i，text2 长度为 j 时的最长公共子串。</p>
<p>状态转移方程：</p>
<ul>
<li>如果<code>text1[i] == text2[j]</code>，则<code>dp[i][j] = dp[i-1][j-1] + 1</code></li>
<li>如果<code>text1[i] != text2[j]</code>，则<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></li>
</ul>
<p>注意到<code>dp[i][j]</code>只用到<code>dp[i-1][j-1], dp[i][j-1], dp[i-1][j]</code>，因此可以仅使用两个一维dp数组代替原先的二维dp数组。但是如果题目中的字符串比较短，这一步也可以不做；如果在面试时问你空间是否可以继续优化，或者在笔试时提示使用内存过大，那么你可能就需要认真考虑这方面了，在 DP on Strings 问题上很多都可以类似考虑，后面不再提了。</p>
<p><strong>Java代码</strong></p>
<p>使用二维dp数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化为一维dp数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                next[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[j] = Math.max(dp[j], next[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两个字符串的最小ASCII删除和-Medium"><a href="#两个字符串的最小ASCII删除和-Medium" class="headerlink" title="两个字符串的最小ASCII删除和 Medium"></a>两个字符串的最小ASCII删除和 Medium</h4><p><strong>题目</strong></p>
<p>给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;sea&quot;, s2 &#x3D; &quot;eat&quot;</span><br><span class="line">输出: 231</span><br><span class="line">解释: 在 &quot;sea&quot; 中删除 &quot;s&quot; 并将 &quot;s&quot; 的值(115)加入总和。</span><br><span class="line">在 &quot;eat&quot; 中删除 &quot;t&quot; 并将 116 加入总和。</span><br><span class="line">结束时，两个字符串相等，115 + 116 &#x3D; 231 就是符合条件的最小和。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>令<code>dp[i][j]</code>表示使 s1 的前 i 字符串和 s2 的前 j 字符串相等时所需删除字符的ASCII值的最小和。</p>
<p>当<code>s1[i] == s2[j]</code>时，有<code>dp[i][j] = dp[i-1][j-1]</code>；<br>当<code>s1[i] != s2[j]</code>时，有<code>dp[i][j] = min(dp[i-1][j] + s1[i], dp[i][j-1], s2[j])</code>。</p>
<p>另外，需要注意二维dp数组数组中的初始化问题：不仅要注意<code>dp[0][0]</code>，还要注意所有的<code>dp[i][0]</code>和<code>dp[0][j]</code>。</p>
<p>本题中，<code>dp[i][0] = s1[1] + s1[2] + ... + s1[i], dp[0][j] = s2[1] + s2[2] + ... + s2[j]</code>。</p>
<p><strong>Java代码</strong></p>
<p>写法1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + s1.charAt(i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + s2.charAt(j - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + s1.charAt(i - <span class="number">1</span>), dp[i][j - <span class="number">1</span>] + s2.charAt(j - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i + <span class="number">1</span>][<span class="number">0</span>] = dp[i][<span class="number">0</span>] + s1.charAt(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j + <span class="number">1</span>] = dp[<span class="number">0</span>][j] + s2.charAt(j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.min(dp[i][j + <span class="number">1</span>] + s1.charAt(i), dp[i + <span class="number">1</span>][j] + s2.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>当循环的范围是<code>i = 1 ~ len</code>时，需要用到的是<code>str[i-1]</code>，需要更新的是<code>dp[i]</code>；当循环的范围是<code>i = 0 ~ len-1</code>时，需要用到的是<code>str[i]</code>，需要更新的是<code>dp[i+1]</code>。因此一般有上述两种写法。</p>
</blockquote>
<h4 id="回文子串-Medium"><a href="#回文子串-Medium" class="headerlink" title="回文子串 Medium"></a>回文子串 Medium</h4><p><strong>题目</strong></p>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aaa&quot;</span><br><span class="line">输出: 6</span><br><span class="line">说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p><strong>DP解法</strong></p>
<p>令<code>dp[i][j]</code>代表 <code>i ~ j</code> 位置的子串是否能构成回文。</p>
<p>状态转移方程：<code>dp[i][j] = s[i] == s[j] &amp;&amp; (j - i &lt; 3 || dp[i+1][j-1])</code></p>
<p>其中<code>j - i &lt; 3</code>是表示子串长度小于等于3，因此内部不需要再判断。另外，注意到<code>dp[i][j]</code>需要用到<code>dp[i+1][j-1]</code>，所以<code>i需要逆序遍历</code>。</p>
<p><strong>中心扩展法</strong></p>
<p>处理回文子串问题还有一种经典的中心扩展法。观察到回文中心的两侧互为镜像，因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心（包括单中心和双中心），O(n^2)复杂度。</p>
<p><strong>Java代码</strong></p>
<p>DP解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中心扩展法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            res += extend(s, i, i);</span><br><span class="line">            res += extend(s, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">extend</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) <span class="keyword">break</span>;</span><br><span class="line">            count++;</span><br><span class="line">            i--;j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最长回文子串-Medium"><a href="#最长回文子串-Medium" class="headerlink" title="最长回文子串 Medium"></a>最长回文子串 Medium</h4><p><strong>题目</strong></p>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>同上题，可以使用 DP 和 中心扩展法。</p>
<p><strong>Java代码</strong></p>
<p>DP解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (j - i &gt; end - start) &#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    end = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中心扩展法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            String s1 = extend(s, i, i);</span><br><span class="line">            String s2 = extend(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s1.length() &gt; res.length()) res = s1;</span><br><span class="line">            <span class="keyword">if</span> (s2.length() &gt; res.length()) res = s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">extend</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) <span class="keyword">break</span>;</span><br><span class="line">            i--;j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最长回文子序列-Medium"><a href="#最长回文子序列-Medium" class="headerlink" title="最长回文子序列 Medium"></a>最长回文子序列 Medium</h4><p><strong>题目</strong></p>
<p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;bbbab&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 一个可能的最长回文子序列为 &quot;bbbb&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>是回文子串问题的升级版。</p>
<p>根据DP问题4要素来分析此题：</p>
<ul>
<li>状态</li>
</ul>
<p><code>dp[i][j]</code>表示 s 的第 i 个字符到第 j 个字符组成的子串中，最长的回文序列长度是多少。</p>
<ul>
<li>转移方程</li>
</ul>
<p>如果<code>s[i] == s[j]</code>，则<code>dp[i][j] = dp[i+1][j-1] + 2</code>；<br>如果<code>s[i] != s[j]</code>，则<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>。</p>
<p>然后注意遍历顺序，i 从最后一个字符开始往前遍历，j 从 i + 1 开始往后遍历，这样可以保证每个子问题都已经算好了。</p>
<ul>
<li>初始化</li>
</ul>
<p><code>dp[i][i] = 1</code></p>
<ul>
<li>结果</li>
</ul>
<p>返回<code>dp[0][n-1]</code></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最短公共超序列-Hard"><a href="#最短公共超序列-Hard" class="headerlink" title="最短公共超序列 Hard"></a>最短公共超序列 Hard</h4><p><strong>题目</strong></p>
<p>给出两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。</p>
<p>（如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 任意位置），可以得到字符串 S，那么 S 就是 T 的子序列）</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：str1 &#x3D; &quot;abac&quot;, str2 &#x3D; &quot;cab&quot;</span><br><span class="line">输出：&quot;cabac&quot;</span><br><span class="line">解释：</span><br><span class="line">str1 &#x3D; &quot;abac&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 的第一个 &quot;c&quot;得到 &quot;abac&quot;。</span><br><span class="line">str2 &#x3D; &quot;cab&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 末尾的 &quot;ac&quot; 得到 &quot;cab&quot;。</span><br><span class="line">最终我们给出的答案是满足上述属性的最短字符串。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;= str1.length, str2.length &lt;= 1000</li>
<li>str1 和 str2 都由小写英文字母组成。</li>
</ul>
<p><strong>分析</strong></p>
<p>可以先找到最大公共子串（LCS），然后利用LCS的结果、str1、str2 共同生成最短公共超序列。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestCommonSupersequence</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        String lcs = longestCommonSubSeq(str1, str2);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : lcs.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (str1.charAt(i) != c) sb.append(str1.charAt(i++));</span><br><span class="line">            <span class="keyword">while</span> (str2.charAt(j) != c) sb.append(str2.charAt(j++));</span><br><span class="line">            sb.append(c);</span><br><span class="line">            i++;j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str1.length()) sb.append(str1.charAt(i++));</span><br><span class="line">        <span class="keyword">while</span> (j &lt; str2.length()) sb.append(str2.charAt(j++));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">longestCommonSubSeq</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = str1.length(), n = str2.length();</span><br><span class="line">        String[][] dp = <span class="keyword">new</span> String[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str1.charAt(i - <span class="number">1</span>) == str2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + str1.charAt(i - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j].length() &gt; dp[i][j - <span class="number">1</span>].length() ?</span><br><span class="line">                            dp[i - <span class="number">1</span>][j] : dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编辑距离-Hard"><a href="#编辑距离-Hard" class="headerlink" title="编辑距离 Hard"></a>编辑距离 Hard</h4><p><strong>题目</strong></p>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p><code>dp[i][j]</code>代表 word1 的前 i 个字符和 word2 的前 j 个字符之间的编辑距离。</p>
<p>当<code>word1[i] == word2[j]</code>时，<code>dp[i][j] = dp[i-1][j-1]</code>；<br>当<code>word1[i] != word2[j]</code>时，<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code>。</p>
<p>最后，本题要注意初始化问题：<code>dp[0][i] = i, dp[j][0] = j</code>。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = word1.charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c2 = word2.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.min(dp[i][j], Math.min(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不同的子序列-Hard"><a href="#不同的子序列-Hard" class="headerlink" title="不同的子序列 Hard"></a>不同的子序列 Hard</h4><p><strong>题目</strong></p>
<p>给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。</p>
<p>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: S &#x3D; &quot;rabbbit&quot;, T &#x3D; &quot;rabbit&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">如下图所示, 有 3 种可以从 S 中得到 &quot;rabbit&quot; 的方案。</span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line"></span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>令<code>dp[i][j]</code>代表 S 的前 i 字符串的子序列中 T 的 前 j 字符串出现的个数。</p>
<p>当<code>S[i] == T[j]</code>时，<code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</code>；<br>当<code>S[i] != T[j]</code>时，<code>dp[i][j] = dp[i-1][j]</code>。</p>
<p>同样要注意初始化问题：<code>dp[i][0] = 1</code>，这是因为第一列是 T 为空的情况，空集是所有字符串子集, 所以我们第一列都是 1 。</p>
<p>因为<code>dp[i][j]</code>只用到了<code>dp[i-1][j-1], dp[i-1][j]</code>，类似于0-1背包问题，其实仅使用一个一维dp数组就足够了。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = t.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化为一维dp数组代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = t.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Decision-Making"><a href="#Decision-Making" class="headerlink" title="Decision Making"></a>Decision Making</h2><p>The general problem statement for this pattern is forgiven situation decide whether to use or not to use the current state. So, the problem requires you to make a decision at a current state.</p>
<h3 id="Statement-4"><a href="#Statement-4" class="headerlink" title="Statement"></a>Statement</h3><p>Given a set of values find an answer with an option to choose or ignore the current value.</p>
<h3 id="Approach-4"><a href="#Approach-4" class="headerlink" title="Approach"></a>Approach</h3><p>If you decide to choose the current value use the previous result where the value was ignored; vice-versa, if you decide to ignore the current value use previous result where value was used.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i - indexing a set of values</span></span><br><span class="line"><span class="comment">// j - options to ignore j values</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">       dp[i][j] = <span class="built_in">max</span>(&#123;dp[i][j], dp[i<span class="number">-1</span>][j] + arr[i], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;);</span><br><span class="line">       dp[i][j<span class="number">-1</span>] = <span class="built_in">max</span>(&#123;dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + arr[i], arr[i]&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Similar-Problems-4"><a href="#Similar-Problems-4" class="headerlink" title="Similar Problems"></a>Similar Problems</h3><p>列举如下：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a> <strong>Easy</strong></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a> <strong>Easy</strong></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a> <strong>Medium</strong></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a> <strong>Hard</strong></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a> <strong>Hard</strong></li>
</ul>
<h4 id="打家劫舍-Easy"><a href="#打家劫舍-Easy" class="headerlink" title="打家劫舍 Easy"></a>打家劫舍 Easy</h4><p><strong>题目</strong></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>建立二维数组<code>dp[n+1][2]</code>，n 代表输入数组的长度，2 代表小偷的决策数量：偷/不偷。</p>
<p>令<code>dp[i][0]</code>表示在 i 个房间不偷，<code>dp[i][1]</code>表示在 i 个房间偷。</p>
<p>有状态转移方程：</p>
<ul>
<li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1])</code></li>
<li><code>dp[i][1] = dp[i-1][0] + nums[i]</code></li>
</ul>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实空间复杂度可以进一步优化到$O(1)$。</p>
</blockquote>
<h4 id="买卖股票的最佳时机-II-Easy"><a href="#买卖股票的最佳时机-II-Easy" class="headerlink" title="买卖股票的最佳时机 II Easy"></a>买卖股票的最佳时机 II Easy</h4><p><strong>题目</strong></p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>有很多方法可以解这道题，为了处理后续更进一步的股票的问题，这里使用DP来做。</p>
<p><strong>第 1 步：状态定义</strong></p>
<p>令<code>dp[i][j]</code> 表示从开始到第 i 天状态为 j 时的最大收益。</p>
<p>这里 j 取两个值：</p>
<ul>
<li>0 表示不持股；</li>
<li>1 表示持股。</li>
</ul>
<p><strong>第 2 步：状态转移方程</strong></p>
<p><code>dp[i][0]</code>代表当天不持股，可以由昨天不持股和昨天持股转换而来，<code>dp[i][1]</code>代表当天持股，也可以由昨天不持股和昨天持股转换而来：</p>
<ul>
<li><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])</code>：</li>
<li><code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</code></li>
</ul>
<p><strong>第 3 步：思考初始化</strong></p>
<p>在第 0 天，不持股的初始化值为 0，持股的初始化值为 -prices[0]。</p>
<p><strong>第 4 步：思考输出</strong></p>
<p>每一天都由前面几天的状态转换而来，最优值在最后一天，并且是不持股的状态。</p>
<p><strong>第 5 步：思考状态压缩</strong></p>
<p>因为当前行总是参考上一行的值，可以使用滚动数组优化。本题dp数组第二维又只有 2 大小，因此空间复杂度可以优化为$O(1)$。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机含手续费-Medium"><a href="#买卖股票的最佳时机含手续费-Medium" class="headerlink" title="买卖股票的最佳时机含手续费 Medium"></a>买卖股票的最佳时机含手续费 Medium</h4><p><strong>题目</strong></p>
<p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>和上题一样的思路。</p>
<p>状态转移方程：</p>
<ul>
<li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code></li>
<li><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)</code></li>
</ul>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>] - fee;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最佳买卖股票时机含冷冻期-Medium"><a href="#最佳买卖股票时机含冷冻期-Medium" class="headerlink" title="最佳买卖股票时机含冷冻期 Medium"></a>最佳买卖股票时机含冷冻期 Medium</h4><p><strong>题目</strong></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>同样定义<code>dp[i][j]</code>，i 仍然表示进行到第几天了，但是此时 j 有 3 种取值：</p>
<ul>
<li>取 0 代表当天不持股且当天没卖出的最大收益</li>
<li>取 1 代表当天持股的最大收益</li>
<li>取 2 代表当天不持股且当天卖出的最大收益</li>
</ul>
<p>这样状态转移方程就很明显了，直接看代码即可。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="买卖股票的最佳时机-III-IV-Hard"><a href="#买卖股票的最佳时机-III-IV-Hard" class="headerlink" title="买卖股票的最佳时机 III/IV Hard"></a>买卖股票的最佳时机 III/IV Hard</h4><p>这是两道 Hard 题，其实对于整个股票问题来说，是有着相应的 <strong>通用解法</strong> 的。想要深入了解股票买卖问题可以参考下面给出的链接，在这里就不详细介绍了。</p>
<ul>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">Most consistent ways of dealing with the series of stock problems</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/" target="_blank" rel="noopener">一个通用方法团灭 6 道股票问题</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-04-04T09:33:16.059Z" itemprop="dateUpdated">2020-04-04 17:33:16</time>
</span><br>


        
        若有疑问或者本人有写的不对的地方, 欢迎留言或者直接邮箱反馈至yingzq0116@163.com, 非常感谢您的阅读~
        
    </div>
    
    <footer>
        <a href="https://www.yingzq.com">
            <img src="/img/avatar.jpg" alt="应子强">
            应子强
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/" rel="tag">算法设计技巧</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.yingzq.com/2020/03/28/dynamic-programming-patterns/&title=《论动态规划常见的5种模式》 — yingzq's Blog&pic=https://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.yingzq.com/2020/03/28/dynamic-programming-patterns/&title=《论动态规划常见的5种模式》 — yingzq's Blog&source=交流NLP, 深度学习技术, 分享coding路上的风景" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.yingzq.com/2020/03/28/dynamic-programming-patterns/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《论动态规划常见的5种模式》 — yingzq's Blog&url=https://www.yingzq.com/2020/03/28/dynamic-programming-patterns/&via=https://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.yingzq.com/2020/03/28/dynamic-programming-patterns/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/03/25/conda-env-config-in-mac/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">在Mac中安装并配置conda环境（简约版）</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "mGqkrgTscxf4JdcqkEHkFCfs-gzGzoHsz",
            appKey: "PwU9oOfhNnWOKaMaOTqQpiNW",
            avatar: "mm",
            placeholder: "要不要说点什么？",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>应子强 &copy; 2019 - 2020</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">京ICP备19041830号</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.yingzq.com/2020/03/28/dynamic-programming-patterns/&title=《论动态规划常见的5种模式》 — yingzq's Blog&pic=https://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.yingzq.com/2020/03/28/dynamic-programming-patterns/&title=《论动态规划常见的5种模式》 — yingzq's Blog&source=交流NLP, 深度学习技术, 分享coding路上的风景" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.yingzq.com/2020/03/28/dynamic-programming-patterns/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《论动态规划常见的5种模式》 — yingzq's Blog&url=https://www.yingzq.com/2020/03/28/dynamic-programming-patterns/&via=https://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.yingzq.com/2020/03/28/dynamic-programming-patterns/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACr0lEQVR42u3aMW7DQAwEQP//004bILG0JI+GirkqMGLpRoWOXvL1itf718o/+XSd68/ff9b1dw8sPDw8vMHWry+drGt8jskf7s0V8PDw8NZ4ycv6+qGUbxw8iHw/Hz/Hw8PDewyvivn+I8DDw8N7Du8akFN798XDw8N7Di8JF/K4Ng8RquX7YtaCh4eHV6taoy7Sc/5e6e/h4eHhjbvqeVl8qm1WbZXdXBMPDw9vgZe/cPP4IB8IOBUl3+wTDw8Pb4GXxwSnqPnQVTLIdf0tPDw8vO/w8kiityZtsOqe8fDw8M7yTsUBk7GD/JCoNtXw8PDwtnn5kVDtMeUFcV6mNxtgeHh4eId41SK7V+zmgWwShURNODw8PLw1Xv5an7S7qjFu9ZCIkmk8PDy8Q7xes+rsqEHvEdzsGQ8PD+/rvFOhwPzIqcbE0cGAh4eH1+JNLjSPEvKIodr6isprPDw8vDEvD2HnzbNCFDso3PHw8PA2eL0hp+oh0Ruiqh42zaErPDw8vBYvb/bnt5m3zXrgjzEuHh4e3iFeNRjNy9+zowZ5kyzKWvDw8PCO8nJkNdpovtBbdynnK3h4eHhFXt7azxtXedG8PiyLh4eHt8bLQ9sqaf66Hx1aeHh4eGu83khT9QjJD4NJDyvq8uHh4eGNedWf+kkRXG2hVYOG6Ap4eHh4a7xJ06saJSRNr14Y8c//4OHh4a3x8htUC+jq2MF84eHh4e3x3sWVBLvVtlmvTI/2g4eHh7fAmzSikttcHxV5iHx2CAwPDw9vzjs19tSs6AeJa7QHPDw8vDXe9edVXi/k7T2ym/3g4eHhPYCXvKar4wJJkyx/xHh4eHhP4+WjAL1jo9dC+7gTPDw8vDXeZKwq31D1SDhwFzw8PLwF3uQH/zz8rQ5vHevp4eHh4XV4PzIz5CmQ/IwLAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来练习bug!';
            clearTimeout(titleTime);
        } else {
            document.title = 'yingzq's Blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
