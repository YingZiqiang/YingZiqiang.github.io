<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>《剑指offer第二版》阅读笔记（一） | yingzq&#39;s Blog | 练习bug时长两年半的实习生</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="数据结构与算法,Java,阅读笔记">
    <meta name="description" content="面试季来临，于是最近两天阅读了《剑指offer第二版》这本程序员面试必备书籍，全书题目不多，但是涵盖了许多重要的知识点，通过自己的阅读也收获良多，所以写下这个阅读笔记。该笔记对书中的面试题进行了自己的分析，相比于原书有的放矢，因此精简了很多，这样做一是加深自己对每个题的印象，二是可以方便今后复习时无需再次看原书，简单的过一下笔记就好。">
<meta property="og:type" content="article">
<meta property="og:title" content="《剑指offer第二版》阅读笔记（一）">
<meta property="og:url" content="http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/index.html">
<meta property="og:site_name" content="yingzq&#39;s Blog">
<meta property="og:description" content="面试季来临，于是最近两天阅读了《剑指offer第二版》这本程序员面试必备书籍，全书题目不多，但是涵盖了许多重要的知识点，通过自己的阅读也收获良多，所以写下这个阅读笔记。该笔记对书中的面试题进行了自己的分析，相比于原书有的放矢，因此精简了很多，这样做一是加深自己对每个题的印象，二是可以方便今后复习时无需再次看原书，简单的过一下笔记就好。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://image.yingzq.com/img/20200219194729.png">
<meta property="og:image" content="http://image.yingzq.com/img/20200219235223.png">
<meta property="article:published_time" content="2020-02-19T07:10:52.000Z">
<meta property="article:modified_time" content="2020-03-03T09:51:34.339Z">
<meta property="article:author" content="应子强">
<meta property="article:tag" content="数据结构与算法">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="阅读笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://image.yingzq.com/img/20200219194729.png">
    
        <link rel="alternate" type="application/atom+xml" title="yingzq&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/avatar.jpg">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">应子强</h5>
          <a href="mailto:yingzq0116@163.com" title="yingzq0116@163.com" class="mail">yingzq0116@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签云
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-info-circle"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/YingZiqiang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">《剑指offer第二版》阅读笔记（一）</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">《剑指offer第二版》阅读笔记（一）</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-02-19T07:10:52.000Z" itemprop="datePublished" class="page-time">
  2020-02-19
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#系列文章"><span class="post-toc-number">1.</span> <span class="post-toc-text">系列文章</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题3-1：找出数组中重复的数字"><span class="post-toc-number">2.</span> <span class="post-toc-text">面试题3-1：找出数组中重复的数字</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题3-2：不修改数组找出重复元素"><span class="post-toc-number">3.</span> <span class="post-toc-text">面试题3-2：不修改数组找出重复元素</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-1"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-1"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题4：二维数组中的查找"><span class="post-toc-number">4.</span> <span class="post-toc-text">面试题4：二维数组中的查找</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-2"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-2"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题5：替换空格"><span class="post-toc-number">5.</span> <span class="post-toc-text">面试题5：替换空格</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-3"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-3"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题6：从尾到头打印链表"><span class="post-toc-number">6.</span> <span class="post-toc-text">面试题6：从尾到头打印链表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-4"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-4"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题7：重建二叉树"><span class="post-toc-number">7.</span> <span class="post-toc-text">面试题7：重建二叉树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-5"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-5"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题8：二叉树的下一个节点"><span class="post-toc-number">8.</span> <span class="post-toc-text">面试题8：二叉树的下一个节点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-6"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-6"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题9：用两个栈实现队列"><span class="post-toc-number">9.</span> <span class="post-toc-text">面试题9：用两个栈实现队列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-7"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-7"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题10-1：斐波那契数列"><span class="post-toc-number">10.</span> <span class="post-toc-text">面试题10-1：斐波那契数列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-8"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-8"><span class="post-toc-number">10.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题10-2：青蛙跳台阶问题"><span class="post-toc-number">11.</span> <span class="post-toc-text">面试题10-2：青蛙跳台阶问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-9"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-9"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题11：旋转数组的最小数字"><span class="post-toc-number">12.</span> <span class="post-toc-text">面试题11：旋转数组的最小数字</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-10"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-10"><span class="post-toc-number">12.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题12：矩阵中的路径"><span class="post-toc-number">13.</span> <span class="post-toc-text">面试题12：矩阵中的路径</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-11"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-11"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题13：机器人的运动范围"><span class="post-toc-number">14.</span> <span class="post-toc-text">面试题13：机器人的运动范围</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-12"><span class="post-toc-number">14.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-12"><span class="post-toc-number">14.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题14：剪绳子"><span class="post-toc-number">15.</span> <span class="post-toc-text">面试题14：剪绳子</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-13"><span class="post-toc-number">15.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-13"><span class="post-toc-number">15.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题15：二进制中1的个数"><span class="post-toc-number">16.</span> <span class="post-toc-text">面试题15：二进制中1的个数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-14"><span class="post-toc-number">16.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-14"><span class="post-toc-number">16.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题16：数值的整数次方"><span class="post-toc-number">17.</span> <span class="post-toc-text">面试题16：数值的整数次方</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-15"><span class="post-toc-number">17.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-15"><span class="post-toc-number">17.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题17：打印从1到最大的n位数"><span class="post-toc-number">18.</span> <span class="post-toc-text">面试题17：打印从1到最大的n位数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-16"><span class="post-toc-number">18.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-16"><span class="post-toc-number">18.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题18：删除链表的节点"><span class="post-toc-number">19.</span> <span class="post-toc-text">面试题18：删除链表的节点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-17"><span class="post-toc-number">19.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-17"><span class="post-toc-number">19.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题19：正则表达式匹配"><span class="post-toc-number">20.</span> <span class="post-toc-text">面试题19：正则表达式匹配</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-18"><span class="post-toc-number">20.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-18"><span class="post-toc-number">20.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题20：表示数值的字符串"><span class="post-toc-number">21.</span> <span class="post-toc-text">面试题20：表示数值的字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-19"><span class="post-toc-number">21.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-19"><span class="post-toc-number">21.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题21：调整数组顺序使奇数位于偶数前面"><span class="post-toc-number">22.</span> <span class="post-toc-text">面试题21：调整数组顺序使奇数位于偶数前面</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-20"><span class="post-toc-number">22.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-20"><span class="post-toc-number">22.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题22：链表中倒数第k个节点"><span class="post-toc-number">23.</span> <span class="post-toc-text">面试题22：链表中倒数第k个节点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-21"><span class="post-toc-number">23.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-21"><span class="post-toc-number">23.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题23：链表中环的入口节点"><span class="post-toc-number">24.</span> <span class="post-toc-text">面试题23：链表中环的入口节点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-22"><span class="post-toc-number">24.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-22"><span class="post-toc-number">24.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题24：反转链表"><span class="post-toc-number">25.</span> <span class="post-toc-text">面试题24：反转链表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-23"><span class="post-toc-number">25.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-23"><span class="post-toc-number">25.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题25：合并两个排序的链表"><span class="post-toc-number">26.</span> <span class="post-toc-text">面试题25：合并两个排序的链表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-24"><span class="post-toc-number">26.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分析-24"><span class="post-toc-number">26.2.</span> <span class="post-toc-text">分析</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-sword-finger-offer-notes"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">《剑指offer第二版》阅读笔记（一）</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-02-19 15:10:52" datetime="2020-02-19T07:10:52.000Z"  itemprop="datePublished">2020-02-19</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>面试季来临，于是最近两天阅读了《剑指offer第二版》这本程序员面试必备书籍，全书题目不多，但是涵盖了许多重要的知识点，通过自己的阅读也收获良多，所以写下这个阅读笔记。该笔记对书中的面试题进行了自己的分析，相比于原书有的放矢，因此精简了很多，这样做一是加深自己对每个题的印象，二是可以方便今后复习时无需再次看原书，简单的过一下笔记就好。</p>
<a id="more"></a>

<blockquote>
<p>注：使用的《剑指offer第二版》是2017年出版的。另外，原书代码是C++，本文侧重于使用Java，但是其实编程语言并不是重点，主要是学习思想以及与编程语言无关的代码风格。</p>
</blockquote>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul>
<li><a href="/2020/02/19/sword-finger-offer-notes/" title="《剑指offer第二版》阅读笔记（一）">《剑指offer第二版》阅读笔记（一）</a></li>
<li><a href="/2020/02/20/sword-finger-offer-notes-part-two/" title="《剑指offer第二版》阅读笔记（二）">《剑指offer第二版》阅读笔记（二）</a></li>
<li><a href="/2020/02/21/sword-finger-offer-notes-part-three/" title="《剑指offer第二版》阅读笔记（三）">《剑指offer第二版》阅读笔记（三）</a>

</li>
</ul>
<h2 id="面试题3-1：找出数组中重复的数字"><a href="#面试题3-1：找出数组中重复的数字" class="headerlink" title="面试题3-1：找出数组中重复的数字"></a>面试题3-1：找出数组中重复的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个长度为 n 的数组 nums 里的所有数字都在 0~n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>有两个很容易想到的方案：</p>
<ol>
<li><code>排序</code>，然后遍历数组，判断nums[i] == nums[i-1]，时间复杂度$O(n\log n)$，空间复杂度$O(1)$</li>
<li><code>使用HashSet</code>，时间复杂度$O(n)$，空间复杂度$O(n)$</li>
</ol>
<p>但是这样题目中“所有数字都在 0~n-1 之间”的条件根本没有用到，这也提示我们需要认真阅读题中每一句话，而不能惯性思维，题目看到一半或者大致一看就开始码代码了。</p>
<p>那这个条件怎么用呢？由于所有的数字都在 0~n-1 之间，和数组的下标范围刚好一致，如果数组中没有重复数字，那么排序后数组的索引和数值会一一对应，即<code>nums[i] = i</code>，而真实情况是有一些数字是重复的，所以<strong>会有多个数字来竞争某个特定索引</strong>，这样便可以判断该索引对应的数字是有重复的。</p>
<p>那如何排序无重复数字的数组呢？我们可以遍历数组，每次遇到索引<code>i</code>，如果有<code>nums[i] == i</code>，说明此数字已在正确位置；否则需要将数字<code>nums[i]</code>放到正确的位置，即放在索引为<code>nums[i]</code>的位置，此时可以将索引为<code>i</code>和<code>nums[i]</code>的元素进行交换，这样索引为<code>nums[i]</code>的数字<code>nums[nums[i]]</code>便处于正确位置了。这样完成遍历后，所有的数字都会和自己的索引一一对应。</p>
<p>对于有重复数字的数组而言，会遇到<code>nums[i] != i</code>但是<code>nums[nums[i]] == nums[i]</code>，这说明在索引<code>nums[i]</code>的位置有两个数字竞争，也就是数字<code>nums[i]</code>肯定是重复的。</p>
<p>相应的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// nums[i]应该放到索引i的位置</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[nums[i]] == nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                swap(nums, i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然是双重循环，但是每一个数到达相应正确的位置后便不会变化了，总体时间复杂度为$O(n)$，空间复杂度$O(1)$。</p>
<p>这一题借助数组的下标作为key来寻找重复元素，其实本质上还是哈希表，只不过使用HashSet、HashMap明面上开辟了空间，而借助数组下标巧妙的节省了空间。因此对于元素在0~n-1、1~n甚至k~n+k-1之间的数组的相关问题，可以考虑这种思路。</p>
<h2 id="面试题3-2：不修改数组找出重复元素"><a href="#面试题3-2：不修改数组找出重复元素" class="headerlink" title="面试题3-2：不修改数组找出重复元素"></a>面试题3-2：不修改数组找出重复元素</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。请找出数组中任意一个重复的数字，但不能修改输入的数组。</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>和上题一样，不修改原数组可以使用HashSet轻松完成，那么如何使用数字在1到n之间的条件来降低时间或空间复杂度呢？我们在这里还可以使用二分查找的思想，我们把1~n的数字从中间的数字m分成两部分，前一半为1~m，后一半为m+1~n，如果1~m之间的数字的数量大于m，则证明这一半的区间一定包含重复数字；否则，另一半m+1~n的区间里一定包含重复的数字，我们可以继续把包含重复数字的区间一分为二，直到找到一个重复数字，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法的时间复杂度为$O(n\log n)$，空间复杂度为$O(n)$。需要注意的是，这个算法并不能找出所有的重复数字，算法能work的重要点是数组长度是n+1而数字范围是1~n。</p>
<h2 id="面试题4：二维数组中的查找"><a href="#面试题4：二维数组中的查找" class="headerlink" title="面试题4：二维数组中的查找"></a>面试题4：二维数组中的查找</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br></pre></td></tr></table></figure>

<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>乍一看可以使用二分查找，但是会有点问题，对于任意<code>matrix[row][col]</code>，比它小的元素、比它大的元素都是一个不规则形状，而且是存在重叠的，所以是不好处理的。</p>
<p>注意到右上角元素的特殊性：是同一行的最大值，是同一列的最小值。如果target大于当前位置的值，则target肯定不处于当前行中，因为行已经排序，所以考虑下一行；反之如果target小于当前位置的值，则target肯定不处于当前列中，因为列同样已经排序，所以考虑前一列。每一次我们可以排除一行或者一列，总体的时间复杂度为$O(m+n)$，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; matrix.length &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; matrix[row][col]) &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题5：替换空格"><a href="#面试题5：替换空格" class="headerlink" title="面试题5：替换空格"></a>面试题5：替换空格</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”</p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>非常简单，遍历字符串，当遇到空格时进行替换即可，值得注意的是java中String是不可变的，循环中不能使用String不断拼接而需要用StringBuilder代替。时间复杂度和空间复杂度均为$O(n)$。</p>
<h2 id="面试题6：从尾到头打印链表"><a href="#面试题6：从尾到头打印链表" class="headerlink" title="面试题6：从尾到头打印链表"></a>面试题6：从尾到头打印链表</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值。</p>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>链表只能顺序访问，但是却需要后面的先打印， 所以主要有两种常见方法：</p>
<ol>
<li>先进后出（FIFO）的需要，因此可以使用<strong>栈</strong></li>
<li>从后向前打印，可以使用<strong>递归</strong>，先走至链表末端，回溯时依次将节点值加入列表</li>
</ol>
<p>这两种方法的时间复杂度均为$O(n)$，空间复杂度均为$O(n)$。</p>
<h2 id="面试题7：重建二叉树"><a href="#面试题7：重建二叉树" class="headerlink" title="面试题7：重建二叉树"></a>面试题7：重建二叉树</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line"></span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>

<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p><strong>经验总结：二叉树的问题一般都是分治思想，递归去做。因为二叉树本身就是递归定义的。</strong></p>
<p>首先需要明白前序遍历、中序遍历、后序遍历的意义：</p>
<ul>
<li>前序遍历：父节点 -&gt; 左子节点 -&gt; 右子节点</li>
<li>中序遍历：左子节点 -&gt; 父节点 -&gt; 右子节点</li>
<li>后序遍历：左子节点 -&gt; 右子节点 -&gt; 父节点</li>
</ul>
<blockquote>
<p>注： 需要掌握这三种遍历的递归以及迭代的实现！LeetCode有相应原题。</p>
</blockquote>
<p>我们可以发现<strong>前序遍历的第一个结点一定是根节点，在中序遍历中，根结点把中序遍历序列分成了两个部分，左边部分构成了二叉树的根结点的左子树，右边部分构成了二叉树的根结点的右子树</strong>。我们可以找到根节点在中序遍历中的位置，然后可以进一步得出左子树和右子数的大小，从而可以在前序遍历序列中找到根节点的左子节点和右子节点，最后递归的进行便能够构建二叉树。</p>
<div align=center>
<img src="http://image.yingzq.com/img/20200219194729.png" width="600" alt="重建二叉树示意图" />

<p>重建二叉树示意图</p>
</div>

<p>具体的代码如下，很容易看懂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, inorder, <span class="number">0</span>, <span class="number">0</span>, inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt;= preorder.length || inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">        <span class="comment">// index代表目前的根节点在中序遍历中的位置</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">for</span> (index = inStart; index &lt;= inEnd; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[index] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归的构建子树</span></span><br><span class="line">        root.left = helper(preorder, inorder, preStart + <span class="number">1</span>, inStart, index - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(preorder, inorder, preStart + index - inStart + <span class="number">1</span>, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，根据中序遍历和后序遍历也使用类似的方法构建出二叉树，因为<strong>后序遍历的最后一个节点一定是根节点</strong>，然后不断的根据中序遍历找到根节点的左子节点、右子节点即可。</p>
<h2 id="面试题8：二叉树的下一个节点"><a href="#面试题8：二叉树的下一个节点" class="headerlink" title="面试题8：二叉树的下一个节点"></a>面试题8：二叉树的下一个节点</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>主要考察中序遍历的知识，中序遍历求当前节点的下一个节点有以下几种情况：</p>
<ol>
<li>当前节点为空，则直接返回空。</li>
<li>当前节点存在右子树，则下一个节点为右子树最左子节点。</li>
<li>若该节点不存在右子树，这时又分为两种情况：<ul>
<li>该节点为父节点的左子节点，则下一个节点为其父节点；</li>
<li>该节点为父节点的右子节点，则沿着父节点向上遍历，直到找到<strong>一个节点的父节点的左子节点为该节点</strong>，此时该节点的父节点便是下一个节点。</li>
</ul>
</li>
</ol>
<h2 id="面试题9：用两个栈实现队列"><a href="#面试题9：用两个栈实现队列" class="headerlink" title="面试题9：用两个栈实现队列"></a>面试题9：用两个栈实现队列</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>队列是先进先出，栈是先进后出，所以利用两个栈，先将数据压入stack1，再将stack1的数据压入stack2，此时stack2中的数据进行弹出时便相当于队列。</p>
<p>由于过程中 appendTail 和 deleteHead 是交叉进行的，我们可以做如下约定：</p>
<ul>
<li>进行 appendTail 时，直接向stack1中压入数据即可。</li>
<li>进行 deleteHead 时，如果stack2不为空，直接输出stack2弹出的结果；否则将stack1中所有数据弹出并压入stack2中，然后再输出stack2中弹出的结果。</li>
</ul>
<p>此时利用均摊的思想，appendTail 和 deleteHead 函数的时间复杂度为$O(1)$。</p>
<p>与之相关的问题还有<code>用两个队列实现一个栈</code>，假如有两个队列q1和q2，当模拟栈压入数据时，只需要向q1中压入数据，当模拟栈弹出数据时，由于队列只能弹出队首的数据，所以有如下思路：假设n是目前q1中的数据总数，对于前n-1个数据，将q1中的数据依次弹出并同时插入到q2中，q1中的最后一个数据则是我们需要的结果，弹出并返回即可。这样实现的系统插入数据的时间复杂度为$O(1)$，弹出数据则为$O(n)$。</p>
<h2 id="面试题10-1：斐波那契数列"><a href="#面试题10-1：斐波那契数列" class="headerlink" title="面试题10-1：斐波那契数列"></a>面试题10-1：斐波那契数列</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>

<ol>
<li>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</li>
<li>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</li>
</ol>
<h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>很多C语言教科书在讲述递归函数时，都会用斐波拉契数列作为例子，其实那种递归的写法效率是非常非常低的，时间复杂度是指数级的，千万不要用！</p>
<p>使用递归方法之所以低效是因为有着大量的重复计算，例如计算F(10)和F(9)向下递归时都会计算F(8)的值。因此我们可以将中间状态保存起来，减少计算量，自底向上的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">long</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> sec = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> nval = first + sec;</span><br><span class="line">            first = sec;</span><br><span class="line">            sec = nval % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) sec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法的时间复杂度为$O(n)$，其实还有复杂度更低的基于数学的方法，将斐波拉契数列推导成为一个较为生僻的公式，一般不常用，在这里就略过了。</p>
<h2 id="面试题10-2：青蛙跳台阶问题"><a href="#面试题10-2：青蛙跳台阶问题" class="headerlink" title="面试题10-2：青蛙跳台阶问题"></a>面试题10-2：青蛙跳台阶问题</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>设跳上n级台阶有 <code>f(n)</code> 种跳法，在所有跳法中，青蛙的最后一步只有两种情况：<strong>跳上 1 级或 2 级台阶</strong>：</p>
<ol>
<li>当为 1 级台阶： 剩 n-1 个台阶，此情况共有 <code>f(n-1)</code> 种跳法；</li>
<li>当为 2 级台阶： 剩 n-2 个台阶，此情况共有 <code>f(n-2)</code> 种跳法。</li>
</ol>
<p>可以得出<code>f(n) = f(n-1) + f(n-2)</code>，因此本题可转化为求斐波那契数列第 n 项的值。</p>
<h2 id="面试题11：旋转数组的最小数字"><a href="#面试题11：旋转数组的最小数字" class="headerlink" title="面试题11：旋转数组的最小数字"></a>面试题11：旋转数组的最小数字</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p>最简单的一个解法是遍历数组，时间复杂度$O(n)$。但是没有用到“旋转数组”的性质，很明显，对于在经过旋转的递增数组的查找，是需要用二分查找来实现$O(\log n)$时间复杂度算法。</p>
<p>对于经过旋转的有序数组，当数组内没有相等元素时，一共有如下3种情景：</p>
<div align=center>
<img src="http://image.yingzq.com/img/20200219235223.png" width="600" alt="旋转的有序数组" />

<p>旋转的有序数组</p>
</div>

<p>可以看出<code>nums[lo], nums[mid], nums[hi]</code>的相对大小决定了最小值所在的区间，这里我们只使用<code>nums[mid], nums[hi]</code>进行分析：</p>
<ul>
<li>当<code>nums[mid] &gt; nums[hi]</code>时，说明是情景二，此时最小值在右半区，因此<code>lo = mid + 1</code>即可。</li>
<li>当<code>nums[mid] &lt; nums[hi]</code>时，说明是情景一或情景三，此时两种情景的最小值均在左半区，但是有可能就是<code>nums[mid]</code>，因此<code>hi = mid</code>即可。</li>
<li>当<code>lo == hi</code>时，循环停止，<code>nums[lo]</code>即为最小值。</li>
</ul>
<p>但是这一题是可能会有重复元素的，当出现<code>nums[mid] == nums[hi]</code>时最小元素在哪个半区呢？其实是都有可能的，是无法确定的，例如 对于 [2,1,2,2,2] 最小值在左半区，对于 [2,2,2,1,2] 则是在右半区。在这里我们直接舍弃<code>nums[hi]</code>，也就是将<code>hi--</code>即可，这是因为此时循环未停止，说明<code>mid &lt; hi</code>，但是此时<code>nums[mid] == nums[hi]</code>，所以<code>lo~hi-1</code>之间的最小值是一定和<code>lo~hi</code>之间的最小值相等的，因此直接舍弃最后一个元素是不影响结果的。</p>
<p>最终代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[hi]) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[hi]) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题12：矩阵中的路径"><a href="#面试题12：矩阵中的路径" class="headerlink" title="面试题12：矩阵中的路径"></a>面试题12：矩阵中的路径</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>很明显直接使用回溯法（或者说DFS）即可，直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exist(board, word, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> idx, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == m || y == n || word.charAt(idx) != board[x][y]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[x][y] ^= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist(board, word, idx + <span class="number">1</span>, x + dir[<span class="number">0</span>], y + dir[<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] ^= <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面有几个点可以学习：</p>
<ul>
<li>首先是边界条件、结束条件的判断放到了最前面，使得代码非常清晰。</li>
<li>其次，对于该问题的回溯法来说，需要一个与<code>board</code>相同大小的<code>visited</code>数组来记录某个位置是否已经访问，但是这样便需要额外的开辟$O(n^2)$的空间，这里一个更巧妙的办法是修改原数组的值，这里使用了<code>board[x][y] ^= 256</code>修改原数组，然后在方法调用结束时再次异或将数组还原，其实这里不一定要使用异或，只需要将该位置的字符先变成一个有区分度的字符，最后再修改回来即可。</li>
<li>最后，使用<code>dirs</code>的方向数组可以任意控制方向，而且使得代码清晰而简洁。</li>
</ul>
<h2 id="面试题13：机器人的运动范围"><a href="#面试题13：机器人的运动范围" class="headerlink" title="面试题13：机器人的运动范围"></a>面试题13：机器人的运动范围</h2><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><p>同样使用回溯法（或者说DFS），只需要写一个判断当前方格是否有效的方法即可；另外可以使用成员变量<code>count</code>来进行记录，每次调用方法前记得进行初始化。</p>
<p>由于并不需要返回运行的完整路径，所以这一题使用BFS也是很好的选择。</p>
<h2 id="面试题14：剪绳子"><a href="#面试题14：剪绳子" class="headerlink" title="面试题14：剪绳子"></a>面试题14：剪绳子</h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 <code>k[0]*k[1]*...*k[m]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><p>首先可以使用自底向上的<strong>动态规划</strong>。设f(n)为长度为n的绳子可以得到的最大乘积，我们可以将f(n)的问题分解成求更小规模f(n-k)的问题，可以得出递推公式为<code>f(n) = max{f(1)*f(n-1), f(2)*f(n-2), ... , f(n-1)*f(1)}</code>，但是这个公式中还存在一些问题，例如求长度为3的绳子时可以分为长度为1、2的两段绳子，这时是可以不需要将长度为2的绳子再次进行裁剪的，因此当绳子长为2时函数返回1，但是当绳子长度大于2时需要<code>f(2) = 2</code>。可以证明，当<code>n &lt; 4</code>时<code>n &gt; i*(n - i)</code>，即此时绳子不裁剪时反而有最大值，所以这部分值做特殊处理即可。算法有双重循环，时间复杂度为$O(n^2)$，空间复杂度为$O(n)$，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123; <span class="comment">// 另一半情况是对称的，因此搜索一半即可</span></span><br><span class="line">                max = Math.max(max, dp[j] * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种解法利用到了一点数学知识：<strong>n个数和一定的情况下，数字越均匀，积越大。</strong> 但是并不知道具体需要分成多少段（即题目中的m不确定），因此m需要遍历2~n，在每一次循环中，尽可能的均分绳子得到局部最大值，最后得到全局最大值。</p>
<p>最后一种解法可以说是找规律，也可以说是贪婪算法：<strong>当 n &gt; 4 时尽可能的分解出更多的3，当 n = 4 时分解出两个2</strong>。简单证明下：当n &lt; 4时直接返回特定结果，当n = 4时最大值为2*2=4，当n &gt; 4时<code>任何整数都可以使用3和2来合成</code>，且有<code>2*(n-2) &gt; n, 3*(n-3) &gt; n</code>，也就是当绳子剩下的长度大于4时，应该将它剪成长度为3或者长度为2的绳子，另外当n &gt; 4时<code>2*(n-2) &lt;= 3*(n-3)</code>，因此应该尽可能剪出更多的长度为3的绳子段，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;  <span class="comment">// 全部分解为3</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, n / <span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) &#123;  <span class="comment">// 分解到最后剩一个4</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, n / <span class="number">3</span> - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 分解到最后剩一个2</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, n / <span class="number">3</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以不借助<code>Math.pow()</code>，使用迭代的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题15：二进制中1的个数"><a href="#面试题15：二进制中1的个数" class="headerlink" title="面试题15：二进制中1的个数"></a>面试题15：二进制中1的个数</h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><p>很显然直接使用位运算即可。值得注意的是，在java中<code>&gt;&gt;</code>是带符号右移，正数右移高位补0，负数右移高位补1；<code>&gt;&gt;&gt;</code>是无符号右移，无论是正数还是负数，高位通通补0。另外java中有<code>Integer.bitCount()</code>方法，可以直接统计输入整数对应二进制中1的个数。</p>
<h2 id="面试题16：数值的整数次方"><a href="#面试题16：数值的整数次方" class="headerlink" title="面试题16：数值的整数次方"></a>面试题16：数值的整数次方</h2><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数。</p>
<h3 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h3><p>最开始想到的就是循环<code>exponent</code>次，但是其实不用，比如我们求某个数的32次方，我们只需要知道这个数的16次方，然后两个16次方进行相乘即可，求16次方又只需要知道8次方的值，以此类推，时间复杂度为$O(\log n)$。</p>
<p>这样这一题基本解决了，但是需要注意细节！如果<code>exponent</code>是负数怎么办？<code>exponent</code>奇数偶数情况是否一样？除以2的操作可以使用位运算代替？代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">            x = x * x;</span><br><span class="line">            n = n / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span> ? myPow(x * x, n &gt;&gt;&gt; <span class="number">1</span>) : x * myPow(x * x, n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题17：打印从1到最大的n位数"><a href="#面试题17：打印从1到最大的n位数" class="headerlink" title="面试题17：打印从1到最大的n位数"></a>面试题17：打印从1到最大的n位数</h2><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<h3 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h3><p>不考虑大数问题此题非常简单，先求出最大的n位十进制数，然后循环打印即可。此题没有规定n的大小，所以n有可能非常大，所代表的十进制数可能超出int，甚至是long的上界，此时应该如何处理呢？数组是可以很长的，因此我们可以利用长度为n的数组来代表长度为n的十进制数，然后在数组上模拟整数加法即可。</p>
<h2 id="面试题18：删除链表的节点"><a href="#面试题18：删除链表的节点" class="headerlink" title="面试题18：删除链表的节点"></a>面试题18：删除链表的节点</h2><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<h3 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h3><p>非常简单，有一个要点是使用一个<strong>虚拟节点</strong>，这样当要删除的节点刚好是头结点时也不需要额外处理。</p>
<h2 id="面试题19：正则表达式匹配"><a href="#面试题19：正则表达式匹配" class="headerlink" title="面试题19：正则表达式匹配"></a>面试题19：正则表达式匹配</h2><h3 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数用来匹配包含<code>&#39;.&#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>

<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
</ul>
<h3 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h3><p>如果没有<code>*</code>，问题会很简单：我们只需要从左到右检查匹配串<code>s</code>是否能匹配模式串<code>p</code>的每一个字符，遇到<code>.</code>也只需要简单处理下就可以了。</p>
<p>当模式中有<code>*</code>时，情况就比较麻烦了，在这里使用动态规划来做。</p>
<p><strong>状态</strong><br>定义二维数组<code>dp</code>，<code>dp[i][j]</code>表示<code>s</code>的前<code>i</code>个是否能被<code>p</code>的前<code>j</code>个匹配。</p>
<p><strong>转移方程</strong><br>怎么想转移方程？首先想的时候从已经求出了<code>dp[i-1][j-1]</code>入手，再加上已知<code>s[i]</code>、<code>p[j]</code>，要想的问题就是怎么去求<code>dp[i][j]</code>。</p>
<ol>
<li>先考虑最简单的，如果<code>s[i] == p[j]</code>，那么有<code>dp[i][j] = dp[i-1][j-1]</code>。</li>
<li>如果<code>p[j] == &#39;.&#39;</code>，那么有<code>dp[i][j] = dp[i-1][j-1]</code>。</li>
<li>如果<code>p[j] == &#39;*&#39;</code>，情况比较复杂，下文主要探讨这种情况。</li>
</ol>
<p><code>*</code>的含义是<strong>匹配零个或多个前面的那一个元素</strong>，所以要考虑它前面的元素<code>p[j-1]</code>。<code>*</code>跟着它前一个字符走，前一个能匹配上<code>s[i]</code>，<code>*</code>才能有用，前一个都不能匹配上<code>s[i]</code>，<code>*</code>也无能为力，只能让前一个字符消失，也就是匹配0次前一个字符。</p>
<p>所以按照<code>p[j-1]</code>和<code>s[i]</code>是否相等，我们分为两种情况：</p>
<ul>
<li>如果<code>p[j-1] != s[i]</code>，这就是刚才说的那种前一个字符匹配不上的情况，那么就将<code>*</code>和它前面的字符全部舍弃，因此有<code>dp[i][j] = dp[i][j-2]</code>。</li>
<li>如果<code>p[j-1] == s[i] || p[j-1] == &#39;.&#39;</code>，这说明最后一个字符是可以匹配的，现在关键是要看前面的部分是否匹配，这里可以有3种情况，只需要满足其一即可：<ol>
<li><code>dp[i][j] = dp[i-1][j]</code>，多个字符匹配的情况，例如<code>a* -&gt; aa</code></li>
<li><code>dp[i][j] = dp[i][j-1]</code>，单个字符匹配的情况，例如<code>a* -&gt; a</code></li>
<li><code>dp[i][j] = dp[i][j-2]</code>，不进行匹配的情况，即舍弃<code>a*</code></li>
</ol>
</li>
</ul>
<p>最终代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][i-<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j-<span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = (dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这题实在是有一点点麻烦~~</p>
<h2 id="面试题20：表示数值的字符串"><a href="#面试题20：表示数值的字符串" class="headerlink" title="面试题20：表示数值的字符串"></a>面试题20：表示数值的字符串</h2><h3 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”及”-1E-16”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<h3 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h3><p>表示数值的字符串遵循模式<code>A[.[B]][e|EC]</code>或者<code>.B[e|EC]</code>，其中<code>A</code>为数值的整数部分，<code>B</code>紧跟着小数点为数值的小数部分，<code>C</code>紧跟着<code>e</code>或<code>E</code>为数值的指数部分。上述<code>A</code>和<code>C</code>都是整数（可以有正负号，也可以没有），而<code>B</code>是一个无符号整数。这一题具体的代码我认为不重要，根据这两个模式按部就班的判断即可。</p>
<h2 id="面试题21：调整数组顺序使奇数位于偶数前面"><a href="#面试题21：调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题21：调整数组顺序使奇数位于偶数前面"></a>面试题21：调整数组顺序使奇数位于偶数前面</h2><h3 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p><em>**示例</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4]</span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ol>
<li>1 &lt;= nums.length &lt;= 50000</li>
<li>1 &lt;= nums[i] &lt;= 10000</li>
</ol>
<h3 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h3><p>可以使用双指针法，具体有两种：</p>
<ol>
<li>首尾双指针法：<ul>
<li>定义双指针<code>lo = 0, hi = nums.length-1</code>，一个在首部，一个在尾部</li>
<li><code>lo</code>一直往右移，直到<code>nums[lo]</code>为偶数；<code>hi</code>一直往左移，直到<code>nums[hi]</code>为奇数</li>
<li>交换<code>nums[lo]</code>和<code>nums[hi]</code>，然后需要<code>lo++, hi--</code></li>
<li>重复上述操作，直到<code>lo == hi</code></li>
</ul>
</li>
<li>快慢双指针法：<ul>
<li>定义双指针<code>slow = 0, fast = 0</code>，一个会运动的快，一个会运动的慢</li>
<li><code>fast</code>的作用是向前搜索奇数位置，<code>slow</code>的作用是指向下一个奇数应当存放的位置</li>
<li><code>fast</code>向前移动，当它搜索到奇数时，将<code>nums[fast]</code>和<code>nums[low]</code>交换，然后将<code>low</code>向前移动一个位置</li>
<li>重复上述操作，直到<code>fast</code>指向数组末尾</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 首尾双指针法</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] % <span class="number">2</span> == <span class="number">1</span>) lo++;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] % <span class="number">2</span> == <span class="number">0</span>) hi--;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[lo];</span><br><span class="line">            nums[lo] = nums[hi];</span><br><span class="line">            nums[hi] = tmp;</span><br><span class="line">            lo++;hi--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 快慢双指针法</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[fast] &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;  <span class="comment">// 这种判断奇偶数的方法也可以学习</span></span><br><span class="line">                <span class="keyword">int</span> temp = nums[fast];</span><br><span class="line">                nums[fast] = nums[slow];</span><br><span class="line">                nums[slow] = temp;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题22：链表中倒数第k个节点"><a href="#面试题22：链表中倒数第k个节点" class="headerlink" title="面试题22：链表中倒数第k个节点"></a>面试题22：链表中倒数第k个节点</h2><h3 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<h3 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h3><p>经典题目，直接快慢双指针法即可，需要注意的是一些小问题：输入的链表为空、输入的k值不合理等情况，总体来说在可能出现空指针的地方需要仔细思考。</p>
<h2 id="面试题23：链表中环的入口节点"><a href="#面试题23：链表中环的入口节点" class="headerlink" title="面试题23：链表中环的入口节点"></a>面试题23：链表中环的入口节点</h2><h3 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>说明：不允许修改给定的链表。</p>
<h3 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h3><p>最简单的方法是使用<code>HashSet</code>，用一个集合保存已经访问过的节点，我们可以遍历整个链表并返回第一个出现重复的节点。算法的时间复杂度、空间复杂度均为$O(n)$。</p>
<p>第二种方法是<code>Floyd 算法</code>，它的出发点是<strong>一个跑得快的人和一个跑得慢的人在一个圆形的赛道上赛跑，会发生什么？在某一个时刻，跑得快的人一定会从后面赶上跑得慢的人</strong>。<code>Floyd算法</code>被划分成两个不同的阶段 。在第一阶段，找出列表中是否有环，如果没有环，可以直接返回null并退出。否则，用<strong>相遇节点</strong>来找到环的入口。</p>
<p><strong>阶段一</strong><br>初始化两个指针：快指针和慢指针。快指针每次移动两步，慢指针每次移动一步，如果能够相遇，证明链表存在环，进入阶段二；否则fast指针会迭代到null，证明不存在环，直接返回null即可。</p>
<p><strong>阶段二</strong><br>给定阶段一找到的<strong>相遇点</strong>，阶段二将找到环的入口。首先我们初始化两个指针： ptr1 ，指向链表的头， ptr2 指向相遇点。然后，我们每次将它们往前移动一步，直到它们相遇，它们相遇的点就是环的入口，返回这个节点。</p>
<p>这里简单的说明下原因：假设环的周长为<code>R</code>，阶段一在慢指针迭代了<code>k</code>步之后相遇，则有<code>2k-k=nR -&gt; k=nR</code>，其中n为某个正整数。假设链表的头结点与环入口的距离为<code>s</code>，环入口与阶段一的相遇点的距离为<code>m</code>，可以得到<code>k=s+m+lR -&gt; s=k-m-lR=(n-l)R-m</code>，其中l为某个小于n的正整数，而相遇点到环入口的距离刚好是<code>R-m</code>，因此ptr1和ptr2下一次相遇的地方刚好是环的入口。</p>
<p><code>Floyd算法</code>相应代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实还有一个不错的方法，分为3个步骤：</p>
<ol>
<li>利用快慢指针法找到相遇点</li>
<li>根据相遇点再次遍历节点得到环的大小C</li>
<li>重新初始化两个快慢指针指向链表的头，其中快指针先移动C步，然后快慢指针每次同时向前移动一步，直到相遇，相遇点即为环的入口</li>
</ol>
<h2 id="面试题24：反转链表"><a href="#面试题24：反转链表" class="headerlink" title="面试题24：反转链表"></a>面试题24：反转链表</h2><h3 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<h3 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h3><p>使用3个变量<code>prev, cur, next</code>，然后迭代一轮便可以完成，非常简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题25：合并两个排序的链表"><a href="#面试题25：合并两个排序的链表" class="headerlink" title="面试题25：合并两个排序的链表"></a>面试题25：合并两个排序的链表</h2><h3 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<h3 id="分析-24"><a href="#分析-24" class="headerlink" title="分析"></a>分析</h3><p>迭代和递归都可以完成，很经典的一道题，为了加深印象分别都写一下，细节可以看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迭代</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) prev.next = l1;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) prev.next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-03-03T09:51:34.339Z" itemprop="dateUpdated">2020-03-03 17:51:34</time>
</span><br>


        
        若有疑问或者本人有写的不对的地方, 欢迎留言反馈, 非常感谢您的阅读~
        
    </div>
    
    <footer>
        <a href="http://www.yingzq.com">
            <img src="/img/avatar.jpg" alt="应子强">
            应子强
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/&title=《《剑指offer第二版》阅读笔记（一）》 — yingzq's Blog&pic=http://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/&title=《《剑指offer第二版》阅读笔记（一）》 — yingzq's Blog&source=面试季来临，于是最近两天阅读了《剑指offer第二版》这本程序员面试必备书籍，全书题目不多，但是涵盖了许多重要的知识点，通过自己的阅读也收获良多，所以写下..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《《剑指offer第二版》阅读笔记（一）》 — yingzq's Blog&url=http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/&via=http://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/02/20/sword-finger-offer-notes-part-two/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">《剑指offer第二版》阅读笔记（二）</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/12/25/common-sorting-algorithms/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">常见排序算法（归纳分析及java实现）</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'true' == 'true',
            appId: "mGqkrgTscxf4JdcqkEHkFCfs-gzGzoHsz",
            appKey: "PwU9oOfhNnWOKaMaOTqQpiNW",
            avatar: "mm",
            placeholder: "要不要说点什么？",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>应子强 &copy; 2019 - 2020</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">京ICP备19041830号</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/&title=《《剑指offer第二版》阅读笔记（一）》 — yingzq's Blog&pic=http://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/&title=《《剑指offer第二版》阅读笔记（一）》 — yingzq's Blog&source=面试季来临，于是最近两天阅读了《剑指offer第二版》这本程序员面试必备书籍，全书题目不多，但是涵盖了许多重要的知识点，通过自己的阅读也收获良多，所以写下..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《《剑指offer第二版》阅读笔记（一）》 — yingzq's Blog&url=http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/&via=http://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJklEQVR42u3aQW7DMAwFUd//0u62QBNnPikHNTVeBYgi6XnBkKKOAz/nr+fdt39H8vFklQWPDBkyHss4Lx8yJuWtWleGDBm7MTphkSz8bi0y2/XeZMiQIaM1dZg+ErYMGTJkEAbZCofJkCFDBmfwlK52HJYmlDfW4jJkyHggg2/i+59v6W/IkCHjUYwzfPrpIx8T7EqGDBmjGTzAkYKzP1tnBhkyZExl1FqM1yP5wVln9WPVRDJkyPj3DFIPpsGXX9FIX1YQ3GXIkDGIwX+cbpq/lAWhVoYMGRsw0qnTBmQafJfdFpEhQ8YIBtkQL03TVJLzgopchgwZ4xirDsjStkHnBb34LEOGjNEMft2BFKU8EPO0LwjBMmTIGM2oFbHpJYxOwG01NWXIkDGCkRaxabJYu64Rj5QhQ8ZQRu1naaKWtg14WfuiFpchQ8Y4BllybSOz00KI25kyZMgYxOgsfL1ArUxtFbEyZMgYzeC3F9b+llDjWlyGDBlDGSQdvKO1GWy0dtlChgwZQxlpyli74EW+jfsbMmTIGM3opH2161ydwliGDBn7MM7w4QdwZIb0BcXdDBkyZIxgrD3oJxsiMJJW1kK2DBkynssgy8QNRZwI8sO7D0FfhgwZGzCCI/gw4JJwyf8BPpSyMmTIkAFIdySCqHiWIUOGjEVH/LVQixoSMmTI2IDBL361Fqt1WUnxLEOGjNEMHij5NYt+a7P2NyBDhoxxjB9PKEup+GvHdwAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来练习bug!';
            clearTimeout(titleTime);
        } else {
            document.title = 'yingzq's Blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
