<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>《程序员面试经典》阅读笔记 | yingzq&#39;s Blog | 练习bug时长两年半的实习生</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="数据结构与算法,Java,阅读笔记">
    <meta name="description" content="LeetCode中文版上线了 程序员面试经典（第6版） 的相关算法题，本人在以前的空余时间做了前 70 题（一共 109 题），在这里对于已经做过的题简单梳理下，方便以后复习。">
<meta property="og:type" content="article">
<meta property="og:title" content="《程序员面试经典》阅读笔记">
<meta property="og:url" content="https://www.yingzq.com/2020/08/28/cracking-the-coding-interview-notes/index.html">
<meta property="og:site_name" content="yingzq&#39;s Blog">
<meta property="og:description" content="LeetCode中文版上线了 程序员面试经典（第6版） 的相关算法题，本人在以前的空余时间做了前 70 题（一共 109 题），在这里对于已经做过的题简单梳理下，方便以后复习。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-28T07:47:53.000Z">
<meta property="article:modified_time" content="2020-08-30T13:44:51.547Z">
<meta property="article:author" content="应子强">
<meta property="article:tag" content="数据结构与算法">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="阅读笔记">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="yingzq&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/avatar.jpg">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">应子强</h5>
          <a href="mailto:yingzq0116@163.com" title="yingzq0116@163.com" class="mail">yingzq0116@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签云
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-info-circle"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/YingZiqiang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">《程序员面试经典》阅读笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">《程序员面试经典》阅读笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-08-28T07:47:53.000Z" itemprop="datePublished" class="page-time">
  2020-08-28
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题01-01-判定字符是否唯一"><span class="post-toc-number">1.</span> <span class="post-toc-text">面试题01.01. 判定字符是否唯一</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-01-02-判定是否互为字符重排"><span class="post-toc-number">2.</span> <span class="post-toc-text">面试题 01.02. 判定是否互为字符重排</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-1"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-1"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-01-03-URL化"><span class="post-toc-number">3.</span> <span class="post-toc-text">面试题 01.03. URL化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-2"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-2"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-01-04-回文排列"><span class="post-toc-number">4.</span> <span class="post-toc-text">面试题 01.04. 回文排列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-3"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-3"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-01-05-一次编辑"><span class="post-toc-number">5.</span> <span class="post-toc-text">面试题 01.05. 一次编辑</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-4"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-4"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-01-06-字符串压缩"><span class="post-toc-number">6.</span> <span class="post-toc-text">面试题 01.06. 字符串压缩</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-5"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-5"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-01-07-旋转矩阵"><span class="post-toc-number">7.</span> <span class="post-toc-text">面试题 01.07. 旋转矩阵</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-6"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-6"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-01-08-零矩阵"><span class="post-toc-number">8.</span> <span class="post-toc-text">面试题 01.08. 零矩阵</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-7"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-7"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-01-09-字符串轮转"><span class="post-toc-number">9.</span> <span class="post-toc-text">面试题 01.09. 字符串轮转</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-8"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-8"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-02-01-移除重复节点"><span class="post-toc-number">10.</span> <span class="post-toc-text">面试题 02.01. 移除重复节点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-9"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-9"><span class="post-toc-number">10.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-02-02-返回倒数第-k-个节点"><span class="post-toc-number">11.</span> <span class="post-toc-text">面试题 02.02. 返回倒数第 k 个节点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-10"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-10"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-02-03-删除中间节点"><span class="post-toc-number">12.</span> <span class="post-toc-text">面试题 02.03. 删除中间节点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-11"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-11"><span class="post-toc-number">12.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-02-04-分割链表"><span class="post-toc-number">13.</span> <span class="post-toc-text">面试题 02.04. 分割链表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-12"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-12"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-02-05-链表求和"><span class="post-toc-number">14.</span> <span class="post-toc-text">面试题 02.05. 链表求和</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-13"><span class="post-toc-number">14.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-13"><span class="post-toc-number">14.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-02-06-回文链表"><span class="post-toc-number">15.</span> <span class="post-toc-text">面试题 02.06. 回文链表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-14"><span class="post-toc-number">15.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-14"><span class="post-toc-number">15.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-02-07-链表相交"><span class="post-toc-number">16.</span> <span class="post-toc-text">面试题 02.07. 链表相交</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-15"><span class="post-toc-number">16.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-15"><span class="post-toc-number">16.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-02-08-环路检测"><span class="post-toc-number">17.</span> <span class="post-toc-text">面试题 02.08. 环路检测</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-16"><span class="post-toc-number">17.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-16"><span class="post-toc-number">17.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-03-01-三合一"><span class="post-toc-number">18.</span> <span class="post-toc-text">面试题 03.01. 三合一</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-17"><span class="post-toc-number">18.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-17"><span class="post-toc-number">18.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-03-02-栈的最小值"><span class="post-toc-number">19.</span> <span class="post-toc-text">面试题 03.02. 栈的最小值</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-18"><span class="post-toc-number">19.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-18"><span class="post-toc-number">19.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-03-03-堆盘子"><span class="post-toc-number">20.</span> <span class="post-toc-text">面试题 03.03. 堆盘子</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-19"><span class="post-toc-number">20.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-19"><span class="post-toc-number">20.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-03-04-化栈为队"><span class="post-toc-number">21.</span> <span class="post-toc-text">面试题 03.04. 化栈为队</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-20"><span class="post-toc-number">21.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-20"><span class="post-toc-number">21.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-03-05-栈排序"><span class="post-toc-number">22.</span> <span class="post-toc-text">面试题 03.05. 栈排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-21"><span class="post-toc-number">22.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-21"><span class="post-toc-number">22.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-03-06-动物收容所"><span class="post-toc-number">23.</span> <span class="post-toc-text">面试题 03.06. 动物收容所</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-22"><span class="post-toc-number">23.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-22"><span class="post-toc-number">23.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-04-01-节点间通路"><span class="post-toc-number">24.</span> <span class="post-toc-text">面试题 04.01. 节点间通路</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-23"><span class="post-toc-number">24.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-23"><span class="post-toc-number">24.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-04-02-最小高度树"><span class="post-toc-number">25.</span> <span class="post-toc-text">面试题 04.02. 最小高度树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-24"><span class="post-toc-number">25.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-24"><span class="post-toc-number">25.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-04-03-特定深度节点链表"><span class="post-toc-number">26.</span> <span class="post-toc-text">面试题 04.03. 特定深度节点链表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-25"><span class="post-toc-number">26.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-25"><span class="post-toc-number">26.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-04-04-检查平衡性"><span class="post-toc-number">27.</span> <span class="post-toc-text">面试题 04.04. 检查平衡性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-26"><span class="post-toc-number">27.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-26"><span class="post-toc-number">27.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-04-05-合法二叉搜索树"><span class="post-toc-number">28.</span> <span class="post-toc-text">面试题 04.05. 合法二叉搜索树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-27"><span class="post-toc-number">28.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-27"><span class="post-toc-number">28.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-04-06-后继者"><span class="post-toc-number">29.</span> <span class="post-toc-text">面试题 04.06. 后继者</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-28"><span class="post-toc-number">29.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-28"><span class="post-toc-number">29.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-04-08-首个共同祖先"><span class="post-toc-number">30.</span> <span class="post-toc-text">面试题 04.08. 首个共同祖先</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-29"><span class="post-toc-number">30.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-29"><span class="post-toc-number">30.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-04-09-二叉搜索树序列"><span class="post-toc-number">31.</span> <span class="post-toc-text">面试题 04.09. 二叉搜索树序列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-30"><span class="post-toc-number">31.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-30"><span class="post-toc-number">31.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-04-10-检查子树"><span class="post-toc-number">32.</span> <span class="post-toc-text">面试题 04.10. 检查子树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-31"><span class="post-toc-number">32.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-31"><span class="post-toc-number">32.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-04-12-求和路径"><span class="post-toc-number">33.</span> <span class="post-toc-text">面试题 04.12. 求和路径</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-32"><span class="post-toc-number">33.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-32"><span class="post-toc-number">33.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-05-01-插入"><span class="post-toc-number">34.</span> <span class="post-toc-text">面试题 05.01. 插入</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-33"><span class="post-toc-number">34.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-33"><span class="post-toc-number">34.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-05-02-二进制数转字符串"><span class="post-toc-number">35.</span> <span class="post-toc-text">面试题 05.02. 二进制数转字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-34"><span class="post-toc-number">35.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-34"><span class="post-toc-number">35.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-05-03-翻转数位"><span class="post-toc-number">36.</span> <span class="post-toc-text">面试题 05.03. 翻转数位</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-35"><span class="post-toc-number">36.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-35"><span class="post-toc-number">36.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-05-04-下一个数"><span class="post-toc-number">37.</span> <span class="post-toc-text">面试题 05.04. 下一个数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-36"><span class="post-toc-number">37.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-36"><span class="post-toc-number">37.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-05-06-整数转换"><span class="post-toc-number">38.</span> <span class="post-toc-text">面试题 05.06. 整数转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-37"><span class="post-toc-number">38.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-37"><span class="post-toc-number">38.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-05-07-配对交换"><span class="post-toc-number">39.</span> <span class="post-toc-text">面试题 05.07. 配对交换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-38"><span class="post-toc-number">39.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-38"><span class="post-toc-number">39.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-05-08-绘制直线"><span class="post-toc-number">40.</span> <span class="post-toc-text">面试题 05.08. 绘制直线</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-39"><span class="post-toc-number">40.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-39"><span class="post-toc-number">40.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-01-三步问题"><span class="post-toc-number">41.</span> <span class="post-toc-text">面试题 08.01. 三步问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-40"><span class="post-toc-number">41.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-40"><span class="post-toc-number">41.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-02-迷路的机器人"><span class="post-toc-number">42.</span> <span class="post-toc-text">面试题 08.02. 迷路的机器人</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-41"><span class="post-toc-number">42.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-41"><span class="post-toc-number">42.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-03-魔术索引"><span class="post-toc-number">43.</span> <span class="post-toc-text">面试题 08.03. 魔术索引</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-42"><span class="post-toc-number">43.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-42"><span class="post-toc-number">43.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-04-幂集"><span class="post-toc-number">44.</span> <span class="post-toc-text">面试题 08.04. 幂集</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-43"><span class="post-toc-number">44.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-43"><span class="post-toc-number">44.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-05-递归乘法"><span class="post-toc-number">45.</span> <span class="post-toc-text">面试题 08.05. 递归乘法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-44"><span class="post-toc-number">45.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-44"><span class="post-toc-number">45.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-06-汉诺塔问题"><span class="post-toc-number">46.</span> <span class="post-toc-text">面试题 08.06. 汉诺塔问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-45"><span class="post-toc-number">46.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-45"><span class="post-toc-number">46.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-07-无重复字符串的排列组合"><span class="post-toc-number">47.</span> <span class="post-toc-text">面试题 08.07. 无重复字符串的排列组合</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-46"><span class="post-toc-number">47.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-46"><span class="post-toc-number">47.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-08-有重复字符串的排列组合"><span class="post-toc-number">48.</span> <span class="post-toc-text">面试题 08.08. 有重复字符串的排列组合</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-47"><span class="post-toc-number">48.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-47"><span class="post-toc-number">48.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-09-括号"><span class="post-toc-number">49.</span> <span class="post-toc-text">面试题 08.09. 括号</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-48"><span class="post-toc-number">49.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-48"><span class="post-toc-number">49.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-10-颜色填充"><span class="post-toc-number">50.</span> <span class="post-toc-text">面试题 08.10. 颜色填充</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-49"><span class="post-toc-number">50.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-49"><span class="post-toc-number">50.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-11-硬币"><span class="post-toc-number">51.</span> <span class="post-toc-text">面试题 08.11. 硬币</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-50"><span class="post-toc-number">51.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-50"><span class="post-toc-number">51.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-12-八皇后"><span class="post-toc-number">52.</span> <span class="post-toc-text">面试题 08.12. 八皇后</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-51"><span class="post-toc-number">52.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-51"><span class="post-toc-number">52.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-13-堆箱子"><span class="post-toc-number">53.</span> <span class="post-toc-text">面试题 08.13. 堆箱子</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-52"><span class="post-toc-number">53.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-52"><span class="post-toc-number">53.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-08-14-布尔运算"><span class="post-toc-number">54.</span> <span class="post-toc-text">面试题 08.14. 布尔运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-53"><span class="post-toc-number">54.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-53"><span class="post-toc-number">54.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-10-01-合并排序的数组"><span class="post-toc-number">55.</span> <span class="post-toc-text">面试题 10.01. 合并排序的数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-54"><span class="post-toc-number">55.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-54"><span class="post-toc-number">55.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-10-02-变位词组"><span class="post-toc-number">56.</span> <span class="post-toc-text">面试题 10.02. 变位词组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-55"><span class="post-toc-number">56.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-55"><span class="post-toc-number">56.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-10-03-搜索旋转数组"><span class="post-toc-number">57.</span> <span class="post-toc-text">面试题 10.03. 搜索旋转数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-56"><span class="post-toc-number">57.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-56"><span class="post-toc-number">57.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-10-05-稀疏数组搜索"><span class="post-toc-number">58.</span> <span class="post-toc-text">面试题 10.05. 稀疏数组搜索</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-57"><span class="post-toc-number">58.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-57"><span class="post-toc-number">58.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-10-09-排序矩阵查找"><span class="post-toc-number">59.</span> <span class="post-toc-text">面试题 10.09. 排序矩阵查找</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-58"><span class="post-toc-number">59.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-58"><span class="post-toc-number">59.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-10-10-数字流的秩"><span class="post-toc-number">60.</span> <span class="post-toc-text">面试题 10.10. 数字流的秩</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-59"><span class="post-toc-number">60.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-59"><span class="post-toc-number">60.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-10-11-峰与谷"><span class="post-toc-number">61.</span> <span class="post-toc-text">面试题 10.11. 峰与谷</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-60"><span class="post-toc-number">61.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-60"><span class="post-toc-number">61.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-16-01-交换数字"><span class="post-toc-number">62.</span> <span class="post-toc-text">面试题 16.01. 交换数字</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-61"><span class="post-toc-number">62.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-61"><span class="post-toc-number">62.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-16-02-单词频率"><span class="post-toc-number">63.</span> <span class="post-toc-text">面试题 16.02. 单词频率</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-62"><span class="post-toc-number">63.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-62"><span class="post-toc-number">63.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-16-03-交点"><span class="post-toc-number">64.</span> <span class="post-toc-text">面试题 16.03. 交点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-63"><span class="post-toc-number">64.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-63"><span class="post-toc-number">64.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-16-04-井字游戏"><span class="post-toc-number">65.</span> <span class="post-toc-text">面试题 16.04. 井字游戏</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-64"><span class="post-toc-number">65.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-64"><span class="post-toc-number">65.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-16-05-阶乘尾数"><span class="post-toc-number">66.</span> <span class="post-toc-text">面试题 16.05. 阶乘尾数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-65"><span class="post-toc-number">66.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-65"><span class="post-toc-number">66.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-16-06-最小差"><span class="post-toc-number">67.</span> <span class="post-toc-text">面试题 16.06. 最小差</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-66"><span class="post-toc-number">67.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-66"><span class="post-toc-number">67.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题-16-07-最大数值"><span class="post-toc-number">68.</span> <span class="post-toc-text">面试题 16.07. 最大数值</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#题目-67"><span class="post-toc-number">68.1.</span> <span class="post-toc-text">题目</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#笔记-67"><span class="post-toc-number">68.2.</span> <span class="post-toc-text">笔记</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-cracking-the-coding-interview-notes"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">《程序员面试经典》阅读笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-08-28 15:47:53" datetime="2020-08-28T07:47:53.000Z"  itemprop="datePublished">2020-08-28</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>LeetCode中文版上线了 <a href="https://leetcode-cn.com/problemset/lcci/" target="_blank" rel="noopener">程序员面试经典（第6版）</a> 的相关算法题，本人在以前的空余时间做了<strong>前 70 题（一共 109 题）</strong>，在这里对于已经做过的题简单梳理下，方便以后复习。</p>
<a id="more"></a>

<h2 id="面试题01-01-判定字符是否唯一"><a href="#面试题01-01-判定字符是否唯一" class="headerlink" title="面试题01.01. 判定字符是否唯一"></a>面试题01.01. 判定字符是否唯一</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p>
<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>排序</li>
<li>HashSet</li>
<li>用boolean数组表示HashSet</li>
<li>位运算</li>
</ol>
<p><strong>其中使用方法3和方法4时要注意题目的字符集范围！</strong></p>
<p>位运算没有想到：用二进制的每一位分别代表一个字母，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (astr == <span class="keyword">null</span> || astr.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : astr.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">if</span> ((mask &amp; temp) != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            mask |= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-01-02-判定是否互为字符重排"><a href="#面试题-01-02-判定是否互为字符重排" class="headerlink" title="面试题 01.02. 判定是否互为字符重排"></a>面试题 01.02. 判定是否互为字符重排</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<h3 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>排序</li>
<li>HashMap</li>
<li>用int数组代替HashMap</li>
</ol>
<p>注意这种题如果两个字符串长度不一致，直接就可以返回false了。</p>
<h2 id="面试题-01-03-URL化"><a href="#面试题-01-03-URL化" class="headerlink" title="面试题 01.03. URL化"></a>面试题 01.03. URL化</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>URL化。编写一种方法，将字符串中的空格全部替换为<code>%20</code>。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）</p>
<h3 id="笔记-2"><a href="#笔记-2" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>StringBuilder</li>
<li>str.replaceAll(“ “, “%20”)</li>
<li>双指针</li>
</ol>
<p>其中前两种方法均为<code>非原地更新</code>的方法，本题的本意肯定是希望读者使用<code>原地更新</code>的方法来完成。</p>
<p><strong>这种替换的题，由于前面替换会影响到后面，因此可以思考从后向前进行替换，然后利用双指针进行替换</strong>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpaces</span><span class="params">(String S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> spaceCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">' '</span>) spaceCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newLen = spaceCount * <span class="number">2</span> + length;</span><br><span class="line">        <span class="keyword">int</span> j = newLen - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                chars[j--] = <span class="string">'0'</span>;</span><br><span class="line">                chars[j--] = <span class="string">'2'</span>;</span><br><span class="line">                chars[j--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chars[j--] = chars[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars).substring(<span class="number">0</span>, newLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-01-04-回文排列"><a href="#面试题-01-04-回文排列" class="headerlink" title="面试题 01.04. 回文排列"></a>面试题 01.04. 回文排列</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。</p>
<p>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。</p>
<p>回文串不一定是字典当中的单词。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;tactcoa&quot;</span><br><span class="line">输出：true（排列有&quot;tacocat&quot;、&quot;atcocta&quot;，等等）</span><br></pre></td></tr></table></figure>

<h3 id="笔记-3"><a href="#笔记-3" class="headerlink" title="笔记"></a>笔记</h3><p>也就是完成如下判断：字符串中最多允许一个字符出现的频率为奇数，其余的必须都是偶数。</p>
<ol>
<li>HashMap</li>
<li>更精简的，可以使用HashSet</li>
<li>使用boolean数组代替HashSet</li>
<li>位运算</li>
</ol>
<p>其中使用方法3和方法4时要注意题目的字符集范围！</p>
<p>给出使用HashSet的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPermutePalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(c))&#123;</span><br><span class="line">                set.remove(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size() &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-01-05-一次编辑"><a href="#面试题-01-05-一次编辑" class="headerlink" title="面试题 01.05. 一次编辑"></a>面试题 01.05. 一次编辑</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<h3 id="笔记-4"><a href="#笔记-4" class="headerlink" title="笔记"></a>笔记</h3><p>编辑距离相关，只不过只能编辑一次。</p>
<p>只能编辑一次会有如下特性：</p>
<ul>
<li>如果 s1 和 s2 长度差大于 1， 直接返回false</li>
<li>如果 s1 和 s2 长度相等，仅有一次的编辑操作一定是<strong>替换</strong></li>
<li>如果 s1 长度大于 s2 长度，仅有一次的编辑操作一定是<strong>删除</strong></li>
<li>如果 s1 长度小于 s2 长度，仅有一次的编辑操作一定是<strong>插入</strong></li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">oneEditAway</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = first.length(), len2 = second.length();</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(len1 - len2) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len1 &amp;&amp; j &lt; len2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first.charAt(i) == second.charAt(j))&#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len1 &lt; len2)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-01-06-字符串压缩"><a href="#面试题-01-06-字符串压缩" class="headerlink" title="面试题 01.06. 字符串压缩"></a>面试题 01.06. 字符串压缩</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p>
<h3 id="笔记-5"><a href="#笔记-5" class="headerlink" title="笔记"></a>笔记</h3><p>一次遍历，使用StringBuilder不断更新。</p>
<h2 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a>面试题 01.07. 旋转矩阵</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？</p>
<h3 id="笔记-6"><a href="#笔记-6" class="headerlink" title="笔记"></a>笔记</h3><p>这类题找规律+原地交换即可。</p>
<h2 id="面试题-01-08-零矩阵"><a href="#面试题-01-08-零矩阵" class="headerlink" title="面试题 01.08. 零矩阵"></a>面试题 01.08. 零矩阵</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p>
<h3 id="笔记-7"><a href="#笔记-7" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>可以使用$O(m+n)$的空间复杂度来保存需要清零的行和列</li>
<li>使用原第一行和第一列来保存需要清零的行和列。</li>
</ol>
<p>方法2而代码如下，很长但是容易理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span> firstRow = <span class="keyword">false</span>, firstCol = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span>) firstRow = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>) firstCol = <span class="keyword">true</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (firstRow) &#123;</span><br><span class="line">            Arrays.fill(matrix[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (firstCol) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-01-09-字符串轮转"><a href="#面试题-01-09-字符串轮转" class="headerlink" title="面试题 01.09. 字符串轮转"></a>面试题 01.09. 字符串轮转</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。</p>
<h3 id="笔记-8"><a href="#笔记-8" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>暴力思考，验证所有可能的分割点</li>
<li>如果s2是通过s1轮转得到的，那么s2一定是s1+s1的子串，s1也一定是s2+s2的子串</li>
</ol>
<p>力扣主站第28题是实现java中的indexOf()，也就是寻找子串的操作，可以设计一个优雅的子串查找算法。</p>
<p>基础代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlipedString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() != s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        s1 += s1;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) != s2.charAt(<span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i + j) != s2.charAt(j)) <span class="keyword">break</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：这里实现的indexOf()方法时间复杂度 $O(mn)$ ，并不是最优的。</p>
</blockquote>
<p>我们也可以直接使用java内置的indexOf()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlipedString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() != s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> (s1+s1).indexOf(s2) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a>面试题 02.01. 移除重复节点</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>进阶：如果不得使用临时缓冲区，该怎么解决？</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1, 2, 3, 3, 2, 1]</span><br><span class="line">输出：[1, 2, 3]</span><br><span class="line"></span><br><span class="line">输入：[1, 1, 1, 1, 2]</span><br><span class="line">输出：[1, 2]</span><br></pre></td></tr></table></figure>

<h3 id="笔记-9"><a href="#笔记-9" class="headerlink" title="笔记"></a>笔记</h3><p>如果可以使用缓冲区，只需要用一个HashSet记录已访问节点值。</p>
<p>如果不可以使用缓冲区，只用$O(n)$的时间复杂度似乎做不到。我们可以使用两重循环来解决：其中第一重循环从链表的头节点开始，枚举一个保留的节点，这是因为我们保留的是<code>最开始出现的节点</code>；第二重循环从枚举的保留节点开始，到链表的末尾结束，将所有与保留节点相同的节点全部移除。</p>
<h2 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a>面试题 02.02. 返回倒数第 k 个节点</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<h3 id="笔记-10"><a href="#笔记-10" class="headerlink" title="笔记"></a>笔记</h3><p>快慢指针法。</p>
<p>如果题目中没有说明 k 总是有效的，需要留意 k 的不合法引起的空指针错误。</p>
<h2 id="面试题-02-03-删除中间节点"><a href="#面试题-02-03-删除中间节点" class="headerlink" title="面试题 02.03. 删除中间节点"></a>面试题 02.03. 删除中间节点</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p>
<h3 id="笔记-11"><a href="#笔记-11" class="headerlink" title="笔记"></a>笔记</h3><p>题目很新奇，不能拿到prev节点，那么就只有在next节点做文章了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-02-04-分割链表"><a href="#面试题-02-04-分割链表" class="headerlink" title="面试题 02.04. 分割链表"></a>面试题 02.04. 分割链表</h2><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><p>编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。</p>
<h3 id="笔记-12"><a href="#笔记-12" class="headerlink" title="笔记"></a>笔记</h3><p>最简单的方法是建立两个虚拟节点，然后分别连接应该在left和right的元素。</p>
<p>需要注意的是，最后的right链表的尾部的next指针一定要置为空，否则链表可能产生环。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode dummy1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode dummy2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode prev1 = dummy1, prev2 = dummy2;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val &lt; x)&#123;</span><br><span class="line">                prev1.next = head;</span><br><span class="line">                prev1 = prev1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev2.next = head;</span><br><span class="line">                prev2 = prev2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev2.next = <span class="keyword">null</span>;  <span class="comment">// 很关键的一步，不能漏洞</span></span><br><span class="line">        prev1.next = dummy2.next;</span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-02-05-链表求和"><a href="#面试题-02-05-链表求和" class="headerlink" title="面试题 02.05. 链表求和"></a>面试题 02.05. 链表求和</h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><p>给定两个用链表表示的整数，每个节点包含一个数位。</p>
<p>这些数位是反向存放的，也就是个位排在链表首部。</p>
<p>编写函数对这两个整数求和，并用链表形式返回结果。</p>
<h3 id="笔记-13"><a href="#笔记-13" class="headerlink" title="笔记"></a>笔记</h3><p>主站原题，注意最后的进位即可。</p>
<h2 id="面试题-02-06-回文链表"><a href="#面试题-02-06-回文链表" class="headerlink" title="面试题 02.06. 回文链表"></a>面试题 02.06. 回文链表</h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，检查输入的链表是否是回文的。</p>
<h3 id="笔记-14"><a href="#笔记-14" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>逆序整个链表，然后和原链表比较</li>
<li>用stack保存前半段，然后和后半段比较</li>
<li>反转后半段链表，然后和前半段比较，空间复杂度$O(1)$，同时要注意断开点next指针的情况</li>
</ol>
<h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h2><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><p>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。</p>
<h3 id="笔记-15"><a href="#笔记-15" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>set保存A中所有节点，接着遍历B，在链表中很多问题都是可以使用set、map方便的解决，只是产生了一定的空间复杂度而已</li>
<li>找到两个链表的长度差，然后利用快慢指针</li>
<li>是一种比较巧的方法</li>
</ol>
<p>方法3代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode a = headA, b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">            a = a == <span class="keyword">null</span> ? headB : a.next;</span><br><span class="line">            b = b == <span class="keyword">null</span> ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-02-08-环路检测"><a href="#面试题-02-08-环路检测" class="headerlink" title="面试题 02.08. 环路检测"></a>面试题 02.08. 环路检测</h2><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。</p>
<h3 id="笔记-16"><a href="#笔记-16" class="headerlink" title="笔记"></a>笔记</h3><p>经典问题，主站和剑指offer上都有。</p>
<p>方法1：利用Set进行求解，非常简单。注意Set存储的是ListNode对象而不是具体的value。</p>
<p>方法2：快慢指针。先找到一个linkedlist是不是有环，如果有环则找到环开始的位置，利用一个小数学知识即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-03-01-三合一"><a href="#面试题-03-01-三合一" class="headerlink" title="面试题 03.01. 三合一"></a>面试题 03.01. 三合一</h2><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><p>三合一。描述如何只用一个数组来实现三个栈。</p>
<p>你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。</p>
<h3 id="笔记-17"><a href="#笔记-17" class="headerlink" title="笔记"></a>笔记</h3><p>这题有点无聊…</p>
<p>就是在给不同的栈分配不同的位置（用索引表示）即可。为了方便可以写成数组的形式，例如<code>size1/size2/size3</code>可以写成<code>int[] size = new int[3]</code>，这样代码精简些。</p>
<h2 id="面试题-03-02-栈的最小值"><a href="#面试题-03-02-栈的最小值" class="headerlink" title="面试题 03.02. 栈的最小值"></a>面试题 03.02. 栈的最小值</h2><h3 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h3><p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为$O(1)$。</p>
<h3 id="笔记-18"><a href="#笔记-18" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>双栈法，用一个辅助栈来保存相应位置的最小值</li>
<li>最小元素标记的单栈法</li>
</ol>
<h2 id="面试题-03-03-堆盘子"><a href="#面试题-03-03-堆盘子" class="headerlink" title="面试题 03.03. 堆盘子"></a>面试题 03.03. 堆盘子</h2><h3 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h3><p>堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。</p>
<p>当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt 应返回 -1.</p>
<h3 id="笔记-19"><a href="#笔记-19" class="headerlink" title="笔记"></a>笔记</h3><p><strong>思路</strong></p>
<ol>
<li>新建一个<code>List&lt;Stack&lt;Integer&gt;&gt;</code>用来存放各个栈，而且栈的个数是动态变化的。</li>
<li>push的时候，可能需要新建一个栈，或者直接插入到最后一个栈中。</li>
<li>pop直接调用popAt方法。其中popAt方法需要处理的是弹出指定位置栈的栈顶元素。我们可以通过list拿到指定index的栈，拿到之后执行stack的pop操作即可。同时如果弹出栈顶元素之后，当前stack变成空了，需要将当前stack从list中移除。</li>
</ol>
<h2 id="面试题-03-04-化栈为队"><a href="#面试题-03-04-化栈为队" class="headerlink" title="面试题 03.04. 化栈为队"></a>面试题 03.04. 化栈为队</h2><h3 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h3><p>实现一个MyQueue类，该类用两个栈来实现一个队列。</p>
<h3 id="笔记-20"><a href="#笔记-20" class="headerlink" title="笔记"></a>笔记</h3><p>原题：剑指offer-面试题9。</p>
<h2 id="面试题-03-05-栈排序"><a href="#面试题-03-05-栈排序" class="headerlink" title="面试题 03.05. 栈排序"></a>面试题 03.05. 栈排序</h2><h3 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h3><p>栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。</p>
<h3 id="笔记-21"><a href="#笔记-21" class="headerlink" title="笔记"></a>笔记</h3><p><strong>未优化方法</strong></p>
<p>使用一个临时的辅助栈便可以维护一个有序栈：每次push前，将栈中元素比当前小的push到辅助栈中，完成后再push回来；每次pop只需将当前栈顶元素pop出来即可。</p>
<p>这样做有个问题，假设序列是一个逆序的序列，该方法每次push前都需要把已有的所有元素移到辅助栈中，非常的耗时。</p>
<p><strong>优化方法</strong></p>
<p>优化思路：考虑到<code>主栈栈顶元素 &gt;= 辅助栈栈顶元素</code>，如果处在中间的元素，我们直接放入辅助栈中，而不用来回倒了。</p>
<p>设新加入的元素为<code>x</code>，主栈栈顶为<code>y</code>、辅栈栈顶为<code>z</code>，此时一共有三种情况：</p>
<ol>
<li><code>x &gt;= y &gt;= z</code>，此时需要将主栈中的所有<code>小于x</code>的元素送到辅栈,将<code>x</code>加入主栈</li>
<li><code>y &gt;= x &gt;= z</code>，直接将<code>x</code>送入辅栈</li>
<li><code>y &gt;= z &gt;= x</code>，此时需要将辅栈中所有<code>大于x</code>的元素移到主栈，将<code>x</code>加入辅栈</li>
</ol>
<blockquote>
<p>参考文章 <a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/solution/java-shuang-zhan-duo-xing-geng-xin-17ms-9938-by-la/" target="_blank" rel="noopener">JAVA 双栈+惰性更新 17ms 99.38%</a> 和 <a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/solution/fei-you-hua-yu-you-hua-de-qu-bie-by-sa1024/" target="_blank" rel="noopener">非优化与优化的区别</a></p>
</blockquote>
<h2 id="面试题-03-06-动物收容所"><a href="#面试题-03-06-动物收容所" class="headerlink" title="面试题 03.06. 动物收容所"></a>面试题 03.06. 动物收容所</h2><h3 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h3><p>动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat。允许使用Java内置的LinkedList数据结构。</p>
<p>enqueue方法有一个animal参数，animal[0]代表动物编号，animal[1]代表动物种类，其中 0 代表猫，1 代表狗。</p>
<p>dequeue*方法返回一个列表[动物编号, 动物种类]，若没有可以收养的动物，则返回[-1,-1]。</p>
<h3 id="笔记-22"><a href="#笔记-22" class="headerlink" title="笔记"></a>笔记</h3><p>思路非常简单，用两个队列queue1、queue2分别保存猫和狗：</p>
<ul>
<li>enqueue(int[] animal)：分别让<code>animal[1]=0</code>的进queue1，<code>animal[1]=1</code>的进queue2。</li>
<li>dequeueAny()：若queue1，queue2均为空，则直接返回{-1,-1}；若其中有一个为空，则返回另一个的头部；若均不为空则分别取出头部比较序号即可。</li>
<li>dequeueDog()：queue2为空则返回{-1,-1};否则返回头部。</li>
<li>dequeueCat()：同上道理。</li>
</ul>
<h2 id="面试题-04-01-节点间通路"><a href="#面试题-04-01-节点间通路" class="headerlink" title="面试题 04.01. 节点间通路"></a>面试题 04.01. 节点间通路</h2><h3 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h3><p>节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</p>
<h3 id="笔记-23"><a href="#笔记-23" class="headerlink" title="笔记"></a>笔记</h3><p>注意，题目中是有向图，否则可以考虑并查集。</p>
<p>对于有向图中的两个节点是否存在路径的问题，有如下思路：</p>
<ol>
<li>构建邻接表</li>
<li>使用DFS或者BFS遍历进行判断</li>
</ol>
<p>其中BFS边界条件的处理和DFS是不太一样的，值得仔细看看。</p>
<p>BFS解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt;[] adj = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : graph)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">0</span>], to = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(adj[from] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                adj[from] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            adj[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(start);</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(adj[cur] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> next : adj[cur])&#123;</span><br><span class="line">                <span class="keyword">if</span>(next == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(visited.contains(next)) <span class="keyword">continue</span>;</span><br><span class="line">                visited.add(next);</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DFS解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt;[] adj = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : graph)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">0</span>], to = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(adj[from] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                adj[from] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            adj[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(adj, start, target, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] adj, <span class="keyword">int</span> cur, <span class="keyword">int</span> target, Set&lt;Integer&gt; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited.contains(cur)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        visited.add(cur);</span><br><span class="line">        <span class="keyword">if</span>(adj[cur] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> next : adj[cur])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(adj, next, target, visited)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里并不需要remove</span></span><br><span class="line">        <span class="comment">// visited.remove(cur);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-04-02-最小高度树"><a href="#面试题-04-02-最小高度树" class="headerlink" title="面试题 04.02. 最小高度树"></a>面试题 04.02. 最小高度树</h2><h3 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h3><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<h3 id="笔记-24"><a href="#笔记-24" class="headerlink" title="笔记"></a>笔记</h3><p>注意题目中是<code>有序数组</code>，因此不断用二分法找根节点来构造BST即为一颗平衡二叉树，也就是高度最小的二叉搜索树。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> builder(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">builder</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt; hi) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = builder(nums, lo, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = builder(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-04-03-特定深度节点链表"><a href="#面试题-04-03-特定深度节点链表" class="headerlink" title="面试题 04.03. 特定深度节点链表"></a>面试题 04.03. 特定深度节点链表</h2><h3 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。</p>
<h3 id="笔记-25"><a href="#笔记-25" class="headerlink" title="笔记"></a>笔记</h3><p>考察点：二叉树的层序遍历。</p>
<h2 id="面试题-04-04-检查平衡性"><a href="#面试题-04-04-检查平衡性" class="headerlink" title="面试题 04.04. 检查平衡性"></a>面试题 04.04. 检查平衡性</h2><h3 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h3><p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
<h3 id="笔记-26"><a href="#笔记-26" class="headerlink" title="笔记"></a>笔记</h3><p>首先可以使用一个height方法来得到某个节点的高度，这样便可以根据左右子树的高度差进行判断。</p>
<p>为了避免不必要的递归，可以有两种方法：</p>
<ol>
<li>使用一个boolean变量</li>
<li>高度是大于等于0的，所以可以利用-1</li>
</ol>
<p>给出第二种优化方法的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = height(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = height(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span> || right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left - right) &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考文章 <a href="https://leetcode.com/problems/balanced-binary-tree/discuss/35686/Java-solution-based-on-height-check-left-and-right-node-in-every-recursion-to-avoid-further-useless-search" target="_blank" rel="noopener">Java solution based on height, check left and right node in every recursion to avoid further useless search</a></p>
</blockquote>
<h2 id="面试题-04-05-合法二叉搜索树"><a href="#面试题-04-05-合法二叉搜索树" class="headerlink" title="面试题 04.05. 合法二叉搜索树"></a>面试题 04.05. 合法二叉搜索树</h2><h3 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h3><p>实现一个函数，检查一棵二叉树是否为二叉搜索树。</p>
<h3 id="笔记-27"><a href="#笔记-27" class="headerlink" title="笔记"></a>笔记</h3><p>有很多种不错的解法，这里列举两种：</p>
<ol>
<li>中序遍历需要是升序，可能的问题在于，它无法正确处理树中的重复值，如果树中没有重复值那就没问题了。</li>
<li>成为二叉搜索树的条件是：所有左边的节点必须小于或等 于当前节点，而当前节点必须小于所有右边的节点。按照二叉搜索树的定义来设计函数，这里需要注意边界问题。</li>
</ol>
<p>在递归算法中，一定要确保基线条件以及节点为空的情况得到 妥善处理。</p>
<p>给出方法2的代码，这里用long处理了边界，也可以使用Integer类来处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= min || root.val &gt;= max) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, min, root.val) &amp;&amp; isValidBST(root.right, root.val, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-04-06-后继者"><a href="#面试题-04-06-后继者" class="headerlink" title="面试题 04.06. 后继者"></a>面试题 04.06. 后继者</h2><h3 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h3><p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p>
<p>如果指定节点没有对应的“下一个”节点，则返回null。</p>
<h3 id="笔记-28"><a href="#笔记-28" class="headerlink" title="笔记"></a>笔记</h3><p>所谓 p 的后继节点，就是这串升序数字中，比 p 大的下一个。</p>
<ol>
<li>如果 p 大于当前节点的值，说明后继节点一定在 RightTree</li>
<li>如果 p 等于当前节点的值，说明后继节点一定在 RightTree</li>
<li>如果 p 小于当前节点的值，说明后继节点一定在 LeftTree 或自己就是<br> 3.1 递归调用 LeftTree，如果是空的，说明当前节点就是答案<br> 3.2 如果不是空的，则说明在 LeftTree 已经找到合适的答案，直接返回即可</li>
</ol>
<p>相应代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val &gt;= root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> inorderSuccessor(root.right, p);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode left = inorderSuccessor(root.left, p);</span><br><span class="line">            <span class="keyword">return</span> left == <span class="keyword">null</span> ? root : left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-04-08-首个共同祖先"><a href="#面试题-04-08-首个共同祖先" class="headerlink" title="面试题 04.08. 首个共同祖先"></a>面试题 04.08. 首个共同祖先</h2><h3 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h3><p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p>
<h3 id="笔记-29"><a href="#笔记-29" class="headerlink" title="笔记"></a>笔记</h3><p>对于二叉树，节点值的相对大小没有意义，因此我们需要在左右子树中查找是否存在p或者p，如果p和q分别在两个子树中，那么就说明根节点就是最低公共祖先。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-04-09-二叉搜索树序列"><a href="#面试题-04-09-二叉搜索树序列" class="headerlink" title="面试题 04.09. 二叉搜索树序列"></a>面试题 04.09. 二叉搜索树序列</h2><h3 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h3><p>从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉搜索树，输出所有可能生成此树的数组。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定如下二叉树：</span><br><span class="line">        2</span><br><span class="line">       &#x2F; \</span><br><span class="line">      1   3</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">[</span><br><span class="line">   [2,1,3],</span><br><span class="line">   [2,3,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="笔记-30"><a href="#笔记-30" class="headerlink" title="笔记"></a>笔记</h3><p>主要分为两个步骤，第一次做的时候把第二个步骤想简单了：</p>
<ol>
<li>把root节点左边的形成的所有可能捕获，右边形成的所有可能也捕获。</li>
<li>把左右形成的集合的每一对都进行编织融合，这一步并不是只有root-&gt;left-&gt;right和root-&gt;right-&gt;left这两种，而是left和right的元素可以任意穿插的。</li>
</ol>
<p>相应代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; BSTSequences(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; prefix = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        prefix.add(root.val);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lefts = BSTSequences(root.left);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; rights = BSTSequences(root.right);</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; left : lefts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(List&lt;Integer&gt; right : rights)&#123;</span><br><span class="line">                weaveLists((LinkedList&lt;Integer&gt;)left, (LinkedList&lt;Integer&gt;)right, prefix, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">weaveLists</span><span class="params">(LinkedList&lt;Integer&gt; left, LinkedList&lt;Integer&gt; right,</span></span></span><br><span class="line"><span class="function"><span class="params">        LinkedList&lt;Integer&gt; prefix, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.size() == <span class="number">0</span> || right.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;(prefix);</span><br><span class="line">            temp.addAll(left);</span><br><span class="line">            temp.addAll(right);</span><br><span class="line">            res.add(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> head = left.removeFirst();</span><br><span class="line">        prefix.add(head);</span><br><span class="line">        weaveLists(left, right, prefix, res);</span><br><span class="line">        prefix.removeLast();</span><br><span class="line">        left.addFirst(head);</span><br><span class="line"></span><br><span class="line">        head = right.removeFirst();</span><br><span class="line">        prefix.add(head);</span><br><span class="line">        weaveLists(left, right, prefix, res);</span><br><span class="line">        prefix.removeLast();</span><br><span class="line">        right.addFirst(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-04-10-检查子树"><a href="#面试题-04-10-检查子树" class="headerlink" title="面试题 04.10. 检查子树"></a>面试题 04.10. 检查子树</h2><h3 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h3><p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。</p>
<p>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>
<h3 id="笔记-31"><a href="#笔记-31" class="headerlink" title="笔记"></a>笔记</h3><p>一道经典的双递归（一次前序遍历，一次dfs）的题：</p>
<ol>
<li>需要设计一个函数判断t2是t1的子树，不一定非要以t1的根节点为初始位置，即为题中的checkSubTree函数。</li>
<li>还需要设计一个函数来判断当以树a的根节点为初始位置时b树是不是a树的子树，命名为isMatching函数。</li>
</ol>
<p>相应代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isMatching(t1, t2) || checkSubTree(t1.left, t2) || checkSubTree(t1.right, t2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatching</span><span class="params">(TreeNode a, TreeNode b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.val != b.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isMatching(a.left, b.left) &amp;&amp; isMatching(a.right, b.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-04-12-求和路径"><a href="#面试题-04-12-求和路径" class="headerlink" title="面试题 04.12. 求和路径"></a>面试题 04.12. 求和路径</h2><h3 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>
<h3 id="笔记-32"><a href="#笔记-32" class="headerlink" title="笔记"></a>笔记</h3><p>这一题暂时使用的是双递归，也就是前序遍历+dfs，但是肯定还有更好的方法，等以后再想想。</p>
<p>双递归代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        preorder(root, sum);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        rootPathSum(root, sum);</span><br><span class="line">        preorder(root.left, sum);</span><br><span class="line">        preorder(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rootPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>) count++;</span><br><span class="line">        rootPathSum(root.left, sum);</span><br><span class="line">        rootPathSum(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-05-01-插入"><a href="#面试题-05-01-插入" class="headerlink" title="面试题 05.01. 插入"></a>面试题 05.01. 插入</h2><h3 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h3><p>插入。给定两个32位的整数N与M，以及表示比特位置的i与j。编写一种方法，将M插入N，使得M从N的第j位开始，到第i位结束。假定从j位到i位足以容纳M，也即若M = 10 011，那么j和i之间至少可容纳5个位。例如，不可能出现j = 3和i = 2的情况，因为第3位和第2位之间放不下M。</p>
<h3 id="笔记-33"><a href="#笔记-33" class="headerlink" title="笔记"></a>笔记</h3><p>按题目的意思，并不是把 M 移位后和 N 相加，而只是单纯地覆盖。所以可以分两步进行：</p>
<ol>
<li>把 N 中 i ~ j 的位置先置零</li>
<li>把 M 左移 i 位后和 N 相加</li>
</ol>
<p>关键在于第一步，如何将N中的i~j的位置的元素置零，其实是有很多方法可以选择的。</p>
<p>其中一种代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBits</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((N &amp; mask) != <span class="number">0</span>) N -= mask;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N + (M &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-05-02-二进制数转字符串"><a href="#面试题-05-02-二进制数转字符串" class="headerlink" title="面试题 05.02. 二进制数转字符串"></a>面试题 05.02. 二进制数转字符串</h2><h3 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h3><p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字不在0和1之间，或者无法精确地用32位以内的二进制表示，则打印“ERROR”。</p>
<h3 id="笔记-34"><a href="#笔记-34" class="headerlink" title="笔记"></a>笔记</h3><p>首先得弄清楚非整数的数字用二进制表示是什么样的。</p>
<p>用乘2法可以很轻松的解决，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printBin</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span> || num &gt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"0."</span>);</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.length() &gt;= <span class="number">32</span>) <span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> r = num * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(r &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">"1"</span>);</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-05-03-翻转数位"><a href="#面试题-05-03-翻转数位" class="headerlink" title="面试题 05.03. 翻转数位"></a>面试题 05.03. 翻转数位</h2><h3 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h3><p>给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p>
<h3 id="笔记-35"><a href="#笔记-35" class="headerlink" title="笔记"></a>笔记</h3><p>使用两个变量来prevLen、curLen来保存相应的状态即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(~num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">int</span> prevLen = <span class="number">0</span>, curLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                curLen++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prevLen = (num &amp; <span class="number">2</span>) == <span class="number">0</span> ? <span class="number">0</span> : curLen;</span><br><span class="line">                curLen = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            max = Math.max(max, prevLen + curLen + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-05-04-下一个数"><a href="#面试题-05-04-下一个数" class="headerlink" title="面试题 05.04. 下一个数"></a>面试题 05.04. 下一个数</h2><h3 id="题目-36"><a href="#题目-36" class="headerlink" title="题目"></a>题目</h3><p>下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。</p>
<h3 id="笔记-36"><a href="#笔记-36" class="headerlink" title="笔记"></a>笔记</h3><p>目前的思路：</p>
<ul>
<li>比 num 大的数：从右往左，找到第一个 01 位置，然后把 01 转为 10，右侧剩下的 1 移到右侧的低位，右侧剩下的位清0。</li>
<li>比 num 小的数：从右往左，找到第一个 10 位置，然后把 10 转为 01，右侧剩下的 1 移到右侧的高位，右侧剩下的位清0。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findClosedNumbers(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] larger = toBitArray(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(larger[i] == <span class="number">0</span> &amp;&amp; larger[i-<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                larger[i] = <span class="number">1</span>;</span><br><span class="line">                larger[i-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> lo = <span class="number">0</span>, hi = i-<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; larger[lo] == <span class="number">1</span>) lo++;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; larger[hi] == <span class="number">0</span>) hi--;</span><br><span class="line">                    <span class="keyword">int</span> temp = larger[lo];</span><br><span class="line">                    larger[lo] = larger[hi];</span><br><span class="line">                    larger[hi] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                res[<span class="number">0</span>] = toNum(larger);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] smaller = toBitArray(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(smaller[i] == <span class="number">1</span> &amp;&amp; smaller[i-<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                smaller[i] = <span class="number">0</span>;</span><br><span class="line">                smaller[i-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> lo = <span class="number">0</span>, hi = i-<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; smaller[lo] == <span class="number">0</span>) lo++;</span><br><span class="line">                    <span class="keyword">while</span>(lo &lt; hi &amp;&amp; smaller[hi] == <span class="number">1</span>) hi--;</span><br><span class="line">                    <span class="keyword">int</span> temp = smaller[lo];</span><br><span class="line">                    smaller[lo] = smaller[hi];</span><br><span class="line">                    smaller[hi] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                res[<span class="number">1</span>] = toNum(smaller);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] toBitArray(<span class="keyword">int</span> num)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; <span class="number">1</span>) == <span class="number">1</span>) arr[idx] = <span class="number">1</span>;</span><br><span class="line">            idx++;</span><br><span class="line">            num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">toNum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                num += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-05-06-整数转换"><a href="#面试题-05-06-整数转换" class="headerlink" title="面试题 05.06. 整数转换"></a>面试题 05.06. 整数转换</h2><h3 id="题目-37"><a href="#题目-37" class="headerlink" title="题目"></a>题目</h3><p>整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。</p>
<h3 id="笔记-37"><a href="#笔记-37" class="headerlink" title="笔记"></a>笔记</h3><p>题目的意思其实就是求出A和B的二进制表示有多少位不同。</p>
<p>我们有如下两种方法：</p>
<ol>
<li>一位一位的进行比较，同时计数。</li>
<li>直接求出A和B异或的结果中1的个数，可以使用n&amp;(n-1)可消除最右侧1的技巧。</li>
</ol>
<h2 id="面试题-05-07-配对交换"><a href="#面试题-05-07-配对交换" class="headerlink" title="面试题 05.07. 配对交换"></a>面试题 05.07. 配对交换</h2><h3 id="题目-38"><a href="#题目-38" class="headerlink" title="题目"></a>题目</h3><p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。</p>
<h3 id="笔记-38"><a href="#笔记-38" class="headerlink" title="笔记"></a>笔记</h3><p>思路如下：</p>
<ol>
<li>左移一位，然后将所有的奇数位置mask为0</li>
<li>右移一位，然后将所有的偶数位置mask为0</li>
<li>将两者进行或运算（其实相加也是可以的）</li>
</ol>
<p>PS：先mask再移动也是可以的。</p>
<p>下面给出两种解法的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((num &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xaaaaaaaa</span>) | ((num &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((num &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;&gt; <span class="number">1</span>) | ((num &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-05-08-绘制直线"><a href="#面试题-05-08-绘制直线" class="headerlink" title="面试题 05.08. 绘制直线"></a>面试题 05.08. 绘制直线</h2><h3 id="题目-39"><a href="#题目-39" class="headerlink" title="题目"></a>题目</h3><p>绘制直线。有个单色屏幕存储在一个一维数组中，使得32个连续像素可以存放在一个 int 里。屏幕宽度为w，且w可被32整除（即一个 int 不会分布在两行上），屏幕高度可由数组长度及屏幕宽度推算得出。请实现一个函数，绘制从点(x1, y)到点(x2, y)的水平线。</p>
<p>给出数组的长度 length，宽度 w（以比特为单位）、直线开始位置 x1（比特为单位）、直线结束位置 x2（比特为单位）、直线所在行数 y。返回绘制过后的数组。</p>
<h3 id="笔记-39"><a href="#笔记-39" class="headerlink" title="笔记"></a>笔记</h3><p>要理解题意…</p>
<p>核心思想：定位到开始和结束的int，将这两个和其中间的所有int全部置为-1，然后再把开始和结束位置的int做特殊处理。</p>
<p>注意：start和end可能操作的是一个int，因此在求end的时候用的是&amp;=。</p>
<p>相应代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] drawLine(<span class="keyword">int</span> length, <span class="keyword">int</span> w, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> offset = y * w / <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">int</span> start = x1 / <span class="number">32</span> + offset;</span><br><span class="line">        <span class="keyword">int</span> end = x2 / <span class="number">32</span> + offset;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;i++)&#123;</span><br><span class="line">            res[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[start] &gt;&gt;&gt;= (x1 % <span class="number">32</span>);</span><br><span class="line">        res[end] &amp;= (Integer.MIN_VALUE &gt;&gt; x2 % <span class="number">32</span>);  <span class="comment">// 方法一</span></span><br><span class="line">        <span class="comment">// res[end] &amp;= (-1 &lt;&lt; (31 - x2 % 32));  // 方法二</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-08-01-三步问题"><a href="#面试题-08-01-三步问题" class="headerlink" title="面试题 08.01. 三步问题"></a>面试题 08.01. 三步问题</h2><h3 id="题目-40"><a href="#题目-40" class="headerlink" title="题目"></a>题目</h3><p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p>
<h3 id="笔记-40"><a href="#笔记-40" class="headerlink" title="笔记"></a>笔记</h3><p>简单的dp，其实可以使用O(1)的空间复杂度，但是为了直观，可以先弄成O(n)的。</p>
<h2 id="面试题-08-02-迷路的机器人"><a href="#面试题-08-02-迷路的机器人" class="headerlink" title="面试题 08.02. 迷路的机器人"></a>面试题 08.02. 迷路的机器人</h2><h3 id="题目-41"><a href="#题目-41" class="headerlink" title="题目"></a>题目</h3><p>设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。</p>
<h3 id="笔记-41"><a href="#笔记-41" class="headerlink" title="笔记"></a>笔记</h3><p>常规dfs+路径记录。要注意的是：</p>
<ol>
<li>只能往左下走，看清题意</li>
<li>访问过的永远不需要再次访问，也就是退出函数不需要将visited置为false</li>
<li>终止条件是什么？达到右下角：x == m-1 &amp;&amp; y == n-1</li>
<li>题中只需要找一条路径即可，可以将dfs的函数返回值改成boolean，这样在找到一条后就无须接着寻找了</li>
<li>本题是一定有解的，如果可能没解还要做特殊处理</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathWithObstacles(<span class="keyword">int</span>[][] obstacleGrid) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        dfs(obstacleGrid, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n], res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">boolean</span>[][] visited, List&lt;List&lt;Integer&gt;&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(x == m || y == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[x][y] == <span class="number">1</span> || visited[x][y]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        path.add(Arrays.asList(x, y));</span><br><span class="line">        <span class="keyword">if</span>(x == m-<span class="number">1</span> &amp;&amp; y == n-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(obstacleGrid, x+<span class="number">1</span>, y, visited, path) || dfs(obstacleGrid, x, y+<span class="number">1</span>, visited, path))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-08-03-魔术索引"><a href="#面试题-08-03-魔术索引" class="headerlink" title="面试题 08.03. 魔术索引"></a>面试题 08.03. 魔术索引</h2><h3 id="题目-42"><a href="#题目-42" class="headerlink" title="题目"></a>题目</h3><p>魔术索引。 在数组A[0…n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。</p>
<h3 id="笔记-42"><a href="#笔记-42" class="headerlink" title="笔记"></a>笔记</h3><p>此题有两个不好处理的地方：</p>
<ol>
<li>不仅需要找到魔术索引，还需要找到最小的，所以当nums[k] == k时，k不一定是最终的结果。</li>
<li>nums数组不是严格单调递增的。</li>
</ol>
<p>暴力法就是遍历一遍数组，不再多提。</p>
<p>方法1：所以可以使用递归版的二分搜索，但是这并不是一个传统意义上的O(log n)的递归，我们只是在nums[k] == k时再次搜索左半部分，否则只能排除k位置不是最终答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt; hi) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == mid)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = search(nums, lo, mid-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(left &gt; -<span class="number">1</span>) <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = search(nums, lo, mid-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(left &gt; -<span class="number">1</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">int</span> right = search(nums, mid+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2：可以对方法1进行一个小优化，当nums[mid] != mid时，方法1是接着搜索lo<del>mid-1和mid+1</del>hi，这里其实可以更精确点：</p>
<ol>
<li>当nums[mid] &gt; mid时，只需要搜索lo~mid-1和nums[mid]~hi</li>
<li>当nums[mid] &lt; mid时，只需要搜索lo~nums[mid]和mid+1~hi</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt; hi) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == mid)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = search(nums, lo, mid-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(left &gt; -<span class="number">1</span>) <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; mid)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = search(nums, lo, mid-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(left &gt; -<span class="number">1</span>) <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">return</span> search(nums, nums[mid], hi);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> left = search(nums, lo, nums[mid]);</span><br><span class="line">            <span class="keyword">if</span>(left &gt; -<span class="number">1</span>) <span class="keyword">return</span> left;</span><br><span class="line">            <span class="keyword">return</span> search(nums, mid+<span class="number">1</span>, hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-08-04-幂集"><a href="#面试题-08-04-幂集" class="headerlink" title="面试题 08.04. 幂集"></a>面试题 08.04. 幂集</h2><h3 id="题目-43"><a href="#题目-43" class="headerlink" title="题目"></a>题目</h3><p>幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。</p>
<p>说明：解集不能包含重复的子集。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入： nums &#x3D; [1,2,3]</span><br><span class="line"> 输出：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="笔记-43"><a href="#笔记-43" class="headerlink" title="笔记"></a>笔记</h3><p>回溯法，需要根据题目的意思调整递归边界条件，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(nums, <span class="number">0</span>, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList)</span></span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt; nums.length;i++)&#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(nums, i+<span class="number">1</span>, res, tempList);</span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看总结过的一篇关于回溯的文章<a href="https://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/">一种处理回溯问题的通用方法</a> 。</p>
<h2 id="面试题-08-05-递归乘法"><a href="#面试题-08-05-递归乘法" class="headerlink" title="面试题 08.05. 递归乘法"></a>面试题 08.05. 递归乘法</h2><h3 id="题目-44"><a href="#题目-44" class="headerlink" title="题目"></a>题目</h3><p>递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。</p>
<h3 id="笔记-44"><a href="#笔记-44" class="headerlink" title="笔记"></a>笔记</h3><p>主要思路是用加法和位移代替乘法，相应代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> larger = A &gt; B ? A : B;</span><br><span class="line">        <span class="keyword">int</span> smaller = A &gt; B ? B : A;</span><br><span class="line">        <span class="keyword">return</span> helper(larger, smaller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> larger, <span class="keyword">int</span> smaller)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(smaller == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(smaller == <span class="number">1</span>) <span class="keyword">return</span> larger;</span><br><span class="line">        <span class="keyword">int</span> half = helper(larger, smaller &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(smaller % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> half + half;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> half + half + larger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-08-06-汉诺塔问题"><a href="#面试题-08-06-汉诺塔问题" class="headerlink" title="面试题 08.06. 汉诺塔问题"></a>面试题 08.06. 汉诺塔问题</h2><h3 id="题目-45"><a href="#题目-45" class="headerlink" title="题目"></a>题目</h3><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>
<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>
<p>你需要原地修改栈。</p>
<h3 id="笔记-45"><a href="#笔记-45" class="headerlink" title="笔记"></a>笔记</h3><p>比较经典的问题，讲解可以看 <a href="https://leetcode-cn.com/problems/hanota-lcci/solution/tu-jie-yi-nuo-ta-de-gu-shi-ju-shuo-dang-64ge-pan-z/" target="_blank" rel="noopener">这里</a></p>
<p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        move(A.size(), A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            C.add(A.remove(A.size()-<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        move(n-<span class="number">1</span>, A, C, B);</span><br><span class="line">        C.add(A.remove(A.size()-<span class="number">1</span>));</span><br><span class="line">        move(n-<span class="number">1</span>, B, A, C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实可以让代码更简洁一点，但是考虑到易读性不一定有必要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        move(A.size(), A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        move(n-<span class="number">1</span>, A, C, B);</span><br><span class="line">        C.add(A.remove(A.size()-<span class="number">1</span>));</span><br><span class="line">        move(n-<span class="number">1</span>, B, A, C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-08-07-无重复字符串的排列组合"><a href="#面试题-08-07-无重复字符串的排列组合" class="headerlink" title="面试题 08.07. 无重复字符串的排列组合"></a>面试题 08.07. 无重复字符串的排列组合</h2><h3 id="题目-46"><a href="#题目-46" class="headerlink" title="题目"></a>题目</h3><p>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。</p>
<h3 id="笔记-46"><a href="#笔记-46" class="headerlink" title="笔记"></a>笔记</h3><p>回溯问题。</p>
<h2 id="面试题-08-08-有重复字符串的排列组合"><a href="#面试题-08-08-有重复字符串的排列组合" class="headerlink" title="面试题 08.08. 有重复字符串的排列组合"></a>面试题 08.08. 有重复字符串的排列组合</h2><h3 id="题目-47"><a href="#题目-47" class="headerlink" title="题目"></a>题目</h3><p>有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p>
<h3 id="笔记-47"><a href="#笔记-47" class="headerlink" title="笔记"></a>笔记</h3><p>典型的 回溯+去重 问题。</p>
<p>可以看看写的一篇总结文章<a href="https://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/">一种处理回溯问题的通用方法</a> 。</p>
<h2 id="面试题-08-09-括号"><a href="#面试题-08-09-括号" class="headerlink" title="面试题 08.09. 括号"></a>面试题 08.09. 括号</h2><h3 id="题目-48"><a href="#题目-48" class="headerlink" title="题目"></a>题目</h3><p>括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。</p>
<p>说明：解集不能包含重复的子集。</p>
<h3 id="笔记-48"><a href="#笔记-48" class="headerlink" title="笔记"></a>笔记</h3><p>回溯问题。</p>
<h2 id="面试题-08-10-颜色填充"><a href="#面试题-08-10-颜色填充" class="headerlink" title="面试题 08.10. 颜色填充"></a>面试题 08.10. 颜色填充</h2><h3 id="题目-49"><a href="#题目-49" class="headerlink" title="题目"></a>题目</h3><p>编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。</p>
<p>待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的横坐标为 sr 纵坐标为 sc。需要填充的新颜色为 newColor 。</p>
<p>「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。</p>
<p>请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。</p>
<h3 id="笔记-49"><a href="#笔记-49" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>DFS，这里不需要开辟visited数组，另外要注意oldColor == newColor的情况。</li>
<li>BFS，同样要注意oldColor == newColor的情况。</li>
</ol>
<p>DFS相应代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line">        dfs(image, sr, sc, image[sr][sc], newColor);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> oldColor, <span class="keyword">int</span> newColor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == image.length || y == image[<span class="number">0</span>].length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(image[x][y] != oldColor) <span class="keyword">return</span>;</span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            dfs(image, x+dir[<span class="number">0</span>], y+dir[<span class="number">1</span>], oldColor, newColor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFS相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line">        <span class="keyword">int</span> oldColor = image[sr][sc];</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] point = q.poll();</span><br><span class="line">            image[point[<span class="number">0</span>]][point[<span class="number">1</span>]] = newColor;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = point[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = point[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == image.length || y == image[<span class="number">0</span>].length) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(image[x][y] != oldColor) <span class="keyword">continue</span>;</span><br><span class="line">                q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a>面试题 08.11. 硬币</h2><h3 id="题目-50"><a href="#题目-50" class="headerlink" title="题目"></a>题目</h3><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<h3 id="笔记-50"><a href="#笔记-50" class="headerlink" title="笔记"></a>笔记</h3><p>典型的背包问题。</p>
<p>相关代码如下，注意内循环和外循环的顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = coin;i &lt;= n;i++)&#123;</span><br><span class="line">                dp[i] += dp[i-coin];</span><br><span class="line">                dp[i] %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-08-12-八皇后"><a href="#面试题-08-12-八皇后" class="headerlink" title="面试题 08.12. 八皇后"></a>面试题 08.12. 八皇后</h2><h3 id="题目-51"><a href="#题目-51" class="headerlink" title="题目"></a>题目</h3><p>设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。</p>
<h3 id="笔记-51"><a href="#笔记-51" class="headerlink" title="笔记"></a>笔记</h3><p>N皇后问题，backtrack解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] cols, diag1, diag2;  <span class="comment">// 用于判断某位置的列以及两条对角线是否冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        cols = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        diag1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n];</span><br><span class="line">        diag2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n];</span><br><span class="line">        backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; tempList, <span class="keyword">int</span> n, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;  <span class="comment">// 终止条件</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id1 = row - j + n, id2 = row + j;</span><br><span class="line">            <span class="keyword">if</span> (cols[j] || diag1[id1] || diag2[id2]) <span class="keyword">continue</span>;  <span class="comment">// 此位置有冲突，跳过</span></span><br><span class="line">            cols[j] = <span class="keyword">true</span>;</span><br><span class="line">            diag1[id1] = <span class="keyword">true</span>;</span><br><span class="line">            diag2[id2] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">            Arrays.fill(chars, <span class="string">'.'</span>);</span><br><span class="line">            chars[j] = <span class="string">'Q'</span>;</span><br><span class="line">            tempList.add(<span class="keyword">new</span> String(chars));</span><br><span class="line"></span><br><span class="line">            backtrack(res, tempList, n, row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            cols[j] = <span class="keyword">false</span>;</span><br><span class="line">            diag1[id1] = <span class="keyword">false</span>;</span><br><span class="line">            diag2[id2] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-08-13-堆箱子"><a href="#面试题-08-13-堆箱子" class="headerlink" title="面试题 08.13. 堆箱子"></a>面试题 08.13. 堆箱子</h2><h3 id="题目-52"><a href="#题目-52" class="headerlink" title="题目"></a>题目</h3><p>堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。</p>
<p>输入使用数组[wi, di, hi]表示每个箱子。</p>
<h3 id="笔记-52"><a href="#笔记-52" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>第一点需要明白的是，我们先对box数组按照一个维度进行排序，得到sorted_box序列，那么最终答案的序列就一定是sorted_box序列的某个子序列（这点很重要）。那么之后我们只需要找到这个总高度最大的子序列。</li>
<li>设dp[i]表示以第i个箱子为结尾的上升子序列的最大总高度，dp[i] = box[i][2] + max(…,dp[k], dp[j],dp[l]…,0)，其中0&lt;= k,j,l &lt;= i-1且box[k,j,l][m] &lt; box[i][m],m=0,1,2。</li>
</ol>
<p>相应代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pileBox</span><span class="params">(<span class="keyword">int</span>[][] box)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = box.length;</span><br><span class="line">        Arrays.sort(box, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = box[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (larger(box, i, j)) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + box[i][<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">larger</span><span class="params">(<span class="keyword">int</span>[][] box, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> box[i][<span class="number">0</span>] &gt; box[j][<span class="number">0</span>] &amp;&amp; box[i][<span class="number">1</span>] &gt; box[j][<span class="number">1</span>] &amp;&amp; box[i][<span class="number">2</span>] &gt; box[j][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-08-14-布尔运算"><a href="#面试题-08-14-布尔运算" class="headerlink" title="面试题 08.14. 布尔运算"></a>面试题 08.14. 布尔运算</h2><h3 id="题目-53"><a href="#题目-53" class="headerlink" title="题目"></a>题目</h3><p>给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、&amp; (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。</p>
<h3 id="笔记-53"><a href="#笔记-53" class="headerlink" title="笔记"></a>笔记</h3><p>按运算符划分为子问题，例如s = “1^0|0|1” 可以分为：</p>
<p>1  ^  0|0|1<br>1^0  |  0|1<br>1^0|0  |  1</p>
<p>三个子问题，同时对子问题递归求解。还要将已经算出的子问题的结果存储起来，可以使用map 也可以利用数组。当前解由左右两部分和中间的运算符计算得出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countEval</span><span class="params">(String s, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.equals(String.valueOf(result)))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'1'</span> || s.charAt(i) == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            String left = s.substring(<span class="number">0</span>, i);</span><br><span class="line">            String right = s.substring(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (map.get(left + <span class="string">"0"</span>) == <span class="keyword">null</span>)</span><br><span class="line">                map.put(left + <span class="string">"0"</span>, countEval(left, <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span> (map.get(left + <span class="string">"1"</span>) == <span class="keyword">null</span>)</span><br><span class="line">                map.put(left + <span class="string">"1"</span>, countEval(left, <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (map.get(right + <span class="string">"0"</span>) == <span class="keyword">null</span>)</span><br><span class="line">                map.put(right + <span class="string">"0"</span>, countEval(right, <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span> (map.get(right + <span class="string">"1"</span>) == <span class="keyword">null</span>)</span><br><span class="line">                map.put(right + <span class="string">"1"</span>, countEval(right, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left_0 = map.get(left + <span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">int</span> left_1 = map.get(left + <span class="string">"1"</span>);</span><br><span class="line">            <span class="keyword">int</span> right_0 = map.get(right + <span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">int</span> right_1 = map.get(right + <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'&amp;'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                    res += (left_0 * right_0 + left_0 * right_1 + left_1 * right_0);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += (left_1 * right_1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'|'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                    res += (left_0 * right_0);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += (left_1 * right_1 + left_0 * right_1 + left_1 * right_0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">                    res += (left_1 * right_1 + left_0 * right_0);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += (left_0 * right_1 + left_1 * right_0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-10-01-合并排序的数组"><a href="#面试题-10-01-合并排序的数组" class="headerlink" title="面试题 10.01. 合并排序的数组"></a>面试题 10.01. 合并排序的数组</h2><h3 id="题目-54"><a href="#题目-54" class="headerlink" title="题目"></a>题目</h3><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 m 和 n。</p>
<h3 id="笔记-54"><a href="#笔记-54" class="headerlink" title="笔记"></a>笔记</h3><p>题目中说明了A的末端有足够的缓冲空间容纳 B，因此使用 逆向双指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx1 = m - <span class="number">1</span>, idx2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx1 &gt;= <span class="number">0</span> &amp;&amp; idx2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[idx1] &gt; B[idx2])&#123;</span><br><span class="line">                A[pos--] = A[idx1--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                A[pos--] = B[idx2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(idx2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            A[pos--] = B[idx2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-10-02-变位词组"><a href="#面试题-10-02-变位词组" class="headerlink" title="面试题 10.02. 变位词组"></a>面试题 10.02. 变位词组</h2><h3 id="题目-55"><a href="#题目-55" class="headerlink" title="题目"></a>题目</h3><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p>
<h3 id="笔记-55"><a href="#笔记-55" class="headerlink" title="笔记"></a>笔记</h3><p>hashmap键的设计。</p>
<h2 id="面试题-10-03-搜索旋转数组"><a href="#面试题-10-03-搜索旋转数组" class="headerlink" title="面试题 10.03. 搜索旋转数组"></a>面试题 10.03. 搜索旋转数组</h2><h3 id="题目-56"><a href="#题目-56" class="headerlink" title="题目"></a>题目</h3><p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p>
<h3 id="笔记-56"><a href="#笔记-56" class="headerlink" title="笔记"></a>笔记</h3><p>具体的总结可以看 <a href="https://www.yingzq.com/2020/03/16/solution-for-rotated-sorted-array/">旋转排序数组总结</a></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[lo] == target) <span class="keyword">return</span> lo;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[lo] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 左边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[lo] &amp;&amp; target &lt; nums[mid]) hi = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[lo] &gt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 右边有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]) lo = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 重复情况</span></span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-10-05-稀疏数组搜索"><a href="#面试题-10-05-稀疏数组搜索" class="headerlink" title="面试题 10.05. 稀疏数组搜索"></a>面试题 10.05. 稀疏数组搜索</h2><h3 id="题目-57"><a href="#题目-57" class="headerlink" title="题目"></a>题目</h3><p>稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: words &#x3D; [&quot;at&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;ball&quot;, &quot;&quot;, &quot;&quot;, &quot;car&quot;, &quot;&quot;, &quot;&quot;,&quot;dad&quot;, &quot;&quot;, &quot;&quot;], s &#x3D; &quot;ta&quot;</span><br><span class="line">输出：-1</span><br><span class="line">说明: 不存在返回-1。</span><br><span class="line"></span><br><span class="line">输入：words &#x3D; [&quot;at&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;ball&quot;, &quot;&quot;, &quot;&quot;, &quot;car&quot;, &quot;&quot;, &quot;&quot;,&quot;dad&quot;, &quot;&quot;, &quot;&quot;], s &#x3D; &quot;ball&quot;</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<h3 id="笔记-57"><a href="#笔记-57" class="headerlink" title="笔记"></a>笔记</h3><p>主题思想是利用二分搜索，其中不一样的地方是需要排除空字符串的情况，这里有2种情况需要排除：</p>
<ol>
<li>每次搜索前的lo和hi的位置</li>
<li>mid位置</li>
</ol>
<p>最终的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findString</span><span class="params">(String[] words, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = words.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt;= hi &amp;&amp; words[lo].length() == <span class="number">0</span>) lo++;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt;= hi &amp;&amp; words[hi].length() == <span class="number">0</span>) hi--;</span><br><span class="line">            <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (mid &lt; hi &amp;&amp; words[mid].length() == <span class="number">0</span>) mid++;</span><br><span class="line">            <span class="keyword">int</span> result = words[mid].compareTo(s);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (result &gt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-10-09-排序矩阵查找"><a href="#面试题-10-09-排序矩阵查找" class="headerlink" title="面试题 10.09. 排序矩阵查找"></a>面试题 10.09. 排序矩阵查找</h2><h3 id="题目-58"><a href="#题目-58" class="headerlink" title="题目"></a>题目</h3><p>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p>
<h3 id="笔记-58"><a href="#笔记-58" class="headerlink" title="笔记"></a>笔记</h3><p>可以从右上角或者左下角开始查找，每次排除一行或者一列，时间复杂度为O(m+n)。</p>
<p>从右上角开始查找的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] &gt; target)&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-10-10-数字流的秩"><a href="#面试题-10-10-数字流的秩" class="headerlink" title="面试题 10.10. 数字流的秩"></a>面试题 10.10. 数字流的秩</h2><h3 id="题目-59"><a href="#题目-59" class="headerlink" title="题目"></a>题目</h3><p>假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：</p>
<ul>
<li>实现 track(int x) 方法，每读入一个数字都会调用该方法；</li>
<li>实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。</li>
</ul>
<h3 id="笔记-59"><a href="#笔记-59" class="headerlink" title="笔记"></a>笔记</h3><p>很明显应该使用BST，然后使用中序遍历，查找当前输入x所在的位置即为所求。这里为了速度更快，不做重复操作，可以改造一下BST，在BST的Node中增加一个count字段：表示该节点及其左子节点中小于等于val元素数的个数。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamRank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node left, right;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> count;  <span class="comment">// 表示该节点及其左子节点中小于等于val元素数的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        root = add(root, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(x);</span><br><span class="line">        <span class="keyword">if</span> (x == node.val) &#123;</span><br><span class="line">            node.count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; node.val) &#123;</span><br><span class="line">            node.count++;</span><br><span class="line">            node.left = add(node.left, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = add(node.right, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRankOfNumber</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(root, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(Node node, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.val == x) <span class="keyword">return</span> node.count;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; x) <span class="keyword">return</span> find(node.left, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> node.count + find(node.right, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-10-11-峰与谷"><a href="#面试题-10-11-峰与谷" class="headerlink" title="面试题 10.11. 峰与谷"></a>面试题 10.11. 峰与谷</h2><h3 id="题目-60"><a href="#题目-60" class="headerlink" title="题目"></a>题目</h3><p>在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 6, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。</p>
<h3 id="笔记-60"><a href="#笔记-60" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>排序，当一道数组题看起来没思路时，不妨先排序，针对一个sorted array看看有没有思路。</li>
<li>假设按照峰-谷-峰的顺序排列数组，那么遍历一遍数组：如果i为峰的位置，则判断当前位置是否小于前一个位置（前一个为谷），若小于，则交换，大于则不处理；如果i为谷的位置，则判断当前位置是否大于前一个位置（前一个为峰），若大于，则交换，大于则不处理。</li>
</ol>
<p>给出方法2的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 偶数位是峰</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>]) swap(nums, i, i-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 奇数位是谷</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>]) swap(nums, i, i-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-16-01-交换数字"><a href="#面试题-16-01-交换数字" class="headerlink" title="面试题 16.01. 交换数字"></a>面试题 16.01. 交换数字</h2><h3 id="题目-61"><a href="#题目-61" class="headerlink" title="题目"></a>题目</h3><p>编写一个函数，不用临时变量，直接交换numbers = [a, b]中a与b的值。</p>
<h3 id="笔记-61"><a href="#笔记-61" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>加减法</li>
</ol>
<p>我们进行如下运算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; a - b;</span><br><span class="line">b &#x3D; a + b;</span><br><span class="line">a &#x3D; b - a;</span><br></pre></td></tr></table></figure>

<p>令a0,b0是a,b最开始的值，a1,b1是a,b交换后的值，其实也就是a1=b0,b1=a0，解释一下上述操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diff &#x3D; a &#x3D; a0 - b0;</span><br><span class="line">b &#x3D; a + b &#x3D; a0 - b0 + b0 &#x3D; a0 &#x3D; b1</span><br><span class="line">a &#x3D; b - a &#x3D; a0 - (a0 - b0) &#x3D; b0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>位运算</li>
</ol>
<p>我们还可以用位操作实现类似的解法，这种解法的优点在于它适用的数 据类型更多，不仅限于整数。</p>
<p>进行如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; a ^ b;</span><br><span class="line">b &#x3D; a ^ b;</span><br><span class="line">a &#x3D; a ^ b;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-16-02-单词频率"><a href="#面试题-16-02-单词频率" class="headerlink" title="面试题 16.02. 单词频率"></a>面试题 16.02. 单词频率</h2><h3 id="题目-62"><a href="#题目-62" class="headerlink" title="题目"></a>题目</h3><p>设计一个方法，找出任意指定单词在一本书中的出现频率。</p>
<h3 id="笔记-62"><a href="#笔记-62" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>HashMap</li>
<li>字典树</li>
</ol>
<h2 id="面试题-16-03-交点"><a href="#面试题-16-03-交点" class="headerlink" title="面试题 16.03. 交点"></a>面试题 16.03. 交点</h2><h3 id="题目-63"><a href="#题目-63" class="headerlink" title="题目"></a>题目</h3><p>给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。</p>
<p>要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p>
<h3 id="笔记-63"><a href="#笔记-63" class="headerlink" title="笔记"></a>笔记</h3><ol>
<li>先求直线交点: 用ax+by+c=0的一般式, 根据两点式直线方程(y-y1)/(x-x1) = (y2-y1)/(x2-x1)，可以得到a = y2-y1，b = x1-x2，c = x2y1-x1y2</li>
<li>判断两个直线是否平行/共线</li>
<li>不是的话求二元一次方程即可得交点<br>交点是:<br>x = (c2 * b1 - c1 * b2) / (a1 * b2 - a2 * b1)<br>y = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1)</li>
<li>然后再判断交点是否在两个线段上</li>
</ol>
<h2 id="面试题-16-04-井字游戏"><a href="#面试题-16-04-井字游戏" class="headerlink" title="面试题 16.04. 井字游戏"></a>面试题 16.04. 井字游戏</h2><h3 id="题目-64"><a href="#题目-64" class="headerlink" title="题目"></a>题目</h3><p>设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符” “，”X”和”O”组成，其中字符” “代表一个空位。</p>
<p>以下是井字游戏的规则：</p>
<ul>
<li>玩家轮流将字符放入空位（” “）中。</li>
<li>第一个玩家总是放字符”O”，且第二个玩家总是放字符”X”。</li>
<li>“X”和”O”只允许放置在空位中，不允许对已放有字符的位置进行填充。</li>
<li>当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。</li>
<li>当所有位置非空时，也算为游戏结束。</li>
<li>如果游戏结束，玩家不允许再放置字符。</li>
</ul>
<p>如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（”X”或”O”）；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。</p>
<h3 id="笔记-64"><a href="#笔记-64" class="headerlink" title="笔记"></a>笔记</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tictactoe</span><span class="params">(String[] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line">        <span class="keyword">boolean</span> hasEmpty = <span class="keyword">false</span>;   <span class="comment">//有没有空位</span></span><br><span class="line">        <span class="keyword">int</span>[] rowX = <span class="keyword">new</span> <span class="keyword">int</span>[n];    <span class="comment">//每行有多少个"X"</span></span><br><span class="line">        <span class="keyword">int</span>[] colX = <span class="keyword">new</span> <span class="keyword">int</span>[n];    <span class="comment">//每列有多少个"X"</span></span><br><span class="line">        <span class="keyword">int</span>[] rowO = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] colO = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// leftX: 从左上角开始的对角线上有多少个"X"</span></span><br><span class="line">        <span class="comment">// rightX: 从右上角开始的对角线上有多少个"X"</span></span><br><span class="line">        <span class="keyword">int</span> leftX=<span class="number">0</span>, rightX=<span class="number">0</span>, leftO=<span class="number">0</span>, rightO=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = board[i].charAt(j);</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">'X'</span>)&#123;</span><br><span class="line">                    rowX[i]++;</span><br><span class="line">                    colX[j]++;</span><br><span class="line">                    <span class="keyword">if</span>(i == j)    leftX++;</span><br><span class="line">                    <span class="keyword">if</span>(i+j == n-<span class="number">1</span>)  rightX++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    rowO[i]++;</span><br><span class="line">                    colO[j]++;</span><br><span class="line">                    <span class="keyword">if</span>(i == j)    leftO++;</span><br><span class="line">                    <span class="keyword">if</span>(i+j == n-<span class="number">1</span>)  rightO++;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    hasEmpty = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftX==n || rightX==n)   <span class="keyword">return</span> <span class="string">"X"</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftO==n || rightO==n)   <span class="keyword">return</span> <span class="string">"O"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rowX[i]==n || colX[i]==n)    <span class="keyword">return</span> <span class="string">"X"</span>;</span><br><span class="line">            <span class="keyword">if</span>(rowO[i]==n || colO[i]==n)    <span class="keyword">return</span> <span class="string">"O"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasEmpty ? <span class="string">"Pending"</span> : <span class="string">"Draw"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-16-05-阶乘尾数"><a href="#面试题-16-05-阶乘尾数" class="headerlink" title="面试题 16.05. 阶乘尾数"></a>面试题 16.05. 阶乘尾数</h2><h3 id="题目-65"><a href="#题目-65" class="headerlink" title="题目"></a>题目</h3><p>设计一个算法，算出 n 阶乘有多少个尾随零。</p>
<h3 id="笔记-65"><a href="#笔记-65" class="headerlink" title="笔记"></a>笔记</h3><p>为了算出尾随零的数量，我们只需计算n的因式分解中有几对5和2倍数。不过， 2倍数始终要比5倍数多，最后只要数出5倍数就可以了。</p>
<p>这里有个陷阱是25相当于2个5，125相当于3个5…</p>
<p>相应的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n / <span class="number">5</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            count += n / <span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-16-06-最小差"><a href="#面试题-16-06-最小差" class="headerlink" title="面试题 16.06. 最小差"></a>面试题 16.06. 最小差</h2><h3 id="题目-66"><a href="#题目-66" class="headerlink" title="题目"></a>题目</h3><p>给定两个整数数组a和b，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差。</p>
<h3 id="笔记-66"><a href="#笔记-66" class="headerlink" title="笔记"></a>笔记</h3><p>排序 + 双指针，注意int相减有可能会越界，所以需要用long来保存临时结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDifference</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        Arrays.sort(b);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; a.length &amp;&amp; j &lt; b.length)&#123;</span><br><span class="line">            min = Math.min(min, Math.abs((<span class="keyword">long</span>)a[i] - b[j]));</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; b[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; b[j]) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-16-07-最大数值"><a href="#面试题-16-07-最大数值" class="headerlink" title="面试题 16.07. 最大数值"></a>面试题 16.07. 最大数值</h2><h3 id="题目-67"><a href="#题目-67" class="headerlink" title="题目"></a>题目</h3><p>编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。</p>
<h3 id="笔记-67"><a href="#笔记-67" class="headerlink" title="笔记"></a>笔记</h3><p>既然题目提到：不得使用if-else或其他比较运算符，那么我们也尽可能回避abs、max这些函数，因为其内部可能调用比较了运算符。</p>
<p>我们可以这样求最大值：<br>max(a, b) = ((a + b) + abs(a - b)) / 2</p>
<p>其中abs()函数可以利用位运算实现，具体参考 <a href="https://leetcode-cn.com/problems/maximum-lcci/solution/ji-yu-wei-yun-suan-shi-xian-da-xiao-bi-jiao-by-dex/" target="_blank" rel="noopener">位运算实现大小比较</a>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = (<span class="keyword">long</span>) a + b;</span><br><span class="line">        <span class="keyword">long</span> diff = (<span class="keyword">long</span>) a - b;</span><br><span class="line">        diff = (diff ^ (diff &gt;&gt; <span class="number">63</span>)) - (diff &gt;&gt; <span class="number">63</span>);  <span class="comment">// 求出abs(diff)</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)((sum + diff) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-08-30T13:44:51.547Z" itemprop="dateUpdated">2020-08-30 21:44:51</time>
</span><br>


        
        若有疑问或者本人有写的不对的地方, 欢迎留言或者直接邮箱反馈至yingzq0116@163.com, 非常感谢您的阅读~
        
    </div>
    
    <footer>
        <a href="https://www.yingzq.com">
            <img src="/img/avatar.jpg" alt="应子强">
            应子强
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.yingzq.com/2020/08/28/cracking-the-coding-interview-notes/&title=《《程序员面试经典》阅读笔记》 — yingzq's Blog&pic=https://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.yingzq.com/2020/08/28/cracking-the-coding-interview-notes/&title=《《程序员面试经典》阅读笔记》 — yingzq's Blog&source=LeetCode中文版上线了 程序员面试经典（第6版） 的相关算法题，本人在以前的空余时间做了前 70 题（一共 109 题），在这里对于已经做过的题简单..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.yingzq.com/2020/08/28/cracking-the-coding-interview-notes/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《《程序员面试经典》阅读笔记》 — yingzq's Blog&url=https://www.yingzq.com/2020/08/28/cracking-the-coding-interview-notes/&via=https://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.yingzq.com/2020/08/28/cracking-the-coding-interview-notes/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/03/28/dynamic-programming-patterns/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">论动态规划常见的5种模式</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "mGqkrgTscxf4JdcqkEHkFCfs-gzGzoHsz",
            appKey: "PwU9oOfhNnWOKaMaOTqQpiNW",
            avatar: "mm",
            placeholder: "要不要说点什么？",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>应子强 &copy; 2019 - 2020</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">京ICP备19041830号</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.yingzq.com/2020/08/28/cracking-the-coding-interview-notes/&title=《《程序员面试经典》阅读笔记》 — yingzq's Blog&pic=https://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.yingzq.com/2020/08/28/cracking-the-coding-interview-notes/&title=《《程序员面试经典》阅读笔记》 — yingzq's Blog&source=LeetCode中文版上线了 程序员面试经典（第6版） 的相关算法题，本人在以前的空余时间做了前 70 题（一共 109 题），在这里对于已经做过的题简单..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.yingzq.com/2020/08/28/cracking-the-coding-interview-notes/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《《程序员面试经典》阅读笔记》 — yingzq's Blog&url=https://www.yingzq.com/2020/08/28/cracking-the-coding-interview-notes/&via=https://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.yingzq.com/2020/08/28/cracking-the-coding-interview-notes/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACyElEQVR42u3aS3IbMQwFQN3/0s4BbI3eA8HEqepZqaT5sGdBQABer/j4enN8Pye/w/erkl9fNw48PDy8paW/e/Dzr+/Az+ckS0/W88N98PDw8K7xkts9b98JoH1xyXo+WPDw8PB+AW+WZH/Fx3NWjIeHh/e/805KG3nq/M8CAx4eHt4jL0l82yJCm3bnhYwrtRY8PDy8LmsttvLf8PlKfw8PDw/vuKueN/vz1DkPJ20w+OEqPDw8vAu8fMOdPTJJiPPBgnadeHh4eDd4W0tphwzaQDJsg+Hh4eFd4+Vl1rbUO6sSzNpdHzp7eHh4eEu8tr3Uprn5QFV7fnEVHh4e3ipvtpXPUt6kpJu8grXZLjw8PLwDXh4S2juclyTyF/qhv4eHh4e3xMs337xoO9uZ2xZXHTzw8PDwlnj51r9VLEiW2JY/PhQj8PDw8FZ5JyNQs2Gp5No2DEQRDw8PD2+Jlze68g199pST9by9Jx4eHt4F3mzDzQsQz0XYkxR8VsjAw8PD2+XNWvv5SEE+XtA2wKIEHQ8PD2+Jl6ekeUJ8MlJwEmB+uCceHh7eBV57ap7a5qNabYGjfdF4eHh4u7yiS3Yyz1Um00XtJBm6wsPDw7vGa8sNCSxfYp5AFyvEw8PDu8bLkXkLvy3dtuyo1IuHh4d3gZc3lk5S8N1m2LA0jIeHh7fKK8Y9l9LuthnWvsS6Go2Hh4c34m1tx8n3SercJtBvn4WHh4d3jdcOVJ2UX1v26+TAw8PDW+V9lUfeXZq1rPJycDSMhYeHh3eBd/KH/7x5ln+/W1zGw8PDO+clwaAdz5qFnLwlVgxm4eHh4V3jJZ2jPHk9SnBHQav+GQ8PD+8v8qK206i5tbUePDw8vN/Ja8sN+WvKBxSiwIOHh4d3jdc2n/LNvR2oysezovQdDw8P7wKv/cM/27Jny8oDzFo9Aw8PD+/p+ANLaLtgl/DedAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来练习bug!';
            clearTimeout(titleTime);
        } else {
            document.title = 'yingzq's Blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
