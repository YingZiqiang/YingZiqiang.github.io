<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Git的杀手锏：分支模型（下） | yingzq&#39;s Blog | 练习bug时长两年半的实习生</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Git">
    <meta name="description" content="在 Git的杀手锏：分支模型（上）中，我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作。在本章我们继续来学习Git分支的工作流、远程分支和变基等内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="Git的杀手锏：分支模型（下）">
<meta property="og:url" content="http://www.yingzq.com/2019/10/16/git-branching-part-two/index.html">
<meta property="og:site_name" content="yingzq&#39;s Blog">
<meta property="og:description" content="在 Git的杀手锏：分支模型（上）中，我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作。在本章我们继续来学习Git分支的工作流、远程分支和变基等内容。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://image.yingzq.com/img/20191021224943.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191021225228.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191021232901.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191021233532.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022002503.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022142139.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022142624.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022143333.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022143611.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022154849.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022155124.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022161447.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022161720.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022162427.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022164831.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022165050.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022170242.png">
<meta property="og:image" content="http://image.yingzq.com/img/20191022170702.png">
<meta property="article:published_time" content="2019-10-16T05:12:25.000Z">
<meta property="article:modified_time" content="2019-10-22T15:50:39.871Z">
<meta property="article:author" content="应子强">
<meta property="article:tag" content="Git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://image.yingzq.com/img/20191021224943.png">
    
        <link rel="alternate" type="application/atom+xml" title="yingzq&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/avatar.jpg">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">应子强</h5>
          <a href="mailto:yingzq0116@163.com" title="yingzq0116@163.com" class="mail">yingzq0116@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签云
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-info-circle"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/YingZiqiang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Git的杀手锏：分支模型（下）</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Git的杀手锏：分支模型（下）</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-10-16T05:12:25.000Z" itemprop="datePublished" class="page-time">
  2019-10-16
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Git分支开发工作流"><span class="post-toc-number">1.</span> <span class="post-toc-text">Git分支开发工作流</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#长期分支"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">长期分支</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#特性分支"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">特性分支</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Git远程分支"><span class="post-toc-number">2.</span> <span class="post-toc-text">Git远程分支</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#推送"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">推送</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#跟踪分支"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">跟踪分支</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#拉取"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">拉取</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#删除远程分支"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">删除远程分支</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#变基"><span class="post-toc-number">3.</span> <span class="post-toc-text">变基</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#变基的基本操作"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">变基的基本操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#更有趣的变基例子"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">更有趣的变基例子</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#变基的风险"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">变基的风险</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#变基-vs-合并"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">变基 vs. 合并</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-number">4.</span> <span class="post-toc-text">总结</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考文献"><span class="post-toc-number">5.</span> <span class="post-toc-text">参考文献</span></a></li></ol>
        </nav>
    </aside>


<article id="post-git-branching-part-two"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Git的杀手锏：分支模型（下）</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-10-16 13:12:25" datetime="2019-10-16T05:12:25.000Z"  itemprop="datePublished">2019-10-16</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>在 <a href="/2019/10/13/git-branching/" title="Git的杀手锏：分支模型（上）">Git的杀手锏：分支模型（上）</a>中，我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作。在本章我们继续来学习Git分支的工作流、远程分支和变基等内容。</p>
<a id="more"></a>

<h2 id="Git分支开发工作流"><a href="#Git分支开发工作流" class="headerlink" title="Git分支开发工作流"></a>Git分支开发工作流</h2><p>现在我们已经学会新建和合并分支，那么可以或者应该用它来做些什么呢？本节会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出这些典型的工作模式。</p>
<h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>因为Git使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p>
<p>许多使用Git的开发者都喜欢使用这种方式来工作，比如只在<code>master</code>分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。他们还有一些名为<code>develop</code>或者<code>next</code>的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入<code>master</code>分支了。这样，在确保这些已完成的特性分支（短期分支，比如之前的<code>iss53</code>分支）能够通过所有测试，并且不会引入更多bug之后，就可以合并入主干分支中，等待下一次的发布。</p>
<p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191021224943.png" width="800" alt="渐进稳定分支的线性图" />

<p>图1：渐进稳定分支的线性图</p>
</div>

<p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191021225228.png" width="800" alt="渐进稳定分支的流水线视图" />

<p>图2：渐进稳定分支的流水线视图</p>
</div>

<p>你可以用这种方法维护不同层次的稳定性。一些大型项目还有一个<code>proposed</code>（建议）或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入<code>next</code>或者<code>master</code>分支。这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。<strong>再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</strong></p>
<h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p>特性分支对任何规模的项目都适用。特性分支是一种短期分支，它被用来实现单一特性或其相关工作。也许你从来没有在其他的版本控制系统上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。然而，在Git中一天之内多次创建、使用、合并、删除分支都很常见。</p>
<p>你已经在前文中创建的<code>iss53</code>和<code>hotfix</code>特性分支中看到过这种用法。你在特性分支（<code>iss53</code>和<code>hotfix</code>分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。<strong>这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。</strong> 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p>
<p>考虑这样一个例子，你在<code>master</code>分支上工作到<code>C1</code>，这时为了解决一个问题而新建<code>iss91</code>分支，在<code>iss91</code>分支上工作到<code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个<code>iss91v2</code>分支试图用另一种方法解决那个问题，接着你回到<code>master</code>分支工作了一会儿，你又冒出了一个不太确定的想法，你便在<code>C10</code>的时候新建一个<code>dumbidea</code>分支，并在上面做些实验。你的提交历史看起来像下面这个样子：</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191021232901.png" width="800" alt="拥有多个特性分支的提交历史" />

<p>图3：拥有多个特性分支的提交历史</p>
</div>

<p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在<code>iss91v2</code>分支中方案；另外，你将<code>dumbidea</code>分支拿给你的同事看过之后，结果发现这是个惊人之举。这时你可以抛弃<code>iss91</code>分支（即丢弃<code>C5</code>和<code>C6</code>提交），然后把另外两个分支合并入主干分支。最终你的提交历史看起来像下面这个样子：</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191021233532.png" width="800" alt="合并了dumbidea和iss91v2分支之后的提交历史" />

<p>图4：合并了dumbidea和iss91v2分支之后的提交历史</p>
</div>

<blockquote>
<p>更多有关分支工作流的细节可以参考 <a href="https://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows#ch05-distributed-git" target="_blank" rel="noopener">Distributed Workflows</a></p>
</blockquote>
<p>最后请牢记，当你做这么多操作的时候，这些分支全部都存于本地。当你新建和合并分支的时候，所有这一切都只发生在你本地的Git版本库中，没有与服务器发生交互。</p>
<h2 id="Git远程分支"><a href="#Git远程分支" class="headerlink" title="Git远程分支"></a>Git远程分支</h2><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。你可以通过<code>git ls-remote [remote]</code>来显式地获得远程引用的完整列表，或者通过<code>git remote show [remote]</code>获得远程分支的更多信息。然而，一个更常见的做法是利用远程跟踪分支。</p>
<p>远程跟踪分支是远程分支状态的引用。它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p>
<p>它们以<code>&lt;remote&gt;/&lt;branch&gt;</code>形式命名。例如，如果你想要看你最后一次与远程仓库<code>origin</code>通信时<code>master</code>分支的状态，你可以查看<code>origin/master</code>分支。你与同事合作解决一个问题并且他们推送了一个<code>iss53</code>分支，你可能有自己的本地<code>iss53</code>分支；但是在服务器上的分支会指向<code>origin/iss53</code>的提交。</p>
<p>这可能有一点儿难以理解，让我们来看一个例子。假设你的网络里有一个在<code>git.ourcompany.com</code>的Git服务器。如果你从这里克隆，Git的<code>clone</code>命令会为你自动将其命名为<code>origin</code>，拉取它的所有数据，创建一个指向它的<code>master</code>分支的指针，并且在本地将其命名为<code>origin/master</code>。Git也会给你一个与<code>origin</code>的<code>master</code>分支在指向同一个地方的本地<code>master</code>分支，这样你就有工作的基础。</p>
<blockquote>
<p><strong>注意：“origin” 并无特殊含义</strong><br>远程仓库名字 “origin” 与分支名字 “master” 一样，在Git中并没有任何特别的含义一样。同时 “master” 是当你运行<code>git init</code>时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行<code>git clone</code>时默认的远程仓库名字。如果你运行<code>git clone -o booyah</code>，那么你默认的远程分支名字将会是<code>booyah/master</code>。</p>
</blockquote>
<div align=center>
<img src="http://image.yingzq.com/img/20191022002503.png" width="750" alt="克隆之后的服务器与本地仓库" />

<p>图5：克隆之后的服务器与本地仓库</p>
</div>

<p>如果你在本地的<code>master</code>分支做了一些工作，与此同时，其他人推送提交到<code>git.ourcompany.com</code>并更新了它的<code>master</code>分支，那么你的提交历史将向不同的方向前进。另外，只要你不与<code>origin</code>服务器连接，你的<code>origin/master</code>指针就不会移动。</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191022142139.png" width="750" alt="本地与远程的工作可以分叉" />

<p>图6：本地与远程的工作可以分叉</p>
</div>

<p>如果要同步你的工作，运行<code>git fetch &lt;remote&gt;</code>命令（在本例中是<code>git fetch origin</code>）。这个命令查找 “origin” 是哪一个服务器（在本例中是<code>git.ourcompany.com</code>），从中抓取本地没有的数据，并且更新本地数据库，移动<code>origin/master</code>指针指向更新后的位置。</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191022142624.png" width="750" alt="git fetch更新远程仓库引用" />

<p>图7：git fetch更新远程仓库引用</p>
</div>

<p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部Git服务器，仅用于你小组的开发工作。这个服务器位于<code>git.team1.ourcompany.com</code>。你可以运行<code>git remote add</code>命令添加一个新的远程仓库引用到当前的项目。将这个远程仓库命名为<code>teamone</code>，将其作为整个URL的缩写。</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191022143333.png" width="750" alt="添加另一个远程仓库" />

<p>图8：添加另一个远程仓库</p>
</div>

<p>现在，可以运行<code>git fetch teamone</code>来抓取远程仓库<code>teamone</code>有而本地没有的数据。因为那台服务器上现有的数据是<code>origin</code>服务器上的一个子集，所以Git并不会抓取数据而是会设置远程跟踪分支<code>teamone/master</code>指向<code>teamone</code>的<code>master</code>分支。</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191022143611.png" width="750" alt="远程跟踪分支teamone/master" />

<p>图9：远程跟踪分支teamone/master</p>
</div>

<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p>
<p>如果希望和别人一起在名为<code>serverfix</code>的分支上工作，你可以像推送第一个分支那样推送它。运行<code>git push &lt;remote&gt; &lt;branch&gt;</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 24, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15&#x2F;15), done.</span><br><span class="line">Writing objects: 100% (24&#x2F;24), 1.91 KiB | 0 bytes&#x2F;s, done.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure>

<p>这里有些工作被简化了。Git自动将<code>serverfix</code>分支名字展开为<code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的<code>serverfix</code>分支来更新远程仓库上的<code>serverfix</code>分支。” 你也可以运行<code>git push origin serverfix:serverfix</code>，它会做同样的事——也就是说 “推送本地的<code>serverfix</code>分支，将其作为远程仓库的<code>serverfix</code>分支”。你也可以通过这种格式来推送本地分支到一个命名不相同的远程分支，例如你并不想让远程仓库上的分支叫做<code>serverfix</code>，可以运行<code>git push origin serverfix:awesomebranch</code>来将本地的<code>serverfix</code>分支推送到远程仓库上的<code>awesomebranch</code>分支。</p>
<p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支<code>origin/serverfix</code>，指向服务器的<code>serverfix</code>分支的引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">remote: Counting objects: 7, done.</span><br><span class="line">remote: Compressing objects: 100% (2&#x2F;2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3&#x2F;3), done.</span><br><span class="line">From https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin&#x2F;serverfix</span><br></pre></td></tr></table></figure>

<p><strong>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本。换句话说，这种情况下，不会有一个新的<code>serverfix</code>分支，只有一个不可以修改的<code>origin/serverfix</code>指针。</strong></p>
<p>可以运行<code>git merge origin/serverfix</code>将这些工作合并到当前所在的分支。如果想要在自己的<code>serverfix</code>分支上工作，可以将其建立在远程跟踪分支之上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b serverfix origin&#x2F;serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#39;serverfix&#39;</span><br></pre></td></tr></table></figure>

<p>这会给你一个用于工作的本地分支，并且起点位于<code>origin/serverfix</code>。</p>
<h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。跟踪分支是与远程分支有直接关系的本地分支。如果在一个跟踪分支上输入<code>git pull</code>，Git能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪<code>origin/master</code>的<code>master</code>分支。然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪<code>master</code>分支。最简单的实例就是像之前看到的那样，运行<code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>。这是一个十分常用的操作所以Git提供了<code>--track</code>快捷方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout --track origin&#x2F;serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#39;serverfix&#39;</span><br></pre></td></tr></table></figure>

<p>事实上，这个命令实在是太常用了，所以有一个快捷方式中的快捷方式。如果您试图检出的分支满足(a)名称不存在(b)有且仅有一个远程分支名称和它完全匹配，Git将为您创建跟踪分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#39;serverfix&#39;</span><br></pre></td></tr></table></figure>

<p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地使用原始版本的命令增加一个不同名字的本地分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b sf origin&#x2F;serverfix</span><br><span class="line">Branch sf set up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch &#39;sf&#39;</span><br></pre></td></tr></table></figure>

<p>现在，本地分支<code>sf</code>会自动从<code>origin/serverfix</code>拉取。</p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用<code>-u</code>或<code>--set-upstream-to</code>选项运行<code>git branch</code>来显式地设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -u origin&#x2F;serverfix</span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：上游快捷方式</strong><br>当设置好跟踪分支后，可以通过<code>@{upstream}</code>或<code>@{u}</code>快捷方式来引用它。所以在<code>master</code>分支时并且它正在跟踪<code>origin/master</code>时，如果愿意的话可以使用<code>git merge @{u}</code>来取代<code>git merge origin/master</code>。</p>
</blockquote>
<p>如果想要查看设置的所有跟踪分支，可以使用<code>git branch</code>的<code>-vv</code>选项。这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">  iss53     7e424c3 [origin&#x2F;iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin&#x2F;master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone&#x2F;server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure>

<p>这里可以看到<code>iss53</code>分支正在跟踪<code>origin/iss53</code>并且 “ahead” 是2，意味着本地有两个提交还没有推送到服务器上。也能看到<code>master</code>分支正在跟踪<code>origin/master</code>分支并且是最新的。接下来可以看到<code>serverfix</code>分支正在跟踪<code>teamone</code>服务器上的<code>server-fix-good</code>分支并且领先3落后1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。最后看到<code>testing</code>分支并没有跟踪任何远程分支。</p>
<p><strong>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。</strong>如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。可以像这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch --all; git branch -vv</span><br></pre></td></tr></table></figure>

<h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>当<code>git fetch</code>命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。它只会获取数据然后让你自己合并。然而，有一个命令叫作<code>git pull</code>在大多数情况下它的含义是一个<code>git fetch</code>紧接着一个<code>git merge</code>命令。如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过<code>clone</code>或<code>checkout</code>命令为你创建的，<code>git pull</code>都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p>
<p>由于<code>git pull</code>的魔法经常令人困惑所以通常单独显式地使用<code>fetch</code>与<code>merge</code>命令会更好一些。</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>假设你已经通过远程分支做完所有的工作了，也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的<code>master</code>分支（或任何其他稳定代码分支）。可以运行带有<code>--delete</code>选项的<code>git push</code>命令来删除一个远程分支。例如想要从服务器上删除<code>serverfix</code>分支，运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure>

<p>基本上这个命令做的只是从服务器上移除这个指针。Git服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在Git中整合来自不同分支的修改主要有两种方法：<code>merge</code>以及<code>rebase</code>。在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p>
<h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h3><p>考虑之前遇到的情况，开发任务分叉到了两个不同分支，又各自提交了更新。</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191022154849.png" width="750" alt="分叉的提交历史" />

<p>图10：分叉的提交历史</p>
</div>

<p>之前介绍过，整合分支最容易的方法是<code>merge</code>命令。它会把两个分支的最新快照（<code>C3</code>和<code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交），如下图所示：</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191022155124.png" width="750" alt="通过合并操作来整合分叉了的历史" />

<p>图11：通过合并操作来整合分叉了的历史</p>
</div>

<p>其实，还有一种方法：你可以提取在<code>C4</code>中引入的补丁和修改，然后在<code>C3</code>的基础上应用一次。在Git中，这种操作就叫做 <strong>变基</strong>。 你可以使用<code>rebase</code>命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>
<p>在上面这个例子中，运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure>

<p>它的原理是首先找到这两个分支（即当前分支<code>experiment</code>、变基操作的目标基底分支<code>master</code>）的最近共同祖先<code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底<code>C3</code>，最后以此将之前另存为临时文件的修改依序应用。</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191022161447.png" width="750" alt="将C4中的修改变基到C3上" />

<p>图12：将C4中的修改变基到C3上</p>
</div>

<p>现在回到<code>master</code>分支，进行一次快进合并。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge experiment</span><br></pre></td></tr></table></figure>

<div align=center>
<img src="http://image.yingzq.com/img/20191022161720.png" width="750" alt="master分支的快进合并" />

<p>图13：master分支的快进合并</p>
</div>

<p>此时，<code>C4&#39;</code>指向的快照就和上面使用<code>merge</code>命令的例子中<code>C5</code>指向的快照一模一样了。这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p>
<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁，例如向某个其他人维护的项目贡献代码时。在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到<code>origin/master</code>上，然后再向主项目提交修改。这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>
<p><strong>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</strong></p>
<h3 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。</p>
<p>就像下图的例子：</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191022162427.png" width="800" alt="从一个特性分支里再分出一个特性分支的提交历史" />

<p>图14：从一个特性分支里再分出一个特性分支的提交历史</p>
</div>

<p>你创建了一个特性分支<code>server</code>，为服务端添加了一些功能，提交了<code>C3</code>和<code>C4</code>。然后从<code>C3</code>上创建了特性分支<code>client</code>，为客户端添加了一些功能，提交了<code>C8</code>和<code>C9</code>。最后，你回到<code>server</code>分支，又提交了<code>C10</code>。</p>
<p>假设你希望将<code>client</code>中的修改合并到主分支并发布，但暂时并不想合并<code>server</code>中的修改，因为它们还需要经过更全面的测试。这时，你就可以使用<code>git rebase</code>命令的<code>--onto</code>选项，选中在<code>client</code>分支里但不在<code>server</code>分支里的修改（即<code>C8</code>和<code>C9</code>），将它们在<code>master</code>分支上重放：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rebase --onto master server client</span><br></pre></td></tr></table></figure>

<p>以上命令的意思是：“取出<code>client</code>分支，找出处于<code>client</code>分支和<code>server</code>分支的共同祖先之后的修改，然后把它们在<code>master</code>分支上重放一遍”。这理解起来有一点复杂，不过效果非常酷。</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191022164831.png" width="800" alt="截取特性分支上的另一个特性分支，然后变基到其他分支" />

<p>图15：截取特性分支上的另一个特性分支，然后变基到其他分支</p>
</div>

<p>现在可以快进合并<code>master</code>分支了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge client</span><br></pre></td></tr></table></figure>

<div align=center>
<img src="http://image.yingzq.com/img/20191022165050.png" width="800" alt="快进合并master分支，使之包含来自client分支的修改" />

<p>图16：快进合并master分支，使之包含来自client分支的修改</p>
</div>

<p>接下来你决定将<code>server</code>分支中的修改也整合进来。使用<code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code>命令可以直接将特性分支（即本例中的<code>server</code>）变基到目标分支（即<code>master</code>）上。这样做能省去你先切换到<code>server</code>分支，再对其执行变基命令的多个步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rebase master server</span><br></pre></td></tr></table></figure>

<p>这样，<code>server</code>中的代码便被“续”到了<code>master</code>后面，如下图所示：</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191022170242.png" width="800" alt="将server中的修改变基到master上" />

<p>图17：将server中的修改变基到master上</p>
</div>

<p>然后就可以快进合并主分支<code>master</code>了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge server</span><br></pre></td></tr></table></figure>

<p>至此，<code>client</code>和<code>server</code>分支中的修改都已经整合到主分支里了，你可以删除这两个分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d client</span><br><span class="line">$ git branch -d server</span><br></pre></td></tr></table></figure>

<p>最终提交历史会变成下图中的样子：</p>
<div align=center>
<img src="http://image.yingzq.com/img/20191022170702.png" width="800" alt="最终的提交历史" />

<p>图18：最终的提交历史</p>
</div>

<h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p>奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p>
<p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p>
<p><strong>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。</strong>如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用<code>git rebase</code>命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>
<h3 id="变基-vs-合并"><a href="#变基-vs-合并" class="headerlink" title="变基 vs. 合并"></a>变基 vs. 合并</h3><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p>
<p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。它是针对历史的文档，本身就有价值，不能乱改。从这个角度看来，改变提交历史是一种亵渎，你使用 <strong>谎言</strong> 掩盖了实际发生过的事情。如果由合并产生的提交历史是一团糟怎么办？既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p>
<p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。持这一观点的人会使用<code>rebase</code>及<code>filter-branch</code>等工具来编写故事，怎么方便后来的读者就怎么写。</p>
<p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。Git是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p>
<p><strong>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们已经讲完了Git分支与合并的基础知识。你现在应该能自如地创建并切换至新分支、在不同分支之间切换以及合并本地分支。你现在应该也能通过推送你的分支至共享服务以分享它们、使用共享分支与他人协作以及在共享之前使用变基操作合并你的分支。同时通过这些例子，我们也能真真切切的感受到Git分支模型的强大，说分支模型是Git的杀手锏一点也不为过！</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git Book</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-10-22T15:50:39.871Z" itemprop="dateUpdated">2019-10-22 23:50:39</time>
</span><br>


        
        若有疑问或者本人有写的不对的地方, 欢迎留言反馈, 非常感谢您的阅读~
        
    </div>
    
    <footer>
        <a href="http://www.yingzq.com">
            <img src="/img/avatar.jpg" alt="应子强">
            应子强
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.yingzq.com/2019/10/16/git-branching-part-two/&title=《Git的杀手锏：分支模型（下）》 — yingzq's Blog&pic=http://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.yingzq.com/2019/10/16/git-branching-part-two/&title=《Git的杀手锏：分支模型（下）》 — yingzq's Blog&source=在 Git的杀手锏：分支模型（上）中，我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作。在本章我们继续来学习G..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.yingzq.com/2019/10/16/git-branching-part-two/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Git的杀手锏：分支模型（下）》 — yingzq's Blog&url=http://www.yingzq.com/2019/10/16/git-branching-part-two/&via=http://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.yingzq.com/2019/10/16/git-branching-part-two/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/10/22/greedy-algorithm/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">贪心算法</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/10/13/git-branching/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Git的杀手锏：分支模型（上）</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'true' == 'true',
            appId: "mGqkrgTscxf4JdcqkEHkFCfs-gzGzoHsz",
            appKey: "PwU9oOfhNnWOKaMaOTqQpiNW",
            avatar: "mm",
            placeholder: "要不要说点什么？",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>应子强 &copy; 2015 - 2020</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">京ICP备19041830号</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.yingzq.com/2019/10/16/git-branching-part-two/&title=《Git的杀手锏：分支模型（下）》 — yingzq's Blog&pic=http://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.yingzq.com/2019/10/16/git-branching-part-two/&title=《Git的杀手锏：分支模型（下）》 — yingzq's Blog&source=在 Git的杀手锏：分支模型（上）中，我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作。在本章我们继续来学习G..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.yingzq.com/2019/10/16/git-branching-part-two/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Git的杀手锏：分支模型（下）》 — yingzq's Blog&url=http://www.yingzq.com/2019/10/16/git-branching-part-two/&via=http://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.yingzq.com/2019/10/16/git-branching-part-two/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKUlEQVR42u3aQY6DMAwF0N7/0sx2pAr6bdMZkbysqhZCHgs3sf16xeP4Nd6/P7vy+q73X8+uv21gYGA8lnFcjskDkjlz2PWrwcDA2IFxtojrR06urM72Yc0YGBgYxaUkD64+FwMDA6M3XQ7OQy0GBgbG5BCb4POE3b+dxTEwMB7IyBfx95+/Ut/AwMB4FOMojmSGSTmzuSoMDIylGXmASzDfmK0wAwYGxjaM3lE2D5rVV5C3o2FgYKzKmOiTZNkk3VZI+WFgYGzDmB9Bq7/2Gjtek5iNgYHxcMb8+7wVtRegR90iGBgYj2XkYXfS+pDMmRQJbvj3wMDAWIiRHCDzAmQ1NOdBv1AYwMDAeDhjkuLvbQqrZcs8LYiBgbEeI9mWVZP7veNuL/33yneXGBgYD2fkITVfem/zl4djDAyMfRjVkdxcTfT3DtKFNBwGBsZCjLtCbS/4Vt/3h0ImBgbGQozqMbJ3HJ3MH82AgYGxNGNSkpy0dlXTedX2DgwMjPUYeZo+3yzm88xfEwYGxm6MScxOjsH3bhAxMDB2Y/RKiXkrRh64k8LD6dYQAwNjOcZRHJM0XB5YyzNgYGAszai2WfTSatXF9drOMDAw1mZUg2zvWNs7+hZaYDEwMDZg5G0N1cTcvPEiejUYGBgYxURbNUk3gWFgYGBUSwXVVF2y3Kg4ioGBsQEjb9KapMau5+kVDzAwMHZgVPddeYjMi6bVe2/YPmJgYDyD8QN9B+TzH+CBMQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来练习bug!';
            clearTimeout(titleTime);
        } else {
            document.title = 'yingzq's Blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
