<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>贪心算法 | yingzq&#39;s Blog | 练习bug时长两年半的实习生</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="数据结构与算法,Java,LeetCode,算法设计技巧">
    <meta name="description" content="贪心算法，又名贪婪算法，是在寻找最优解问题时的常用方法。贪心算法分阶段地工作，在每一个阶段，选取当前状态下最好或最优的的选择，而不考虑将来的后果。通常，这意味着选择的是某个局部最优。这种 “眼下能够拿到的就拿” 的策略也正是贪心算法名称的由来，就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。 当算法">
<meta property="og:type" content="article">
<meta property="og:title" content="贪心算法">
<meta property="og:url" content="https://www.yingzq.com/2019/10/22/greedy-algorithm/index.html">
<meta property="og:site_name" content="yingzq&#39;s Blog">
<meta property="og:description" content="贪心算法，又名贪婪算法，是在寻找最优解问题时的常用方法。贪心算法分阶段地工作，在每一个阶段，选取当前状态下最好或最优的的选择，而不考虑将来的后果。通常，这意味着选择的是某个局部最优。这种 “眼下能够拿到的就拿” 的策略也正是贪心算法名称的由来，就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。 当算法">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-10-22T14:04:30.000Z">
<meta property="article:modified_time" content="2020-04-24T03:25:17.474Z">
<meta property="article:author" content="应子强">
<meta property="article:tag" content="数据结构与算法">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="算法设计技巧">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="yingzq&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/avatar.jpg">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">应子强</h5>
          <a href="mailto:yingzq0116@163.com" title="yingzq0116@163.com" class="mail">yingzq0116@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签云
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-info-circle"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/YingZiqiang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">贪心算法</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">贪心算法</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-10-22T14:04:30.000Z" itemprop="datePublished" class="page-time">
  2019-10-22
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#基本思路"><span class="post-toc-number">1.</span> <span class="post-toc-text">基本思路</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#例题分析"><span class="post-toc-number">2.</span> <span class="post-toc-text">例题分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分发饼干（LeetCode455-easy）"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">分发饼干（LeetCode455 easy）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#柠檬水找零（LeetCode-860-easy）"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">柠檬水找零（LeetCode 860 easy）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#跳跃游戏（LeetCode-55-medium）"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">跳跃游戏（LeetCode 55 medium）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#跳跃游戏-II（LeetCode-45-hard）"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">跳跃游戏 II（LeetCode 45 hard）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用最少数量的箭引爆气球（LeetCode-452-medium）"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">用最少数量的箭引爆气球（LeetCode 452 medium）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考文献"><span class="post-toc-number">3.</span> <span class="post-toc-text">参考文献</span></a></li></ol>
        </nav>
    </aside>


<article id="post-greedy-algorithm"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">贪心算法</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-10-22 22:04:30" datetime="2019-10-22T14:04:30.000Z"  itemprop="datePublished">2019-10-22</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>贪心算法，又名贪婪算法，是在寻找最优解问题时的常用方法。贪心算法分阶段地工作，在每一个阶段，选取<strong>当前状态下最好或最优</strong>的的选择，而不考虑将来的后果。通常，这意味着选择的是某个<strong>局部最优</strong>。这种 “眼下能够拿到的就拿” 的策略也正是贪心算法名称的由来，就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。</p>
<p>当算法终止时，我们希望<strong>局部最优</strong>等于<strong>全局最优</strong>。如果是这样的话，那么算法就是正确的；否则，算法得到的就是一个次最优解（suboptimal solution）。如果不要求绝对最佳答案，有时候也可以使用简单的贪心算法生成近似的答案，而无需使用产生准确答案所需要的复杂算法。</p>
<blockquote>
<p>注：本文我们主要考虑第一种情况，也就是贪心算法能得到最优解的情况</p>
</blockquote>
<p>贪心算法的应用实例也非常广泛，例如最短路径中的Dijkstra算法，最小生成树中的Prim算法和Kruskal算法。所以贪心算法是值得我们深入了解的。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>首先要明确一个问题可以使用贪心算法的两个<strong>基本要素</strong>：</p>
<ol>
<li><code>贪心选择性质</code>：所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到</li>
<li><code>最优子结构性质</code>：一个问题的最优解包含其子问题的最优解</li>
</ol>
<p>贪心算法的<strong>基本过程</strong>如下：</p>
<ol>
<li>建立数学模型来描述问题</li>
<li>把求解的问题分成若干个子问题</li>
<li>对每一子问题求解，得到子问题的局部最优解</li>
<li>把子问题的解局部最优解合成原来解问题的一个解</li>
</ol>
<p>其实上面的两段话大致有个印象就好，具体的做法我们接下来通过一些例子学习。</p>
<h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="分发饼干（LeetCode455-easy）"><a href="#分发饼干（LeetCode455-easy）" class="headerlink" title="分发饼干（LeetCode455 easy）"></a>分发饼干（LeetCode455 easy）</h3><p><strong>题目：</strong></p>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 g<sub>i</sub> ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 s<sub>j</sub> 。如果 s<sub>j</sub> &gt;= g<sub>i</sub> ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><strong>注意：</strong></p>
<ul>
<li>你可以假设胃口值为正。</li>
<li>一个小朋友最多只能拥有一块饼干。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>咋一看似乎有点麻烦，回溯、动态规划什么的已经开始酝酿了！但是再一想，本题的目标是尽可能满足多数量的孩子，那么很显然有如下结论：<strong>无论饼干情况如何，肯定是先满足胃口小的孩子是最优的；反之对于某个特定孩子而言，饼干肯定要选择最小的但是能满足该孩子的是最优的。</strong></p>
<p>所以这题可以使用贪心算法，优先使用最小的饼干满足最小的胃口，如果不可以，则丢弃这个饼干，采用次小的，依次类推，直到没有饼干或者没有小朋友。具体代码思路如下：</p>
<ol>
<li>对<code>g</code>和<code>s</code>升序排序</li>
<li>初始化两个指针<code>i</code>和<code>j</code>分别指向<code>g</code>和<code>s</code>初始位置</li>
<li>对比<code>g[i]</code>和<code>s[j]</code><ul>
<li><code>g[i] &lt;= s[j]</code>： 饼干满足胃口，把能满足的孩子数量加 1，并移动指针<code>i = i + 1</code>，<code>j = j + 1</code></li>
<li><code>g[i] &gt; s[j]</code>：无法满足胃口，<code>j</code>右移，继续查看下一块饼干是否可以满足胃口</li>
</ul>
</li>
</ol>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;i&lt;g.length &amp;&amp; j&lt;s.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[j]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="柠檬水找零（LeetCode-860-easy）"><a href="#柠檬水找零（LeetCode-860-easy）" class="headerlink" title="柠檬水找零（LeetCode 860 easy）"></a>柠檬水找零（LeetCode 860 easy）</h3><p><strong>题目</strong></p>
<p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，按账单 bills 支付的顺序一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p>
<p>注意，一开始你手头没有任何零钱。<br>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>顾客付款有三种可能：5、10、20。</p>
<ul>
<li>如果收到5美元，直接把5元放进口袋，什么也不用做</li>
<li>如果收到的10美元，则需要翻一翻自己的口袋里是否有5美元的零钱，没有则交易失败，可以关门回家了（返回false）</li>
<li>如果收到20美元，这时可以找零<code>10美元+5美元</code>或者<code>三张5美元</code>，这个时候如何抉择呢？<strong>我们使用贪心策略，尽可能地多留5元在手上，防止后面付款10元的顾客无法找零</strong>，也就是优先使用<code>10美元+5美元</code>，如果没有则使用<code>5美元+5美元+5美元</code>的组合，都不成立的话则交易失败，可以关门回家了（返回false）</li>
</ul>
<p>可以很显然的看出，当算法终止时局部最优是等于全局最优的，这一题的贪心策略是完全正确的。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lemonadeChange</span><span class="params">(<span class="keyword">int</span>[] bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : bills) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) five++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;five--; ten++;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ten &gt; <span class="number">0</span>) &#123;ten--; five--;&#125;</span><br><span class="line">            <span class="keyword">else</span> five -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (five &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跳跃游戏（LeetCode-55-medium）"><a href="#跳跃游戏（LeetCode-55-medium）" class="headerlink" title="跳跃游戏（LeetCode 55 medium）"></a>跳跃游戏（LeetCode 55 medium）</h3><p><strong>题目：</strong></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>这题粗略一看是可以用动态规划完成的，但是仔细研读后，其实我们很容易有这种想法：</p>
<ol>
<li>如果某一个作为<code>起跳点</code>的格子可以跳跃的距离是3，那么表示后面3个格子都可以作为<code>起跳点</code></li>
<li>那么我们选择这3个<code>起跳点</code>中的哪一个呢？其实在这里，我们是希望选择的新的<code>起跳点</code>可以让后续的跳跃尽可能的远，这样的局部最优很显然是全局最优。所以可以对每一个能作为<code>起跳点</code>的格子都尝试跳一次，把<code>能跳到的最远距离</code>不断更新</li>
<li>如果可以一直跳到最后就成功了，反之则失败</li>
</ol>
<p>那什么是<code>能跳到的最远距离</code>呢？在代码中便是<code>i+nums[i]</code>，也就是此时数组的下标加上该位置数组元素对应的数值。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            max = Math.max(i + nums[i], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跳跃游戏-II（LeetCode-45-hard）"><a href="#跳跃游戏-II（LeetCode-45-hard）" class="headerlink" title="跳跃游戏 II（LeetCode 45 hard）"></a>跳跃游戏 II（LeetCode 45 hard）</h3><p><strong>题目：</strong></p>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<p>说明: 假设你总是可以到达数组的最后一个位置。</p>
<p><strong>分析</strong></p>
<p>和上题的思路是一样的，我们每次贪心的跳到<code>i+nums[i]</code>最大的位置，这样跳的次数肯定是最少的。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (idx + nums[idx] &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">            <span class="keyword">int</span> pos = idx + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = idx + <span class="number">1</span>; i &lt;= idx + nums[idx]; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt; pos + nums[pos]) pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            idx = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种更加简洁的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, curEnd = <span class="number">0</span>, curFarthest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curFarthest = Math.max(curFarthest, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == curEnd) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                curEnd = curFarthest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用最少数量的箭引爆气球（LeetCode-452-medium）"><a href="#用最少数量的箭引爆气球（LeetCode-452-medium）" class="headerlink" title="用最少数量的箭引爆气球（LeetCode 452 medium）"></a>用最少数量的箭引爆气球（LeetCode 452 medium）</h3><p><strong>题目：</strong></p>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。</p>
<p>一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 $x_{start}, x_{end}$，且满足 $x_{start} ≤ x ≤ x_{end}$，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">对于该样例，我们可以在x &#x3D; 6（射爆[2,8],[1,6]两个气球）和 x &#x3D; 11（射爆另外两个气球）。</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong></p>
<p>对于某个气球，至少需要使用1只弓箭将它击穿。</p>
<p>因此有如下贪心策略：在击穿某个气球的同时，尽可能的击穿其他更多的气球。</p>
<p>算法思路如下：</p>
<ol>
<li>对各个气球排序，按照气球<code>左端点</code>从小到大排序。</li>
<li>遍历气球数组，同时维护一个<code>射击区间</code>，在满足可以将当前气球击穿的情况下，尽可能的击穿更多的气球，每击穿一个新的气球，更新一次射击区间（保证射击区间可以将新气球也击穿）。</li>
<li>如果新的气球没法被击穿了，则需要增加一名弓箭手，即维护一个新的射击区间，随后继续遍历气球数组。</li>
</ol>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// int start = points[0][0];</span></span><br><span class="line">        <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; points[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// start = points[i][0];</span></span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// start = points[i][0];</span></span><br><span class="line">                end = Math.min(end, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们发现，<code>end</code>是至关重要的，<code>start</code>是可有可无的。因此本题最好的方式是按照气球的<code>右端点</code>从小到大排序，这里直接给出相应代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; points[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.zhihu.com/search?q=%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95&type=content" target="_blank" rel="noopener">小白带你学—贪心算法</a></li>
<li><a href="https://leetcode.com/problemset/algorithms/" target="_blank" rel="noopener">LeetCode Algorithms</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-04-24T03:25:17.474Z" itemprop="dateUpdated">2020-04-24 11:25:17</time>
</span><br>


        
        若有疑问或者本人有写的不对的地方, 欢迎留言或者直接邮箱反馈至yingzq0116@163.com, 非常感谢您的阅读~
        
    </div>
    
    <footer>
        <a href="https://www.yingzq.com">
            <img src="/img/avatar.jpg" alt="应子强">
            应子强
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/" rel="tag">算法设计技巧</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.yingzq.com/2019/10/22/greedy-algorithm/&title=《贪心算法》 — yingzq's Blog&pic=https://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.yingzq.com/2019/10/22/greedy-algorithm/&title=《贪心算法》 — yingzq's Blog&source=交流NLP, 深度学习技术, 分享coding路上的风景" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.yingzq.com/2019/10/22/greedy-algorithm/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《贪心算法》 — yingzq's Blog&url=https://www.yingzq.com/2019/10/22/greedy-algorithm/&via=https://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.yingzq.com/2019/10/22/greedy-algorithm/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/10/30/the-illustrated-transformer/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Transformer图解</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/10/16/git-branching-part-two/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Git的杀手锏：分支模型（下）</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "mGqkrgTscxf4JdcqkEHkFCfs-gzGzoHsz",
            appKey: "PwU9oOfhNnWOKaMaOTqQpiNW",
            avatar: "mm",
            placeholder: "要不要说点什么？",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>应子强 &copy; 2019 - 2021</span>
            <span>
                
                <a href="https://beian.miit.gov.cn/" target="_blank">京ICP备19041830号-1</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.yingzq.com/2019/10/22/greedy-algorithm/&title=《贪心算法》 — yingzq's Blog&pic=https://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.yingzq.com/2019/10/22/greedy-algorithm/&title=《贪心算法》 — yingzq's Blog&source=交流NLP, 深度学习技术, 分享coding路上的风景" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.yingzq.com/2019/10/22/greedy-algorithm/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《贪心算法》 — yingzq's Blog&url=https://www.yingzq.com/2019/10/22/greedy-algorithm/&via=https://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.yingzq.com/2019/10/22/greedy-algorithm/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKElEQVR42u3aQW4DIQwF0Nz/0tNtpabJ/zitNPBYRQkz4bGwDPbjEY/r2/j5TfJr+87HXwwMDIzbMq6X4/UfvH7q+5zkc75ZT6gYGBgHMH6LYJM5SdjNqW/WjIGBgRGka2ther59GBgYGMmcPKTmARoDAwNj7RDbXr21b/unszgGBsYNGfmt+/9//pP6BgYGxq0YVznaomZbmLyWBgYGxt6M+VVaMnOtdaNdDwYGxq6MeVNX3jaRJ52v2zWefIOBgXEAI5oaLGJS4GyLBE8CLgYGxqaMPHS2xc5JE1gb7jEwMPZm5Ffza4XJSRmyaO/AwMA4gJGnaO3xMt+OUaMYBgbGMYxJmpgnc22DRfQUBgbGAYx5CrgWrNcu3d7cGmJgYGzHaP9yrRgwacioV4iBgbEdI0n+kgSuDdk5JvpfDAyMrRn51EmNNN+sthHtTT0WAwNjI8Za2F0Lvnm0rNNTDAyMTRltG8SnSgX5s6NmCwwMjC0Yk+Jie3E2KVgmTR4YGBgnMNbustqr/7aZo9hiDAyMwxhtstg2Z3y22ImBgXEOI19uEhA/lSwuHmIxMDA2YlzlSALoJOzmbyiiPgYGxs0Z+ch58yQvwRcpIwYGxhaMNsjmx922eLnWooGBgXEOIw987cXZZJvy1WJgYGAkjHmymLedYWBgYLTXam2DRZv8JSEbAwPjBMbaVVr7VF4KrZswMDAwtmaMjo6Dlybv/HBREwMD436ML0lH2xmgXVrDAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来练习bug!';
            clearTimeout(titleTime);
        } else {
            document.title = 'yingzq's Blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
