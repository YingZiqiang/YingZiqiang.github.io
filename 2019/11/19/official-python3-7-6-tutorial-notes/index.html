<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Python3.7.6官方教程阅读笔记 | yingzq&#39;s Blog | 练习bug时长两年半的实习生</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Python,阅读笔记">
    <meta name="description" content="最近想要复习一下Python一些基本的知识点，网上有着许许多多的Python学习教程，眼花缭乱，但是其实Python是有 官方中文文档 的，并且写的非常不错！所以对照着文档中的入门教程进行了学习，同时记录了一些值得注意的地方。">
<meta property="og:type" content="article">
<meta property="og:title" content="Python3.7.6官方教程阅读笔记">
<meta property="og:url" content="https://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/index.html">
<meta property="og:site_name" content="yingzq&#39;s Blog">
<meta property="og:description" content="最近想要复习一下Python一些基本的知识点，网上有着许许多多的Python学习教程，眼花缭乱，但是其实Python是有 官方中文文档 的，并且写的非常不错！所以对照着文档中的入门教程进行了学习，同时记录了一些值得注意的地方。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-11-19T09:23:40.000Z">
<meta property="article:modified_time" content="2020-02-27T07:06:24.177Z">
<meta property="article:author" content="应子强">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="阅读笔记">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="yingzq&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/avatar.jpg">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">应子强</h5>
          <a href="mailto:yingzq0116@163.com" title="yingzq0116@163.com" class="mail">yingzq0116@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签云
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-info-circle"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/YingZiqiang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Python3.7.6官方教程阅读笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Python3.7.6官方教程阅读笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-11-19T09:23:40.000Z" itemprop="datePublished" class="page-time">
  2019-11-19
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Python/">Python</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#初入Python"><span class="post-toc-number">1.</span> <span class="post-toc-text">初入Python</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#除法运算"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">除法运算</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符串"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#列表"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">列表</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#流程控制工具"><span class="post-toc-number">2.</span> <span class="post-toc-text">流程控制工具</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#if-语句"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">if 语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#for-语句"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">for 语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#循环中的-else-子句"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">循环中的 else 子句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pass-语句"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">pass 语句</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数定义的更多形式"><span class="post-toc-number">3.</span> <span class="post-toc-text">函数定义的更多形式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#参数默认值"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">参数默认值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#关键字参数"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">关键字参数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#任意的参数列表"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">任意的参数列表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解包参数列表"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">解包参数列表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#lambda-表达式"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">lambda 表达式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文档字符串"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">文档字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数标注"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">函数标注</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据结构"><span class="post-toc-number">4.</span> <span class="post-toc-text">数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#列表的更多特性"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">列表的更多特性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#del-语句"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">del 语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#元组，集合以及字典"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">元组，集合以及字典</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#循环的技巧"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">循环的技巧</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#模块"><span class="post-toc-number">5.</span> <span class="post-toc-text">模块</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#以脚本的方式执行模块"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">以脚本的方式执行模块</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#包"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">包</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#输入输出"><span class="post-toc-number">6.</span> <span class="post-toc-text">输入输出</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#更漂亮的输出格式"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">更漂亮的输出格式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#读写文件"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">读写文件</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#错误和异常"><span class="post-toc-number">7.</span> <span class="post-toc-text">错误和异常</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#语法错误"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">语法错误</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#异常"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">异常</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#处理异常"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">处理异常</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#抛出异常"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">抛出异常</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用户自定义异常"><span class="post-toc-number">7.5.</span> <span class="post-toc-text">用户自定义异常</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义清理操作"><span class="post-toc-number">7.6.</span> <span class="post-toc-text">定义清理操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类"><span class="post-toc-number">8.</span> <span class="post-toc-text">类</span></a></li></ol>
        </nav>
    </aside>


<article id="post-official-python3-7-6-tutorial-notes"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Python3.7.6官方教程阅读笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-11-19 17:23:40" datetime="2019-11-19T09:23:40.000Z"  itemprop="datePublished">2019-11-19</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Python/">Python</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>最近想要复习一下Python一些基本的知识点，网上有着许许多多的Python学习教程，眼花缭乱，但是其实Python是有 <a href="https://docs.python.org/zh-cn/3/" target="_blank" rel="noopener">官方中文文档</a> 的，并且写的非常不错！所以对照着文档中的入门教程进行了学习，同时记录了一些值得注意的地方。</p>
<a id="more"></a>

<blockquote>
<p>注：本文选取了对应Python 3.7.6版本的官方教程进行阅读，另外本文只是<strong>简单记录了官方教程1到9章中（也就是不含标准库的部分）值得留意的、零碎的笔记</strong>便于复习。想要系统的学习一遍可移步 <a href="https://docs.python.org/zh-cn/3.7/tutorial/index.html" target="_blank" rel="noopener">官方入门教程</a> 。</p>
</blockquote>
<h2 id="初入Python"><a href="#初入Python" class="headerlink" title="初入Python"></a>初入Python</h2><h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p>Python除法运算 <code>/</code> 永远返回浮点数类型。如果想要得到一个忽略小数部分的整数结果（floor division），可以使用 <code>//</code> 运算符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> / <span class="number">3</span>  <span class="comment"># classic division returns a float</span></span><br><span class="line"><span class="number">5.666666666666667</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> // <span class="number">3</span>  <span class="comment"># floor division discards the fractional part</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>如果你不希望前置了 <code>\</code> 的字符转义成特殊字符，可以使用 <code>原始字符串</code> 方式，在引号前添加 <code>r</code> 即可:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'C:\some\name'</span>)  <span class="comment"># here \n means newline!</span></span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r'C:\some\name'</span>)  <span class="comment"># note the r before the quote</span></span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure>

<p>字符串字面值可以跨行连续输入。一种方式是用三重引号：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个 <code>\</code> 即可。</p>
<p>字符串可以用 <code>+</code> 进行连接（粘到一起），也可以用 <code>*</code> 进行重复:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 3 times 'un', followed by 'ium'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="string">'un'</span> + <span class="string">'ium'</span></span><br><span class="line"><span class="string">'unununium'</span></span><br></pre></td></tr></table></figure>

<p>相邻的两个或多个 <code>字符串字面值（引号引起来的字符）</code> 将会自动连接到一起:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Py'</span> <span class="string">'thon'</span></span><br><span class="line"><span class="string">'Python'</span></span><br></pre></td></tr></table></figure>

<p>把很长的字符串拆开分别输入的时候尤其有用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = (<span class="string">'Put several strings within parentheses '</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">'to have them joined together.'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text</span><br><span class="line"><span class="string">'Put several strings within parentheses to have them joined together.'</span></span><br></pre></td></tr></table></figure>

<p>但是只能对两个字面值这样操作，变量或表达式不行，如果你想连接变量，或者连接变量和字面值，可以用 <code>+</code> 号。</p>
<p>字符串是可以被 <code>索引（下标访问）</code> 的，第一个字符索引是 0。单个字符并没有特殊的类型，只是一个长度为一的字符串。索引也可以用负数，这种会从右边开始数，<strong>注意 -0 和 0 是一样的，所以负数索引从 -1 开始</strong>。</p>
<p>除了索引，字符串还支持 <code>切片</code>，<strong>注意<code>切片</code>的开始总是被包括在结果中，而结束不被包括</strong>。另外切片的索引有默认值：省略开始索引时默认为 0，省略结束索引时默认为到字符串的结束。</p>
<p>试图使用过大的索引会产生一个错误，但是切片中的越界索引会被自动处理:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">42</span>]  <span class="comment"># the word only has 6 characters</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: string index out of range</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">4</span>:<span class="number">42</span>]</span><br><span class="line"><span class="string">'on'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">42</span>:]</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure>

<p><strong>Python 中的字符串不能被修改，它们是 <code>immutable</code> 的。</strong> 因此，向字符串的某个索引位置赋值会产生一个错误:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>] = <span class="string">'J'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:] = <span class="string">'py'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>

<blockquote>
<p>immutable: 具有固定值的对象。不可变对象包括数字、字符串和元组。这样的对象不能被改变。如果必须存储一个不同的值，则必须创建新的对象。它们在需要常量哈希值的地方起着重要作用，例如作为字典中的键。</p>
</blockquote>
<p>如果需要一个不同的字符串，应当新建一个:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'J'</span> + word[<span class="number">1</span>:]</span><br><span class="line"><span class="string">'Jython'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>] + <span class="string">'py'</span></span><br><span class="line"><span class="string">'Pypy'</span></span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Python 中可以通过组合一些值得到多种 <code>复合</code> 数据类型。其中最常用的 <code>列表</code>，可以通过方括号括起、逗号分隔的一组值（元素）得到。一个 <code>列表</code> 可以包含不同类型的元素，但通常使用时各个元素类型相同。</p>
<p>和字符串（以及各种内置的 <code>sequence</code> 类型）一样，列表也支持索引和切片。所有的切片操作都返回一个新列表，这个新列表包含所需要的元素。就是说，如下的切片会返回<code>列表的一个新的(浅)拷贝</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[:]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>

<p>与 <code>immutable</code> 的字符串不同, 列表是一个 <code>mutable</code> 类型，就是说，它自己的内容是可以改变的。</p>
<blockquote>
<p>注：后面章节会更加详细的介绍列表。</p>
</blockquote>
<h2 id="流程控制工具"><a href="#流程控制工具" class="headerlink" title="流程控制工具"></a>流程控制工具</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>值得注意的是Python中使用的是<code>elif</code>而不是类似Java、C语言中的 “else if” ，其实关键字<code>elif</code>就是 “else if” 的缩写。Python中一个 <code>if ... elif ... elif ...</code> 序列可以看作是其他语言中的 switch 或 case 语句的替代。</p>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p>Python中的 <code>for</code> 语句与你在 C 或 Java 中可能用到的有所不同。Python中的 <code>for</code> 语句是对任意序列进行迭代（例如列表或字符串），条目的迭代顺序与它们在序列中出现的顺序一致。</p>
<p><strong>如果在循环内需要修改序列中的值（比如重复某些选中的元素），推荐你先拷贝一份副本。</strong> 对序列进行循环不代表制作了一个副本进行操作。切片操作使这件事非常简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = [<span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> w <span class="keyword">in</span> words[:]:  <span class="comment"># Loop over a slice copy of the entire list.</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> len(w) &gt; <span class="number">6</span>:</span><br><span class="line"><span class="meta">... </span>        words.insert(<span class="number">0</span>, w)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words</span><br><span class="line">[<span class="string">'defenestrate'</span>, <span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br></pre></td></tr></table></figure>

<p>如果写成 <code>for w in words:</code>，这个示例就会创建无限长的列表，一次又一次重复地插入 <code>defenestrate</code>。</p>
<h3 id="循环中的-else-子句"><a href="#循环中的-else-子句" class="headerlink" title="循环中的 else 子句"></a>循环中的 else 子句</h3><p>Python <code>循环语句</code>可能带有一个 <code>else 子句</code>；<strong>它会在循环遍历完列表 (使用 for) 或是在条件变为假 (使用 while) 的时候被执行，但是不会在循环被 break 语句终止时被执行。</strong> 这可以通过以下搜索素数的循环为例来进行说明:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line"><span class="meta">... </span>        print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h3><p><code>pass</code> 语句什么也不做。<strong>当语法上需要一个语句，但程序需要什么动作也不做时，可以使用它</strong>。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span>  <span class="comment"># Busy-wait for keyboard interrupt (Ctrl+C)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通常还用于创建最小的类:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyEmptyClass</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>pass</code> 的另一个可以使用的场合是在你编写新的代码时作为一个函数或条件子句体的占位符，允许你保持在更抽象的层次上进行思考。 <code>pass</code> 会被静默地忽略:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">initlog</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span>   <span class="comment"># Remember to implement this!</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="函数定义的更多形式"><a href="#函数定义的更多形式" class="headerlink" title="函数定义的更多形式"></a>函数定义的更多形式</h2><p>给函数定义有可变数目的参数也是可行的。这里有三种形式，可以组合使用。</p>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>最有用的形式是对一个或多个参数指定一个默认值。这样创建的函数，可以用比定义时允许的更少的参数调用。此类函数可以通过几种方式调用:</p>
<ul>
<li>只给出必需的参数</li>
<li>给出部分可选的参数</li>
<li>给出所有的参数</li>
</ul>
<p>需要注意的是<strong>默认值是在定义过程中在函数定义处计算的</strong>，所以:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(arg=i)</span>:</span></span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">f()</span><br></pre></td></tr></table></figure>

<p>会打印 <code>5</code>。</p>
<p><strong>重要警告：</strong> <code>默认值只会执行一次</code>。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。比如，下面的函数会存储在后续调用中传递给它的参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, L=[])</span>:</span></span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line">print(f(<span class="number">1</span>))</span><br><span class="line">print(f(<span class="number">2</span>))</span><br><span class="line">print(f(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>这将打印出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>如果你不想要在后续调用之间共享默认值，你可以这样写这个函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>

<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>也可以使用形如 <code>kwarg=value</code> 的关键字参数来调用函数。</p>
<p>需要注意的是，在函数调用中，<strong>关键字参数必须跟随在位置参数的后面；传递的所有关键字参数必须与函数接受的其中一个参数匹配，它们的顺序并不重要，这也包括非可选参数；也不能对同一个参数多次赋值。</strong></p>
<p>当存在一个形式为 <code>**name</code> 的最后一个形参时，它会接收一个<strong>字典</strong>，其中包含除了与已有形参相对应的关键字参数以外的所有关键字参数。这可以与一个形式为 <code>*name</code>，接收一个包含除了已有形参列表以外的位置参数的<strong>元组</strong>的形参 (将在下一小节介绍) 组合使用，其中 <code>*name</code> 必须出现在 <code>**name</code> 之前！。例如，如果我们这样定义一个函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cheeseshop</span><span class="params">(kind, *arguments, **keywords)</span>:</span></span><br><span class="line">    print(<span class="string">"-- Do you have any"</span>, kind, <span class="string">"?"</span>)</span><br><span class="line">    print(<span class="string">"-- I'm sorry, we're all out of"</span>, kind)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> arguments:</span><br><span class="line">        print(arg)</span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line">    <span class="keyword">for</span> kw <span class="keyword">in</span> keywords:</span><br><span class="line">        print(kw, <span class="string">":"</span>, keywords[kw])</span><br></pre></td></tr></table></figure>

<p>它可以像这样调用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cheeseshop(<span class="string">"Limburger"</span>, <span class="string">"It's very runny, sir."</span>,</span><br><span class="line">           <span class="string">"It's really very, VERY runny, sir."</span>,</span><br><span class="line">           shopkeeper=<span class="string">"Michael Palin"</span>,</span><br><span class="line">           client=<span class="string">"John Cleese"</span>,</span><br><span class="line">           sketch=<span class="string">"Cheese Shop Sketch"</span>)</span><br></pre></td></tr></table></figure>

<p>当然它会打印:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- Do you have any Limburger ?</span><br><span class="line">-- I&#39;m sorry, we&#39;re all out of Limburger</span><br><span class="line">It&#39;s very runny, sir.</span><br><span class="line">It&#39;s really very, VERY runny, sir.</span><br><span class="line">----------------------------------------</span><br><span class="line">shopkeeper : Michael Palin</span><br><span class="line">client : John Cleese</span><br><span class="line">sketch : Cheese Shop Sketch</span><br></pre></td></tr></table></figure>

<p>注意打印时关键字参数的顺序保证与调用函数时提供它们的顺序是相匹配的。</p>
<h3 id="任意的参数列表"><a href="#任意的参数列表" class="headerlink" title="任意的参数列表"></a>任意的参数列表</h3><p>最后，最不常用的选项是可以使用任意数量的参数调用函数。这些参数会被包含在一个<strong>元组</strong>里，在可变数量的参数之前，可能会出现零个或多个普通参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_multiple_items</span><span class="params">(file, separator, *args)</span>:</span></span><br><span class="line">    file.write(separator.join(args))</span><br></pre></td></tr></table></figure>

<p><strong>一般来说，这些 <code>可变参数</code> 将在形式参数列表的末尾，因为它们收集传递给函数的所有剩余输入参数。出现在 <code>*args</code> 参数之后的任何形式参数都是 ‘仅关键字参数’，也就是说它们只能作为关键字参数而不能是位置参数:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat</span><span class="params">(*args, sep=<span class="string">"/"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sep.join(args)</span><br></pre></td></tr></table></figure>

<h3 id="解包参数列表"><a href="#解包参数列表" class="headerlink" title="解包参数列表"></a>解包参数列表</h3><p>当参数已经在列表或元组中但需要为需要单独位置参数的函数调用解包时，会发生相反的情况。例如，内置的 range() 函数需要单独的 start 和 stop 参数。如果它们不能单独使用，请使用 <code>*</code> 运算符编写函数调用以从列表或元组中解包参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">3</span>, <span class="number">6</span>))            <span class="comment"># normal call with separate arguments</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = [<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(*args))            <span class="comment"># call with arguments unpacked from a list</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>以同样的方式，字典可以使用 <code>**</code> 运算符来提供关键字参数。</p>
<h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><p>可以用 <code>lambda</code> 关键字来创建一个小的匿名函数。这个函数返回两个参数的和：<code>lambda a, b: a+b</code> 。<strong>lambda函数可以在需要函数对象的任何地方使用。</strong> 它们在语法上限于单个表达式。从语义上来说，它们只是正常函数定义的语法糖。与嵌套函数定义一样，lambda函数可以引用所包含域的变量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_incrementor</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = make_incrementor(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">0</span>)</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>)</span><br><span class="line"><span class="number">43</span></span><br></pre></td></tr></table></figure>

<p>上面的例子使用一个lambda表达式来返回一个函数。另一个用法是传递一个小函数作为参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs = [(<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">2</span>, <span class="string">'two'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">4</span>, <span class="string">'four'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs.sort(key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs</span><br><span class="line">[(<span class="number">4</span>, <span class="string">'four'</span>), (<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">2</span>, <span class="string">'two'</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>以下是有关文档字符串的内容和格式的一些约定。</p>
<p><strong>第一行应该是对象目的的简要概述。</strong> 为简洁起见，它不应显式声明对象的名称或类型，因为这些可通过其他方式获得（除非名称恰好是描述函数操作的动词）。这一行应以大写字母开头，以句点结尾。</p>
<p><strong>如果文档字符串中有更多行，则第二行应为空白，从而在视觉上将摘要与其余描述分开。</strong> 后面几行应该是一个或多个段落，描述对象的调用约定，它的副作用等。</p>
<p>Python 解析器不会从 Python 中删除多行字符串文字的缩进，因此处理文档的工具必须在需要时删除缩进。 这是使用以下约定完成的：<strong>文档字符串第一行之后的第一个非空行确定整个文档字符串的缩进量（我们不能使用第一行，因为它通常与字符串的开头引号相邻，因此它的缩进在字符串文字中不明显）。</strong> 然后从字符串的所有行的开头剥离与该缩进 “等效” 的空格。 缩进更少的行不应该出现，但是如果它们出现，则应该剥离它们的所有前导空格。 应在转化制表符为空格后测试空格的等效性（通常转化为8个空格）。</p>
<p>下面是一个多行文档字符串的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Do nothing, but document it.</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    No, really, it doesn't do anything.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    """</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_function.__doc__)</span><br><span class="line">Do nothing, but document it.</span><br><span class="line"></span><br><span class="line">    No, really, it doesn<span class="string">'t do anything.</span></span><br></pre></td></tr></table></figure>

<h3 id="函数标注"><a href="#函数标注" class="headerlink" title="函数标注"></a>函数标注</h3><p><code>函数标注</code>是关于用户自定义函数中使用的类型的完全可选元数据信息。</p>
<p><strong>函数标注以字典的形式存放在函数的 <code>__annotations__</code> 属性中，并且不会影响函数的任何其他部分。</strong> 形参标注的定义方式是在形参名称后加上冒号，后面跟一个表达式，该表达式会被求值为标注的值。 返回值标注的定义方式是加上一个组合符号 <code>-&gt;</code>，后面跟一个表达式，该标注位于形参列表和表示 def 语句结束的冒号之间。 下面的示例有一个位置参数，一个关键字参数以及返回值带有相应标注:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(ham: str, eggs: str = <span class="string">'eggs'</span>)</span> -&gt; str:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Annotations:"</span>, f.__annotations__)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Arguments:"</span>, ham, eggs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> ham + <span class="string">' and '</span> + eggs</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="string">'spam'</span>)</span><br><span class="line">Annotations: &#123;'ham': &lt;class 'str'&gt;, 'return': &lt;class 'str'&gt;, 'eggs': &lt;class 'str'&gt;&#125;</span><br><span class="line">Arguments: spam eggs</span><br><span class="line"><span class="string">'spam and eggs'</span></span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="列表的更多特性"><a href="#列表的更多特性" class="headerlink" title="列表的更多特性"></a>列表的更多特性</h3><p><strong>1. 列表对象方法的清单</strong></p>
<ul>
<li>list.<strong>append</strong>(x) ：在列表的末尾添加一个元素。相当于 <code>a[len(a):] = [x]</code> 。</li>
<li>list.<strong>extend</strong>(iterable) ：使用可迭代对象中的所有元素来扩展列表。相当于 <code>a[len(a):] = iterable</code> 。</li>
<li>list.<strong>insert</strong>(i, x) ：在给定的位置插入一个元素。第一个参数是要插入的元素的索引，所以 <code>a.insert(0, x)</code> 插入列表头部， <code>a.insert(len(a), x)</code> 等同于 <code>a.append(x)</code> 。</li>
<li>list.<strong>remove</strong>(x) ：移除列表中第一个值为 x 的元素。如果没有这样的元素，则抛出 ValueError 异常。</li>
<li>list.<strong>pop</strong>([i]) ：删除列表中给定位置的元素并返回它。如果没有给定位置，<code>a.pop()</code> 将会删除并返回列表中的最后一个元素。<em>（ 方法签名中 i 两边的方括号表示这个参数是可选的，而不是要你输入方括号。你会在 Python 参考库中经常看到这种表示方法)</em></li>
<li>list.<strong>clear</strong>() ：移除列表中的所有元素。等价于<code>del a[:]</code>。</li>
<li>list.<strong>index</strong>(x[, start[, end]]) ：返回列表中第一个值为 x 的元素的从零开始的索引。如果没有这样的元素将会抛出 ValueError 异常。可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数。</li>
<li>list.<strong>count</strong>(x) ：返回元素 x 在列表中出现的次数。</li>
<li>list.<strong>sort</strong>(key=None, reverse=False) ：对列表中的元素进行排序。</li>
<li>list.<strong>reverse</strong>() ：翻转列表中的元素。</li>
<li>list.<strong>copy</strong>() ：返回列表的一个浅拷贝，等价于 <code>a[:]</code>。</li>
</ul>
<p>根据上面的方法，是可以很轻松的将列表作为<code>栈</code>或者<code>队列</code>使用的。但是列表作为<code>队列</code>使用是相当低效的，因为在列表的末尾添加和弹出元素非常快，但是在列表的开头插入或弹出元素却很慢 (因为所有的其他元素都必须移动一位)，若要实现一个队列，可使用 <code>collections.deque</code>，它被设计成可以快速地从两端添加或弹出元素。</p>
<p><strong>2. 列表推导式</strong></p>
<p>列表推导式提供了一个更简单的创建列表的方法。常见的用法是把某种操作应用于序列或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。</p>
<p>例如，假设我们想创建一个平方列表，像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    squares.append(x**<span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>

<p>可以写成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>

<p><strong>列表推导式的结构是由一对方括号所包含的以下内容：一个表达式，后面跟一个 for 子句，然后是零个或多个 for 或 if 子句。 其结果将是一个新列表，由对表达式依据后面的 for 和 if 子句的内容进行求值计算而得出。</strong> 举例来说，以下列表推导式会将两个列表中不相等的元素组合起来:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>

<p>而它等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> x != y:</span><br><span class="line"><span class="meta">... </span>            combs.append((x, y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>

<p>注意在上面两个代码片段中，<strong>for 和 if 的顺序是相同的</strong>。</p>
<p>如果表达式是一个元组（例如上面的 <code>(x, y)</code>），那么就必须加上括号。另外列表推导式可以使用复杂的表达式和嵌套函数。</p>
<p><strong>3. 嵌套的列表推导式</strong></p>
<p>列表推导式中的初始表达式可以是任何表达式，包括另一个列表推导式。</p>
<p>考虑下面这个 3x4的矩阵，它由3个长度为4的列表组成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [</span><br><span class="line"><span class="meta">... </span>    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"><span class="meta">... </span>]</span><br></pre></td></tr></table></figure>

<p>下面的列表推导式将交换其行和列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure>

<p>如上节所示，嵌套的列表推导式是基于跟随其后的 for 进行求值的，所以这个例子等价于:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</span><br></pre></td></tr></table></figure>

<p>实际应用中，你应该会更喜欢使用内置函数去组成复杂的流程语句。 <code>zip()</code> 函数将会很好地处理这种情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*matrix))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="del-语句"><a href="#del-语句" class="headerlink" title="del 语句"></a>del 语句</h3><p>有一种方式可以从列表按照给定的索引而不是值来移除一个元素: 那就是 <code>del</code> 语句。 它不同于会返回一个值的 pop() 方法， <code>del</code> 语句也可以用来从列表中移除切片或者清空整个列表，也可以删除整个变量。</p>
<h3 id="元组，集合以及字典"><a href="#元组，集合以及字典" class="headerlink" title="元组，集合以及字典"></a>元组，集合以及字典</h3><p><code>元组</code>可能看起来与列表很像，但它们通常是在不同的场景被使用，并且有着不同的用途。元组是 <code>immutable</code> ，其序列通常包含不同种类的元素，并且通过解包或者索引来访问（如果是 <code>namedtuples</code> 的话甚至还可以通过属性访问）。列表是 <code>mutable</code> ，并且列表中的元素一般是同种类型的，并且通过迭代访问。</p>
<p>Python也包含有 <code>集合</code> 类型。集合是由不重复元素组成的无序的集。它的基本用法包括成员检测和消除重复元素。集合对象也支持像 联合，交集，差集，对称差分等数学运算。<code>花括号或 set() 函数</code>可以用来创建集合。<strong>注意：</strong>要创建一个空集合你只能用 <code>set()</code> 而不能用 <code>{}</code>，因为后者是创建一个空字典。</p>
<p>下面简单演示集合之间常用的运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Demonstrate set operations on unique letters from two words</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  <span class="comment"># unique letters in a</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># letters in a but not in b</span></span><br><span class="line">&#123;<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># letters in a or b or both</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># letters in both a and b</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># letters in a or b but not both</span></span><br><span class="line">&#123;<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个非常有用的 Python 內置数据类型是 <code>字典</code>。与以连续整数为索引的序列不同，字典是以 <code>关键字</code> 为索引的，关键字可以是任意不可变类型，通常是字符串或数字。如果一个元组只包含字符串、数字或元组，那么这个元组也可以用作关键字。但如果元组直接或间接地包含了可变对象，那么它就不能用作关键字。列表不能用作关键字，因为列表可以通过索引、切片或 append() 和 extend() 之类的方法来改变。</p>
<p>对于字典的创建，除了一般的初始化，还有一些其他方法：</p>
<ul>
<li>dict() 构造函数可以直接从键值对序列里创建字典，例如<code>dict([(&#39;sape&#39;, 4139), (&#39;guido&#39;, 4127), (&#39;jack&#39;, 4098)])</code>。</li>
<li>字典推导式可以从任意的键值表达式中创建字典，例如<code>{x: x**2 for x in (2, 4, 6)}</code>。</li>
<li>当关键字是简单字符串时，有时直接通过关键字参数来指定键值对更方便，例如<code>dict(sape=4139, guido=4127, jack=4098)</code>。</li>
</ul>
<h3 id="循环的技巧"><a href="#循环的技巧" class="headerlink" title="循环的技巧"></a>循环的技巧</h3><ul>
<li>当在字典中循环时，用 <code>items()</code> 方法可将关键字和对应的值同时取出</li>
<li>当在序列中循环时，用 <code>enumerate()</code> 函数可以将索引位置和其对应的值同时取出</li>
<li>当同时在两个或更多序列中循环时，可以用 <code>zip()</code> 函数将其内元素一一匹配</li>
<li>如果要逆向循环一个序列，可以先正向定位序列，然后调用 <code>reversed()</code> 函数</li>
<li>如果要按某个指定顺序循环一个序列，可以用 <code>sorted()</code> 函数，它可以<strong>在不改动原序列的基础上返回一个新的排好序的序列</strong></li>
<li>有时可能会想在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全的</li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是一个包含Python定义和语句的文件。文件名就是模块名后跟文件后缀 <code>.py</code> 。在一个模块内部，模块名（作为一个字符串）可以通过全局变量 <code>__name__</code> 的值获得。</p>
<h3 id="以脚本的方式执行模块"><a href="#以脚本的方式执行模块" class="headerlink" title="以脚本的方式执行模块"></a>以脚本的方式执行模块</h3><p>当你用下面方式运行一个Python模块:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python test.py &lt;arguments&gt;</span><br></pre></td></tr></table></figure>

<p>模块里的代码会被执行，就好像你导入了模块一样，但是 <code>__name__</code> 被赋值为 <code>&quot;__main__&quot;</code>。 这意味着通过在你的模块末尾添加这些代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    test(int(sys.argv[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>

<p><strong>你既可以把这个文件当作脚本又可当作一个可调入的模块来使用， 因为那段解析命令行的代码只有在当模块是以“main”文件的方式执行的时候才会运行，如果模块是被导入的，那些代码是不运行的。</strong> 这经常用于为模块提供一个方便的用户接口，或用于测试（以脚本的方式运行模块从而执行一些测试套件）。</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。 例如，模块名 <code>A.B</code> 表示 <code>A</code> 包中名为 <code>B</code> 的子模块。正如模块的使用使得不同模块的作者不必担心彼此的全局变量名称一样，使用加点的模块名可以使得 NumPy 或 Pillow 等多模块软件包的作者不必担心彼此的模块名称一样。</p>
<p><strong>必须要有 <code>__init__.py</code> 文件才能让 Python 将包含该文件的目录当作包。</strong> 这样可以防止具有通常名称例如 <code>string</code> 的目录在无意中隐藏稍后在模块搜索路径上出现的有效模块。 在最简单的情况下，<code>__init__.py</code> 可以只是一个空文件，但它也可以执行包的初始化代码或设置 <code>__all__</code> 变量，具体将在后文介绍。</p>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="更漂亮的输出格式"><a href="#更漂亮的输出格式" class="headerlink" title="更漂亮的输出格式"></a>更漂亮的输出格式</h3><p><strong>1. 格式化字符串文字</strong></p>
<p><code>格式化字符串字面值（常简称为 f-字符串）</code>能让你在字符串前加上 <code>f</code> 和 <code>F</code> 并将表达式写成 <code>{expression}</code> 来在字符串中包含 Python 表达式的值。</p>
<p>可选的格式说明符可以跟在表达式后面。这样可以更好地控制值的格式化方式。以下示例将pi舍入到小数点后三位:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f'The value of pi is approximately <span class="subst">&#123;math.pi:<span class="number">.3</span>f&#125;</span>.'</span>)</span><br><span class="line">The value of pi <span class="keyword">is</span> approximately <span class="number">3.142</span>.</span><br></pre></td></tr></table></figure>

<p>关于更多格式规范的参考，请参阅参考指南 <a href="https://docs.python.org/zh-cn/3.7/library/string.html#formatspec" target="_blank" rel="noopener">格式规格迷你语言</a> 。</p>
<p><strong>2. 字符串的 format() 方法</strong></p>
<p><code>str.format()</code> 方法的基本用法如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'We are the &#123;&#125; who say "&#123;&#125;!"'</span>.format(<span class="string">'knights'</span>, <span class="string">'Ni'</span>))</span><br><span class="line">We are the knights who say <span class="string">"Ni!"</span></span><br></pre></td></tr></table></figure>

<p>花括号和其中的字符（称为格式字段）将替换为传递给 <code>str.format()</code> 方法的对象。花括号中的数字可用来表示传递给 <code>str.format()</code> 方法的对象的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;0&#125; and &#123;1&#125;'</span>.format(<span class="string">'spam'</span>, <span class="string">'eggs'</span>))</span><br><span class="line">spam <span class="keyword">and</span> eggs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;1&#125; and &#123;0&#125;'</span>.format(<span class="string">'spam'</span>, <span class="string">'eggs'</span>))</span><br><span class="line">eggs <span class="keyword">and</span> spam</span><br></pre></td></tr></table></figure>

<p>如果在 <code>str.format()</code> 方法中使用关键字参数，则使用参数的名称引用它们的值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'This &#123;food&#125; is &#123;adjective&#125;.'</span>.format(</span><br><span class="line"><span class="meta">... </span>      food=<span class="string">'spam'</span>, adjective=<span class="string">'absolutely horrible'</span>))</span><br><span class="line">This spam <span class="keyword">is</span> absolutely horrible.</span><br></pre></td></tr></table></figure>

<p>位置和关键字参数可以任意组合:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'The story of &#123;0&#125;, &#123;1&#125;, and &#123;other&#125;.'</span>.format(<span class="string">'Bill'</span>, <span class="string">'Manfred'</span>, other=<span class="string">'Georg'</span>))</span><br><span class="line">The story of Bill, Manfred, <span class="keyword">and</span> Georg.</span><br></pre></td></tr></table></figure>

<p>关于使用 <code>str.format()</code> 进行字符串格式化的完整概述，请参阅 <a href="https://docs.python.org/zh-cn/3.7/library/string.html#formatstrings" target="_blank" rel="noopener">格式字符串语法</a> 。</p>
<p><strong>3. str() 与 repr()</strong></p>
<p><code>str()</code> 函数是用于返回人类可读的值的表示，而 <code>repr()</code> 是用于生成解释器可读的表示（如果没有等效的语法，则会强制执行 SyntaxError）对于没有人类可读性的表示的对象， <code>str()</code> 将返回和 <code>repr()</code> 一样的值。很多值使用任一函数都具有相同的表示，比如数字或类似列表和字典的结构。特殊的是字符串有两个不同的表示。</p>
<p><strong>4. 手动格式化字符串</strong></p>
<p>字符串对象的 <code>str.rjust()</code> 方法通过在左侧填充空格来对给定宽度的字段中的字符串进行右对齐。类似的方法还有 <code>str.ljust()</code> 和 <code>str.center()</code> 。这些方法不会写入任何东西，它们只是返回一个新的字符串，如果输入的字符串太长，它们不会截断字符串，而是原样返回；这虽然会弄乱你的列布局，但这通常比另一种方法好，后者会在显示值时可能不准确。（如果你真的想截断，你可以添加一个切片操作，例如 <code>x.ljust(n)[:n]</code> 。）</p>
<p>还有另外一个方法，<code>str.zfill()</code> ，它会在数字字符串的左边填充零。</p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p><strong>1. open() 函数</strong></p>
<p><code>open()</code> 返回一个 <code>file object</code>，最常用的有两个参数： <code>open(filename, mode)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'workfile'</span>, <span class="string">'w'</span>)</span><br></pre></td></tr></table></figure>

<p>第一个参数是包含文件名的字符串。第二个参数是另一个字符串，其中包含一些描述文件使用方式的字符。mode 可以是 <code>&#39;r&#39;</code> ，表示文件只能读取，<code>&#39;w&#39;</code> 表示只能写入（已存在的同名文件会被删除），还有 <code>&#39;a&#39;</code> 表示打开文件以追加内容；任何写入的数据会自动添加到文件的末尾。<code>&#39;r+&#39;</code> 表示打开文件进行读写。<code>mode参数</code> 是可选的；省略时默认为 <code>&#39;r&#39;</code>。</p>
<p>在处理文件对象时，最好使用 <code>with</code> 关键字。 <strong>优点是当子句体结束后文件会正确关闭，即使在某个时刻引发了异常。</strong> 而且使用 <code>with</code> 相比等效的 <code>try-finally</code> 代码块要简短得多:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'workfile'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    read_data = f.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.closed</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 文件对象的方法</strong></p>
<p>要读取文件内容，请调用 <code>f.read(size)</code>，它会读取一些数据并将其作为字符串（在文本模式下）或字节串对象（在二进制模式下）返回。 <code>size</code> 是一个可选的数值参数。 当 <code>size</code> 被省略或者为负数时，将读取并返回整个文件的内容；如果文件的大小是你的机器内存的两倍就会出现问题。 当取其他值时，将读取并返回至多 <code>size</code> 个字符（在文本模式下）或 <code>size</code> 个字节（在二进制模式下）。 如果已到达文件末尾，<code>f.read()</code> 将返回一个空字符串 (<code>&#39;&#39;</code>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">'This is the entire file.\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure>

<p><code>f.readline()</code> 从文件中读取一行；换行符（<code>\n</code>）留在字符串的末尾，如果文件不以换行符结尾，则在文件的最后一行省略。<strong>这使得返回值明确无误</strong>；如果 <code>f.readline()</code> 返回一个空的字符串，则表示已经到达了文件末尾，而空行使用 <code>&#39;\n&#39;</code> 表示，该字符串只包含一个换行符。</p>
<p>要从文件中读取行，你可以循环遍历文件对象。这是内存高效，快速的，并简化代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line"><span class="meta">... </span>    print(line, end=<span class="string">''</span>)</span><br><span class="line">...</span><br><span class="line">This <span class="keyword">is</span> the first line of the file.</span><br><span class="line">Second line of the file</span><br></pre></td></tr></table></figure>

<p>如果你想以列表的形式读取文件中的所有行，你也可以使用 <code>list(f)</code> 或 <code>f.readlines()</code>。</p>
<p><code>f.write(string)</code> 会把 <code>string</code> 的内容写入到文件中，并返回写入的字符数。在写入其他类型的对象之前，需要先把它们转化为字符串（在文本模式下）或者字节对象（在二进制模式下）。</p>
<p>文件对象有一些额外的方法，使用频率没这么高，就不详细介绍了。</p>
<p><strong>3. 使用 json 保存结构化数据</strong></p>
<p>Python 允许你使用称为 <code>JSON (JavaScript Object Notation)</code> 的流行数据交换格式，而不是让用户不断的编写和调试代码以将复杂的数据类型保存到文件中。名为 <code>json</code> 的标准模块可以采用 Python 数据层次结构，并将它们转化为字符串表示形式；这个过程称为 <code>serializing</code> 。从字符串表示中重建数据称为 <code>deserializing</code> 。在序列化和反序列化之间，表示对象的字符串可能已存储在文件或数据中，或通过网络连接发送到某个远程机器。</p>
<h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p><code>语法错误</code>又称<code>解析错误</code>，可能是你在学习Python 时最容易遇到的错误:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span> print(<span class="string">'Hello world'</span>)</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span> print(<span class="string">'Hello world'</span>)</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>解析器会输出出现语法错误的那一行，并显示一个“箭头”，指向这行里面检测到第一个错误。 错误是由箭头指示的位置<strong>上面</strong>的 token 引起的（或者至少是在这里被检测出的）：在示例中，在 <code>print()</code> 这个函数中检测到了错误，因为在它前面少了个冒号 (<code>&#39;:&#39;</code>) 。文件名和行号也会被输出，以便输入来自脚本文件时你能知道去哪检查。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>即使语句或表达式在语法上是正确的，但在尝试执行时，它仍可能会引发错误，在执行时检测到的错误被称为 <code>异常</code>。</p>
<p>异常不一定会导致严重后果， 但是大多数异常并不会被程序处理，此时会显示如下所示的错误信息:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> * (<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span> + spam*<span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'spam'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'2'</span> + <span class="number">2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">'t convert '</span>int<span class="string">' object to str implicitly</span></span><br></pre></td></tr></table></figure>

<p>错误信息的最后一行告诉我们程序遇到了什么类型的错误。异常有不同的类型，而其类型名称将会作为错误信息的一部分中打印出来：上述示例中的异常类型依次是：ZeroDivisionError， NameError 和 TypeError。作为异常类型打印的字符串是发生的内置异常的名称。对于所有内置异常都是如此，但对于用户定义的异常则不一定如此（虽然这是一个有用的规范）。标准的异常类型是内置的标识符（而不是保留关键字）。</p>
<p>这一行的剩下的部分根据异常类型及其原因提供详细信息。</p>
<p>错误信息的前一部分以堆栈回溯的形式显示发生异常时的上下文。通常它包含列出源代码行的堆栈回溯；但是它不会显示从标准输入中读取的行。</p>
<p><a href="https://docs.python.org/zh-cn/3.7/library/exceptions.html#bltin-exceptions" target="_blank" rel="noopener">内置异常</a> 列出了内置异常和它们的含义。</p>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>可以编写处理所选异常的程序。请看下面的例子，它会要求用户一直输入，直到输入的是一个有效的整数，但允许用户中断程序（使用 Control-C 或操作系统支持的其他操作）；请注意用户引起的中断可以通过引发 KeyboardInterrupt 异常来指示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        x = int(input(<span class="string">"Please enter a number: "</span>))</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Oops!  That was no valid number.  Try again..."</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>try 语句</code> 的工作原理如下：</p>
<ul>
<li>首先，执行 <code>try 子句</code>（try 和 except 关键字之间的（多行）语句）。</li>
<li>如果没有异常发生，则跳过 <code>except 子句</code> 并完成 <code>try 语句</code>的执行。</li>
<li>如果在执行<code>try 子句</code>时发生了异常，则跳过该子句中剩下的部分。然后，如果异常的类型和 except 关键字后面的异常匹配，则执行 <code>except 子句</code> ，然后继续执行 <code>try 语句</code><strong>之后</strong>的代码。</li>
</ul>
<p>如果发生的异常和 except 子句中指定的异常不匹配，则将其传递到外部的 try 语句中；如果没有找到处理程序，则它是一个 未处理异常，执行将停止并显示如上所示的消息。</p>
<p>一个 <code>try 语句</code>可能有多个 <code>except 子句</code>，以指定不同异常的处理程序。 最多会执行一个处理程序，处理程序只处理相应的 <code>try 子句</code> 中发生的异常，而不处理同一 <code>try 语句</code> 内其他处理程序中的异常。</p>
<p><code>try ... except 语句</code> 有一个可选的 <code>else 子句</code>，在使用时必须放在<strong>所有的 <code>except 子句</code> 后面</strong>。<strong>对于在try 子句不引发异常时必须执行的代码来说很有用。</strong></p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p><code>raise</code> 语句允许程序员强制发生指定的异常。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure>

<p><code>raise</code> 唯一的参数就是要抛出的异常。这个参数必须是一个异常实例或者是一个异常类（派生自 <code>Exception</code> 的类）。如果传递的是一个异常类，它将通过调用没有参数的构造函数来隐式实例化:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> ValueError  <span class="comment"># shorthand for 'raise ValueError()'</span></span><br></pre></td></tr></table></figure>

<p>如果你需要确定是否引发了异常但不打算处理它，则可以使用更简单的 <code>raise</code> 语句形式重新引发异常:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> NameError:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'An exception flew by!'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span></span><br><span class="line">...</span><br><span class="line">An exception flew by!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure>

<h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h3><p>程序可以通过创建新的异常类来命名它们自己的异常，异常通常应该直接或间接地从 <code>Exception</code> 类派生。</p>
<p>可以定义异常类，它可以执行任何其他类可以执行的任何操作，但通常保持简单，通常只提供许多属性，这些属性允许处理程序为异常提取有关错误的信息。在创建可能引发多个不同错误的模块时，通常的做法是为该模块定义的异常创建基类，并为不同错误条件创建特定异常类的子类。</p>
<p>大多数异常都定义为名称以“Error”结尾，类似于标准异常的命名。</p>
<h3 id="定义清理操作"><a href="#定义清理操作" class="headerlink" title="定义清理操作"></a>定义清理操作</h3><p>try 语句有另一个可选的 <code>finally 子句</code>，用于定义必须在所有情况下执行的清理操作。</p>
<p>如果存在 <code>finally 子句</code>，则 <code>finally 子句</code>将作为 try 语句结束前的最后一项任务被执行。 <strong><code>finally 子句</code> 不论 try 语句是否产生了异常都会被执行。</strong> 以下几点讨论了当异常发生时一些更复杂的情况：</p>
<ul>
<li>如果在执行 try 子句期间发生了异常，该异常可由一个 except 子句进行处理。 如果异常没有被某个 except 子句所处理，则该异常会在 <code>finally 子句</code> 执行之后被重新引发。</li>
<li>异常也可能在 except 或 else 子句执行期间发生。 同样地，该异常会在 <code>finally 子句</code> 执行之后被重新引发。</li>
<li>如果在执行 try 语句时遇到一个 break, continue 或 return 语句，则 <code>finally 子句</code> 将在执行 break, continue 或 return 语句之前被执行。</li>
<li>如果 <code>finally 子句</code> 中包含一个 return 语句，则返回值将来自 <code>finally 子句</code> 的某个 return 语句的返回值，而非来自 try 子句的 return 语句的返回值。</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>这一章节官方文档讲的有些晦涩，特别是“Python 作用域和命名空间”这一节，后来发现菜鸟教程对于这一部分的讲解还挺通俗易懂的，下面贴出相应网址：</p>
<ul>
<li><a href="https://www.runoob.com/python3/python3-class.html" target="_blank" rel="noopener">Python3 面向对象</a></li>
<li><a href="https://www.runoob.com/python3/python3-namespace-scope.html" target="_blank" rel="noopener">Python3 命名空间和作用域</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-02-27T07:06:24.177Z" itemprop="dateUpdated">2020-02-27 15:06:24</time>
</span><br>


        
        若有疑问或者本人有写的不对的地方, 欢迎留言或者直接邮箱反馈至yingzq0116@163.com, 非常感谢您的阅读~
        
    </div>
    
    <footer>
        <a href="https://www.yingzq.com">
            <img src="/img/avatar.jpg" alt="应子强">
            应子强
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag">阅读笔记</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/&title=《Python3.7.6官方教程阅读笔记》 — yingzq's Blog&pic=https://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/&title=《Python3.7.6官方教程阅读笔记》 — yingzq's Blog&source=最近想要复习一下Python一些基本的知识点，网上有着许许多多的Python学习教程，眼花缭乱，但是其实Python是有 官方中文文档 的，并且写的非常不..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python3.7.6官方教程阅读笔记》 — yingzq's Blog&url=https://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/&via=https://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/12/25/common-sorting-algorithms/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">常见排序算法（归纳分析及java实现）</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/11/18/the-annotated-transformer/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Transformer代码实现</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'true' == 'true',
            appId: "mGqkrgTscxf4JdcqkEHkFCfs-gzGzoHsz",
            appKey: "PwU9oOfhNnWOKaMaOTqQpiNW",
            avatar: "mm",
            placeholder: "要不要说点什么？",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>应子强 &copy; 2019 - 2020</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">京ICP备19041830号</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/&title=《Python3.7.6官方教程阅读笔记》 — yingzq's Blog&pic=https://www.yingzq.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/&title=《Python3.7.6官方教程阅读笔记》 — yingzq's Blog&source=最近想要复习一下Python一些基本的知识点，网上有着许许多多的Python学习教程，眼花缭乱，但是其实Python是有 官方中文文档 的，并且写的非常不..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python3.7.6官方教程阅读笔记》 — yingzq's Blog&url=https://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/&via=https://www.yingzq.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuklEQVR42u3ay3IbMQwEQP3/TztXVxxZMwApO1W9J5W0DzYOS2rAxyM+Pj4d7a9fz/l85tfPyZmHDzw8PLzF0L+/dXtOUoK2NPl48PDw8G7znt30+8/5+W3h8vu/sODh4eH9Al5+Tv4qb5fseHh4eP8jb/ZNGytsJic8PDy827w8Qm2DhjwI/uGsBQ8PD69btR54Qb/z85X+Hh4eHt66qz5rdG22IMzi4KejxcPDw7vAy1+4sxIkC+J2UV6XDw8PD++NvLbttAl222i4iDbw8PDwjvJmm0rPbplKppZ8unrktcHDw8Mb8ZJBtMvlzePrOa19Ch4eHt6aN2s1taFDPgltNhYMu3Z4eHh4I17yqm0LkcDa8tVTFx4eHt4FXnvr2Zq93QqQhxF5yfDw8PBu8IptTGUh2qh3szSPltd4eHh4C1672E3+6edxw37r6gs8Hh4e3gVe245qNxa0U87s1+FyHA8PD2/Bax88mzYSfNsYq9tgeHh4eId4eetrdtVsk9apPBYPDw/vBu9UQJBEsS21DU1ehLl4eHh4R3ntsGaDzjtybfBRhxF4eHh4I94+INgsl/MAN58S6grh4eHhlbz2MbOX+KyPn9/nxVSEh4eHd5SX/+FPJo88O82bW3lx//ENHh4e3gXe97fYtKM2QcYsjChSajw8PLxDvDYI2De09pu6ijACDw8P7xrvXrOqDSPaBfTTa/Hw8PDewsvj1NnGqYTRBsFR5fDw8PDWvI/yaK9ti5JHG1FIgYeHh3eBt5k88lAgaX21ZZq10/Dw8PBO8Ta3ToLadgqZLcRfbL3Cw8PDu8Bro4TZxqwD2clm0xUeHh7eD/Hy6SQJC9qoYrikxsPDw/tR3izY3US6s4Li4eHh3ebNYoL22lPtq2IjAh4eHt4F3uYPfz7Q5Jv23X49z8DDw8P7+/gD8YgNAf7MmDoAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来练习bug!';
            clearTimeout(titleTime);
        } else {
            document.title = 'yingzq's Blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
