{"meta":{"title":"yingzq's Blog","subtitle":"练习bug时长两年半的实习生","description":"交流NLP, 深度学习技术, 分享coding路上的风景","author":"应子强","url":"http://www.yingzq.com","root":"/"},"pages":[{"title":"about","date":"2019-09-22T13:14:01.000Z","updated":"2019-09-22T14:15:33.242Z","comments":true,"path":"about/index.html","permalink":"http://www.yingzq.com/about/index.html","excerpt":"","text":"Welcome to contact me at yingzq0116@163.com"},{"title":"","date":"2019-09-18T14:56:17.871Z","updated":"2019-09-18T14:56:17.871Z","comments":false,"path":"categories/index.html","permalink":"http://www.yingzq.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-18T14:56:25.333Z","updated":"2019-09-18T14:56:25.333Z","comments":false,"path":"tags/index.html","permalink":"http://www.yingzq.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"请务必掌握的Git基础","slug":"git-basics","date":"2019-10-01T05:03:38.000Z","updated":"2019-10-01T05:13:02.095Z","comments":true,"path":"2019/10/01/git-basics/","link":"","permalink":"http://www.yingzq.com/2019/10/01/git-basics/","excerpt":"Git是目前最流行的分布式版本控制系统，值得我们去学会使用并深入了解。本文将会介绍几个最基本的，也是最常用的命令，以后绝大多数时间里用到的可能也就是这几个命令，主要涉及Git的配置、Git仓库的获取、如何记录每次更新到Git仓库、提交历史的查看、Git的撤销操作、Git标签和Git别名等基础知识点，这些是你务必掌握的Git基础！","text":"Git是目前最流行的分布式版本控制系统，值得我们去学会使用并深入了解。本文将会介绍几个最基本的，也是最常用的命令，以后绝大多数时间里用到的可能也就是这几个命令，主要涉及Git的配置、Git仓库的获取、如何记录每次更新到Git仓库、提交历史的查看、Git的撤销操作、Git标签和Git别名等基础知识点，这些是你务必掌握的Git基础！ 前奏在开始阅读前，有几个需要注意的点： 如果你没听说过Git或者还不了解Git是什么，请参阅文章 What is Git 。 Git有多种使用方式，包括原生的和GUI模式，在这里推荐先使用并熟悉命令行模式，因为如果你学会了在命令行下如何操作，那么你在操作GUI软件时应该也不会遇到什么困难，但是，反之则不成立。 Git的安装在不同平台上Git安装的方式有一定差异，在这里不详细介绍。值得注意的是，虽然Git具有很好的向后兼容性，但是还是建议大家最好将它升级到最新的版本。 例如在Ubuntu系统中，可通过如下指令来安装最新稳定版本的Git： $ sudo apt-get install git 在mac系统中则可通过Homebrew来安装最新版本的Git： $ brew install git 更多的安装指导可查看 Installing Git 和 官方下载界面 。 安装完成后，输入指令git --version，返回正常的版本信息则证明已成功安装Git： $ git --versiongit version 2.21.0 注：因为Git的安装是非常方便快捷的，官网也有清晰的指导，所以这一章节讲的非常简略。 初次使用Git前的配置在第一次使用一个新编辑器的时候，你会倾向于把字体大小、界面还有需要的插件等统一配置一下，这样在你以后使用这个编辑器的时候，编辑器便会默认载入这些配置，非常的方便。 Git中也有类似的机制。Git自带一个git config的工具来帮助设置控制Git外观和行为的配置变量，这些变量存储在三个不同的位置： etc/gitconfig文件: 包含系统上每一个用户及他们仓库的通用配置。如果使用带有--system选项的git config时，它会从此文件读写配置变量。 ~/.gitconfig或~/.config/git/config文件：只针对当前用户。可以传递--global选项让Git读写此文件。 当前使用仓库的Git目录中的config文件（也就是.git/config）：针对该仓库。可以传递--local选项让Git读写此文件，但是其实这个选项是默认的，因此可以省略。 每一个级别覆盖上一级别的配置，例如.git/config的配置变量会覆盖/etc/gitconfig中的配置变量。 在Windows系统中，Git会查找$HOME目录下（一般情况下是 C:\\Users\\$USER）的.gitconfig文件。Git同样也会寻找/etc/gitconfig文件，但只限于MSys的根目录下，即安装Git时所选的目标位置。 用户信息首先你需要设置自己的用户名称和邮箱，这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改（换句话说，不设置用户信息无法进行git commit操作）： $ git config --global user.name &quot;YingZiqiang&quot;$ git config --global user.email yingzq0116@163.com 再次强调，如果使用了--global选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有--global选项的命令来配置。 文本编辑器当Git需要你输入信息时会调用默认的文本编辑器。如果未配置，Git会使用操作系统默认的文本编辑器，通常是Vim。如果你想使用不同的文本编辑器，例如Emacs，可以这样做： $ git config --global core.editor emacs 检查配置信息如果想要检查你的配置，可以使用git config --list命令来列出所有Git当时能找到的配置。 $ git config --listuser.name=YingZiqianguser.email=88629850@qq.compush.default=simple... 有时候会看到重复的变量名，因为Git可能会从多个配置文件中读取同一个配置变量。这种情况下，Git会使用它找到的每一个变量的最后一个配置。 可以通过输入git config &lt;key&gt;来检查Git的某一项配置： $ git config user.nameYingZiqiang 如果你想确认某配置变量的最终决定权的来源，可以输入git config --show-origin &lt;key&gt;查询： $ git config --show-origin user.namefile:/Users/yingzq/.gitconfig YingZiqiang Git帮助若你使用Git时需要获取帮助，有三种方法可以找到Git命令的使用手册： $ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; 例如，要想获得config命令的手册，执行 $ git help config 另外，如果你不想查看一个Git命令完整的使用手册，仅仅是想要快速查看某些参数的用法，可以通过-h选项来获得一个更加简洁的帮助界面，例如查看git add命令的参数信息： $ git add -h 注：你可以随时随地可以使用这些命令而无需联网 获取Git仓库有两种取得Git项目仓库的方法。第一种是在现有项目或目录下导入所有文件到Git中；第二种是从一个服务器克隆一个现有的Git仓库。 在现有目录中初始化仓库如果你打算使用Git来对现有的项目进行管理，你只需要进入该项目目录并输入： $ git init 该命令将创建一个名为.git的子目录，这个子目录含有你初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化Git仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。你可通过git add命令来实现对指定文件的跟踪，然后执行git commit提交： $ git add *.py$ git add LICENSE$ git commit -m &apos;initial project version&apos; 稍后会逐一解释每一条指令的意思。现在，你已经得到了一个实际维护（或者说是跟踪）着若干个文件的Git仓库。 克隆现有的仓库如果你想获得一份已经存在了的Git仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到git clone命令。 克隆仓库的命令格式是git clone [url]。比如，要克隆一个叫“TensorFlow-Examples”的库，可以用下面的命令： $ git clone https://github.com/aymericdamien/TensorFlow-Examples 这会在当前目录下创建一个名为“TensorFlow-Examples”的目录，并在这个目录下初始化一个.git文件夹，并从远程仓库拉取下所有数据放入.git文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的“TensorFlow-Examples”文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令： $ git clone https://github.com/aymericdamien/TensorFlow-Examples my-tf-examples 这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为“my-tf-examples”。 Git支持多种数据传输协议。上面的例子使用的是https://协议，不过你也可以使用git://协议或者使用例如user@server:path/to/repo.git的SSH传输协议。 注：Git克隆的是该Git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。当你执行git clone命令的时候，默认配置下远程Git仓库中的每一个文件的每一个版本都将被拉取下来。 记录每次更新到仓库现在我们手上有了一个真实项目的Git仓库，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。 工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。 图1：文件的状态变化周期 检查当前文件状态要查看哪些文件处于什么状态，可以用git status命令。如果在克隆仓库后立即使用此命令，会看到类似这样的输出： $ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.nothing to commit, working tree clean 这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则Git会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是“master”，这是默认的分支名。在这里不用担心不明白分支是什么，这一部分会在 Git的杀手锏：分支 单独讲解。 如果在项目中创建一个新的README文件，如果之前并不存在这个文件，使用git status命令，你将看到一个新的未跟踪文件： $ echo &apos;My Project&apos; &gt; README$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) READMEnothing added to commit but untracked files present (use &quot;git add&quot; to track) 在状态报告中可以看到新建的README文件出现在“Untracked files”下面。未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。不过现在的例子中，我们确实想要跟踪管理README这个文件。 跟踪新文件使用命令git add开始跟踪一个文件。所以如果要跟踪README文件，运行： $ git add README 此时再运行git status命令，会看到README文件已被跟踪，并处于暂存状态： $ git add READMEOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README 只要在“Changes to be committed”这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用git init后就运行了git add (files)命令，开始跟踪当前目录下的文件。git add命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 暂存已修改文件现在我们来修改一个已被跟踪的文件。如果你修改了一个名为TINY.md的已被跟踪的文件，然后运行git status命令，会看到下面内容： $ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.md 文件TINY.md出现在“Changes not staged for commit”这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行git add命令。git add是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行git add将TINY.md放到暂存区，然后再看看git status的输出： $ git add TINY.mdOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: TINY.md 现在两个文件都已暂存，下次提交时就会一并记录到仓库。 这里再追加一个小问题，假设此时，你的TINY.md文件存在一些小瑕疵，于是你重新编辑该文件并存盘了，此时运行git status会发生什么呢？ $ vim TINY.md$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: TINY.mdChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.md 怎么回事？现在TINY.md文件同时出现在暂存区和非暂存区。这怎么可能呢？实际上Git只不过暂存了你运行git add命令时的版本，如果你现在提交，TINY.md的版本是你最后一次运行git add命令时的那个版本，而不是你运行git commit时，在工作目录中的当前版本。 所以，运行了git add之后又作了修订的文件，需要重新运行git add把最新版本重新暂存起来： $ git add TINY.md$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: TINY.md 状态简览git status命令的输出十分详细，但其用语有些繁琐。如果你使用git status -s命令或git status --short命令，你将得到一种更为紧凑的格式输出。运行git status -s，状态报告输出如下： $ git status -sA READMEM TINY.md 新添加的未跟踪文件前面有??标记，新添加到暂存区中的文件前面有A标记，修改过的文件前面有M标记。其中M有两个可以出现的位置，出现在右边的M表示该文件被修改了但是还没放入暂存区，出现在靠左边的M表示该文件被修改了并放入了暂存区。 忽略文件一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为.gitignore的文件，列出要忽略的文件模式。来看一个实际的例子： $ cat .gitignore*.[oa]*~ 第一行告诉Git忽略所有以“.o”或“.a”结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。第二行告诉Git忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略log，tmp或者pid目录，以及自动生成的文档等等。要养成一开始就设置好.gitignore文件的习惯，以免将来误提交这类无用的文件。 文件.gitignore的格式规范如下： 所有空行或者以#开头的行都会被Git忽略。 可以使用标准的glob模式匹配，并且会在整个工作目录中递归的应用。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上感叹号（!）取反。 所谓的glob模式是指所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个a，要么匹配一个b，要么匹配一个c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9]表示匹配所有0到9的数字）。使用两个星号表示匹配任意中间目录，比如a/**/z可以匹配a/z,a/b/z或a/b/c/z等。 我们再看一个 .gitignore 文件的例子： # no .a files *.a # but do track lib.a, even though you&apos;re ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in the build/ directory build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory doc/**/*.pdf GitHub有一个十分详细的针对数十种项目及语言的.gitignore文件列表，你可以在 https://github.com/github/gitignore 找到它。 查看已暂存和未暂存的修改如果git status命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用git diff命令。 你可能通常会用git diff命令来回答这两个问题：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？尽管git status已经通过在相应栏下列出文件名的方式回答了这个问题，git diff将通过文件补丁的格式显示具体哪些行发生了改变。 假如此时你再次编辑TINY.md后不暂存，运行git status会看到： $ git statusYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: TINY.mdChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.md 要查看尚未暂存的文件更新了哪些部分，不加参数直接输入git diff，此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容： $ git diffdiff --git a/TINY.md b/TINY.mdindex 5818529..f0bfc69 100644--- a/TINY.md+++ b/TINY.md@@ -1,3 +1,3 @@ tiny data modify this file, we add one new line-fix something+add one line for test 若要查看已暂存的将要添加到下次提交里的内容，可以用git diff --cached命令（Git 1.6.1及更高版本还允许使用git diff --staged，效果是相同的，但更好记些），此命令是将目前已暂存的更改和上次提交的内容进行比较： $ git diff --stageddiff --git a/README b/READMEnew file mode 100644index 0000000..e69de29diff --git a/TINY.md b/TINY.mdindex f8f5ae1..5818529 100644--- a/TINY.md+++ b/TINY.md@@ -1 +1,3 @@ tiny data+modify this file, we add one new line+fix something 请注意，git diff本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。所以有时候你一下子暂存了所有更新过的文件后，运行git diff后却什么也没有，就是这个原因。 提交更新当你的暂存区域已经准备妥当便可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有git add过，否则提交的时候不会记录这些还没暂存起来的变化。这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用git status看下，是不是都已暂存起来了，然后再运行提交命令git commit： $ git commit 这种方式会启动默认的文本编辑器以便输入本次提交的说明，需要注意的是，如果输入的提交说明为空你的本次提交将会被中止。 更常用的方式是在commit命令后添加-m选项，将提交信息与命令放在同一行，如下所示： $ git commit -m &apos;add README file and fix some bugs in TINY.md&apos;[master 10114de] add README file and fix some bugs in TINY.md 2 files changed, 2 insertions(+) create mode 100644 README 现在你已经创建了第一个提交！可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整SHA-1校验和是什么（10114de），以及在本次提交中，有多少文件修订过，多少行添加和删改过。 请记住，提交时记录的是放在暂存区域的快照。任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给git commit加上-a选项，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add步骤： $ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)$ git commit -a -m &apos;test the commit -a option&apos;[master 45f06e1] test the commit -a option 1 file changed, 1 insertion(+), 1 deletion(-) 可以看到，提交之前不再需要git add文件TINY.md了。 移除文件要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用git rm命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 如果只是简单地从工作目录中手工删除文件，运行git status时就会在“Changes not staged for commit”部分（也就是未暂存清单）看到： $ rm TINY.md$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: TINY.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 然后再运行git rm记录此次移除文件的操作： $ git rm TINY.md$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: TINY.md 下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项-f（即force的首字母）。这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被Git恢复。 另外一种情况是，我们想把文件从暂存区域移除，但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，但是并不想让Git继续跟踪。当你忘记添加.gitignore文件，不小心把一个很大的日志文件或一堆.a这样的编译生成文件添加到暂存区时，这一做法尤其有用。为达到这一目的，使用--cached选项： $ git rm --cached README git rm命令后面可以列出文件或者目录的名字，也可以使用glob模式。例如： $ git rm log/\\*.log 注意到星号*之前的反斜杠\\，这是非常有必要的，因为除了拥有shell的文件模式扩展匹配方式，Git还有它自己的文件模式扩展匹配方式。 此命令会删除log/目录及其子目录下扩展名为.log的所有文件。 移动文件不像其它的VCS系统，Git并不显式跟踪文件移动操作。如果在Git中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过Git非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，可以放到以后再详细了解。 要在Git中对文件改名，可以这么做： $ git mv file_from file_to 此时查看状态信息，可以明白无误地看到关于重命名操作的说明： $ git mv TINY.md MY-TOY.md$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) renamed: TINY.md -&gt; MY-TOY.md 其实，运行git mv就相当于运行了下面三条命令： $ mv TINY.md MY-TOY.md$ git rm TINY.md$ git add MY-TOY.md 如此分开操作，Git也会意识到这是一次改名，所以不管何种方式结果都一样，但是git mv一个命令代替了第二种方式的三个命令，更加的轻便。更进一步，你可以使用任何你熟悉的工具来重命名文件，然后只需要记得在提交前，删除老的文件名并添加新的文件名。 查看提交历史在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。完成这个任务最简单而又有效的工具是git log命令。 首先运行下面的命令获取用于演示的simplegit项目的源代码： $ git clone https://github.com/schacon/simplegit-progit 然后在此项目中运行git log，应该会看到下面的输出： $ git logcommit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the verison numbercommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test codecommit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Sat Mar 15 10:31:28 2008 -0700 first commit 默认不用任何参数的话，git log会按提交时间列出所有的更新，最近的更新排在最上面。正如你所看到的，这个命令会列出每个提交的SHA-1校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 git log有许多选项可以帮助你搜寻你所要找的提交， 接下来我们先来了解一些最常用的选项。 一个常用的选项是-p或者说是--patch，用来显示每次提交的内容差异（the patch output）。你也可以限制展示的提交条目数，例如可以加上-2来仅显示最近两次提交： $ git log -p -2commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the verison numberdiff --git a/Rakefile b/Rakefileindex a874b73..8f94139 100644--- a/Rakefile+++ b/Rakefile@@ -5,7 +5,7 @@ require &apos;rake/gempackagetask&apos; spec = Gem::Specification.new do |s| s.platform = Gem::Platform::RUBY s.name = &quot;simplegit&quot;- s.version = &quot;0.1.0&quot;+ s.version = &quot;0.1.1&quot; s.author = &quot;Scott Chacon&quot; s.email = &quot;schacon@gmail.com&quot; s.summary = &quot;A simple gem for using Git in Ruby code.&quot;commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test codediff --git a/lib/simplegit.rb b/lib/simplegit.rbindex a0a60ae..47c6340 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -18,8 +18,3 @@ class SimpleGit end end--if $0 == __FILE__- git = SimpleGit.new- puts git.show-end\\ No newline at end of file 该选项除了显示基本信息之外，还附带了每次commit的变化。当进行代码审查，或者快速浏览某个搭档提交的commit所带来的变化的时候，这个参数就非常有用了。你也可以为git log附带一系列的总结性选项。比如说，如果你想看到每次提交的简略的统计信息，你可以使用--stat选项： $ git log --statcommit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin/master, origin/HEAD)Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the verison number Rakefile | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test code lib/simplegit.rb | 5 ----- 1 file changed, 5 deletions(-)commit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Sat Mar 15 10:31:28 2008 -0700 first commit README | 6 ++++++ Rakefile | 23 +++++++++++++++++++++++ lib/simplegit.rb | 25 +++++++++++++++++++++++++ 3 files changed, 54 insertions(+) 正如你所看到的，--stat选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。在每次提交的最后还有一个总结。 另外一个常用的选项是--pretty。这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用。比如用oneline将每个提交放在一行显示，查看的提交数很大时非常有用。 git log还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。例如之前看到的-2其实是-&lt;n&gt;选项的写法，其中的n可以是任何整数，表示仅显示最近的若干条提交；另外还有按照时间作限制的选项，比如--since和--until也很有用，还可以给出若干搜索条件，列出符合的提交… git log的选项非常多，在这里不再一一介绍。总之，git log是一个功能非常齐全、可定制化程度非常高的、能满足你几乎所有查询方式的查看提交历史的命令。 撤消操作在任何一个阶段，你都有可能想要撤消某些操作。这里，我们将会学习几个撤消你所做修改的基本工具。注意，有些撤消操作是不可逆的，这是在使用Git的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有--amend选项的提交命令尝试重新提交： $ git commit --amend 这个命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。 运行该命令后会启动文本编辑器，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。 例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作： $ git commit -m &apos;initial commit&apos;$ git add forgotten_file$ git commit --amend 最终你只会有一个提交——第二次提交将代替第一次提交的结果。 接下来再来学习一下如何操作暂存区域与工作目录中已修改的文件。这些命令在修改文件状态的同时，也会提示如何撤消操作。 取消暂存的文件如果你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了git add *暂存了它们两个。如何只取消暂存两个中的一个呢？git status命令提示了你： $ git add *$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: README modified: TINY.md 在“Changes to be committed”文字正下方，提示使用git reset HEAD &lt;file&gt;...来取消暂存。所以，我们可以这样来取消暂存TINY.md文件： $ git reset HEAD TINY.mdOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.md 可以看到TINY.md文件已经是修改未暂存的状态了。 撤消对文件的修改如果你并不想保留对TINY.md文件的修改怎么办？你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？幸运的是，git status也告诉了你应该如何做。在最后一个例子中，未暂存区域是这样： Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.md 它非常清楚地告诉了你如何撤消之前所做的修改。让我们来按照提示执行： $ git checkout -- TINY.md$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: README 可以看到关于TINY.md的修改已经被撤消了。 请记住，在Git中任何已提交的东西几乎总是可以恢复的。甚至那些被删除的分支中的提交或使用--amend选项覆盖的提交也可以恢复。然而，任何你未提交的东西丢失后很可能再也找不到了。 远程仓库的使用为了能在任意Git项目上协作，你需要知道如何管理自己的远程仓库。远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。在本章节中，将介绍一部分基础的远程管理技能。 查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行git remote命令。它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到origin——这是Git给你克隆的仓库服务器的默认名字 $ git clone https://github.com/schacon/ticgitCloning into &apos;ticgit&apos;...remote: Enumerating objects: 1857, done.remote: Total 1857 (delta 0), reused 0 (delta 0), pack-reused 1857Receiving objects: 100% (1857/1857), 334.04 KiB | 36.00 KiB/s, done.Resolving deltas: 100% (837/837), done.$ cd ticgit$ git remoteorigin 你也可以指定选项-v，会显示需要读写远程仓库使用的Git保存的简写与其对应的URL。 $ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push) 如果你的远程仓库不止一个，该命令会将它们全部列出。例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样： $ cd grit$ git remote -vbakkdoor https://github.com/bakkdoor/grit (fetch)bakkdoor https://github.com/bakkdoor/grit (push)cho45 https://github.com/cho45/grit (fetch)cho45 https://github.com/cho45/grit (push)defunkt https://github.com/defunkt/grit (fetch)defunkt https://github.com/defunkt/grit (push)koke git://github.com/koke/grit.git (fetch)koke git://github.com/koke/grit.git (push)origin git@github.com:mojombo/grit.git (fetch)origin git@github.com:mojombo/grit.git (push) 这样我们可以轻松拉取其中任何一个用户的贡献。此外，我们大概还会有某些远程仓库的推送权限，不过暂时不在此介绍。 添加远程仓库运行git remote add &lt;shortname&gt; &lt;url&gt;添加一个新的远程Git仓库，同时指定一个你可以轻松引用的简写： $ git remoteorigin$ git remote add pb https://github.com/paulboone/ticgit$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push)pb https://github.com/paulboone/ticgit (fetch)pb https://github.com/paulboone/ticgit (push) 现在你可以在命令行中使用字符串pb来代替整个URL。例如，如果你想拉取Paul的仓库中有但你没有的信息，可以运行git fetch pb： $ git fetch pbremote: Enumerating objects: 22, done.remote: Counting objects: 100% (22/22), done.remote: Total 43 (delta 22), reused 22 (delta 22), pack-reused 21Unpacking objects: 100% (43/43), done.From https://github.com/paulboone/ticgit * [new branch] master -&gt; pb/master * [new branch] ticgit -&gt; pb/ticgit 现在Paul的master分支可以在本地通过pb/master访问到——你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 关于什么是分支以及如何使用分支将会在 Git的杀手锏：分支 中详细介绍 从远程仓库中抓取与拉取就如刚才所见，从远程仓库中获得数据，可以执行： $ git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用clone命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以“origin”为简写。所以，git fetch origin会抓取克隆（或上一次抓取）后新推送的所有工作。必须注意git fetch命令会将数据拉取到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 如果你有一个分支设置为跟踪一个远程分支，可以使用git pull命令来自动的抓取然后合并远程分支到当前分支。这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone命令会自动设置本地master分支跟踪克隆的远程仓库的master分支（或不管是什么名字的默认分支）。运行git pull通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程仓库当你想分享你的项目时，必须将其推送到上游。这个命令很简单：git push [remote-name] [branch-name]。当你想要将master分支推送到origin服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器： $ git push origin master 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。阅读 Git的杀手锏：分支 了解如何推送到远程仓库服务器的详细信息。 查看某个远程仓库如果想要查看某一个远程仓库的更多信息，可以使用git remote show [remote-name]命令。如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息： $ git remote show origin* remote origin Fetch URL: https://github.com/schacon/ticgit Push URL: https://github.com/schacon/ticgit HEAD branch: master Remote branches: master tracked ticgit tracked Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (up to date) 它同样会列出远程仓库的URL与跟踪分支的信息。这些信息非常有用，它告诉你正处于master分支，并且如果运行git pull，就会抓取所有的远程引用，然后将远程master分支合并到本地master分支。它也会列出拉取到的所有远程引用。 这是一个经常遇到的简单例子。如果你是Git的重度使用者，那么还可以通过git remote show看到更多的信息： $ git remote show origin* remote origin URL: https://github.com/my-org/complex-project Fetch URL: https://github.com/my-org/complex-project Push URL: https://github.com/my-org/complex-project HEAD branch: master Remote branches: master tracked dev-branch tracked markdown-strip tracked issue-43 new (next fetch will store in remotes/origin) issue-45 new (next fetch will store in remotes/origin) refs/remotes/origin/issue-11 stale (use &apos;git remote prune&apos; to remove) Local branches configured for &apos;git pull&apos;: dev-branch merges with remote dev-branch master merges with remote master Local refs configured for &apos;git push&apos;: dev-branch pushes to dev-branch (up to date) markdown-strip pushes to markdown-strip (up to date) master pushes to master (up to date) 这个命令列出了当你在特定的分支上执行git push会自动地推送到哪一个远程分支。它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行git pull时哪些分支会自动合并。 远程仓库的移除与重命名如果想要重命名引用的名字可以运行git remote rename去修改一个远程仓库的简写名。例如，想要将pb重命名为paul，可以用git remote rename这样做： $ git remote rename pb paul$ git remoteoriginpaul 值得注意的是这同样也会修改你的远程分支名字。那些过去引用pb/master的现在会引用paul/master。 如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用git remote rm： $ git remote rm paul$ git remoteorigin 打标签像其他版本控制系统（VCS）一样，Git可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。在本章节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。 列出标签在Git中列出已有的标签是非常简单直观的。只需要输入git tag： $ git tagv0.1v1.3 这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。 你也可以使用特定的模式查找标签。例如，Git自身的源代码仓库包含标签的数量超过500个。如果只对1.8.5系列感兴趣，可以运行： $ git tag -l &apos;v1.8.5*&apos;v1.8.5v1.8.5-rc0v1.8.5-rc1v1.8.5-rc2v1.8.5-rc3v1.8.5.1v1.8.5.2v1.8.5.3v1.8.5.4v1.8.5.5 注：如果你只是想要列出全部的标签，-l或者--list选项可以省略；但是如果是希望用特定的模式查找标签，-l或--list选项则是必须的 创建标签Git使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。 一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。 然而，附注标签是存储在Git数据库中的一个完整对象。它们是可以被校验的：其中包含打标签者的名字、电子邮件地址、日期时间，还有一个标签信息，并且可以使用GNU Privacy Guard （GPG）签名与验证。通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。 附注标签在Git中创建一个附注标签是很简单的。最简单的方式是当你在运行tag命令时指定-a选项： $ git tag -a v1.4 -m &quot;my version 1.4&quot;$ git tagv0.1v1.3v1.4 -m选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会运行编辑器要求你输入信息。 通过使用git show命令可以看到标签信息与对应的提交信息： $ git show v1.4tag v1.4Tagger: Ben Straub &lt;ben@straub.cc&gt;Date: Sat May 3 20:19:12 2014 -0700my version 1.4commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。 轻量标签另一种给提交打标签的方式是使用轻量标签。轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用-a、-s或-m选项，只需要提供标签名字： $ git tag v1.4-lw$ git tagv0.1v1.3v1.4v1.4-lwv1.5 这时，如果在标签上运行git show，你不会看到额外的标签信息。命令只会显示出提交信息： $ git show v1.4-lwcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 后期打标签你也可以对过去的提交打标签。假设提交历史是这样的： $ git log --pretty=oneline15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &apos;experiment&apos;a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support0d52aaab4479697da7686c15f77a3d64d9165190 one more thing6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &apos;experiment&apos;0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function4682c3261057305bdd616e23b64b0857d832627b added a todo file166ae0c4d3f420721acbb115cc33848dfcc2121a started write support9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme 现在，假设在v1.2时你忘记给项目打标签，也就是在“updated rakefile”提交。你可以在之后补上标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）： $ git tag -a v1.2 9fceb02 -m &apos;my version v1.2&apos; 共享标签默认情况下，git push命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样——你可以运行git push origin [tagname]。 $ git push origin v1.5Counting objects: 14, done.Delta compression using up to 8 threads.Compressing objects: 100% (12/12), done.Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.Total 14 (delta 3), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag] v1.5 -&gt; v1.5 如果想要一次性推送很多标签，也可以使用带有--tags选项的git push命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。 $ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag] v1.4 -&gt; v1.4 * [new tag] v1.4-lw -&gt; v1.4-lw 现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。 删除标签要删除掉你本地仓库上的标签，可以使用命令git tag -d &lt;tagname&gt;。例如，可以使用下面的命令删除掉一个轻量级标签： $ git tag -d v1.4-lwDeleted tag &apos;v1.4-lw&apos; (was e7d5add) 应该注意的是上述命令并不会从任何远程仓库中移除这个标签，有两种方式可以从远程仓库中删除标签。 第一种方式是使用git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;来更新你的远程仓库： $ git push origin :refs/tags/v1.4-lwTo /git@github.com:schacon/simplegit.git - [deleted] v1.4-lw 第二种删除远程仓库标签的方式更加直观： $ git push origin --delete &lt;tagname&gt; 检出标签如果你想查看某个标签所指向的文件版本，可以使用git checkout命令。但是这会使你的仓库处于“分离头指针（detacthed HEAD）”状态，这个状态有些不好的副作用：如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。 因此，如果你需要进行更改——比如说你正在修复旧版本的错误——这通常需要创建一个新分支来进行操作。 Git别名有一个小技巧可以使你的Git体验更简单、容易、熟悉：别名 Git并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的Git命令，可以通过git config来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试： $ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status 这意味着，当要输入git commit时，只需要输入git ci。随着你继续不断地使用Git，可能也会经常使用其他命令，此时不要犹豫，为它创建一个别名吧。 在创建你认为应该存在的命令时这个技术也会很有用。例如，为了解决取消暂存文件的易用性问题，可以向Git中添加你自己的取消暂存别名： $ git config --global alias.unstage &apos;reset HEAD --&apos; 这会使下面的两个命令等价： $ git unstage fileA$ git reset HEAD -- fileA 这样看起来更清楚一些。通常也会添加一个last命令，像这样： $ git config --global alias.last &apos;log -1 HEAD&apos; 这样，可以轻松地看到最后一次提交： $ git lastcommit 66938dae3329c7aebe598c2246a8e6af90d04646Author: Josh Goebel &lt;dreamer3@example.com&gt;Date: Tue Aug 26 19:48:51 2008 +0800 test for current head Signed-off-by: Scott Chacon &lt;schacon@example.com&gt; 可以看出，Git只是简单地将别名替换为对应的命令。然而，你可能想要执行外部命令，而不是一个Git子命令。如果是那样的话，可以在命令前面加入!符号。如果你自己要写一些与Git仓库协作的工具的话，那会很有用。例如将git visual定义为gitk的别名： $ git config --global alias.visual &apos;!gitk&apos; 总结本文介绍的Git的内容的确不少，但是这些都是你学习Git务必要掌握的基础。随着你对Git的使用越来越多，你会发现Git的每一个命令都是精简而高效的，他们使得你对文件版本控制变得异常方便快捷。 Just do it! 参考文献 Pro Git Book Git Documents","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.yingzq.com/tags/Git/"}]},{"title":"Git的杀手锏：分支","slug":"git-branching","date":"2019-09-27T09:11:55.000Z","updated":"2019-10-01T05:22:18.276Z","comments":true,"path":"2019/09/27/git-branching/","link":"","permalink":"http://www.yingzq.com/2019/09/27/git-branching/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Pandas入门","slug":"pandas-getting-started","date":"2019-09-22T12:54:20.000Z","updated":"2019-09-24T03:11:19.037Z","comments":true,"path":"2019/09/22/pandas-getting-started/","link":"","permalink":"http://www.yingzq.com/2019/09/22/pandas-getting-started/","excerpt":"","text":"","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://www.yingzq.com/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"http://www.yingzq.com/tags/Python/"}]},{"title":"NumPy入门","slug":"numpy-getting-started","date":"2019-09-22T12:53:26.000Z","updated":"2019-09-24T03:11:21.860Z","comments":true,"path":"2019/09/22/numpy-getting-started/","link":"","permalink":"http://www.yingzq.com/2019/09/22/numpy-getting-started/","excerpt":"","text":"","categories":[],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://www.yingzq.com/tags/Machine-Learning/"},{"name":"Python","slug":"Python","permalink":"http://www.yingzq.com/tags/Python/"}]},{"title":"The Annotated Transformer","slug":"the-annotated-transformer","date":"2019-09-22T08:22:27.000Z","updated":"2019-09-22T14:18:32.888Z","comments":true,"path":"2019/09/22/the-annotated-transformer/","link":"","permalink":"http://www.yingzq.com/2019/09/22/the-annotated-transformer/","excerpt":"将要进行…","text":"将要进行… 2017年6月Google发表论文“Attention is All You Need”，","categories":[],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://www.yingzq.com/tags/NLP/"},{"name":"Transformer","slug":"Transformer","permalink":"http://www.yingzq.com/tags/Transformer/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://www.yingzq.com/tags/Deep-Learning/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://www.yingzq.com/tags/PyTorch/"}]},{"title":"What is Git","slug":"what-is-git","date":"2019-09-18T14:19:30.000Z","updated":"2019-09-27T14:31:21.764Z","comments":true,"path":"2019/09/18/what-is-git/","link":"","permalink":"http://www.yingzq.com/2019/09/18/what-is-git/","excerpt":"相信写过代码的程序猿们都听说过Git的大名，哪怕是刚刚入门的小白，也在GitHub等代码托管网站git clone过他人的代码。那么什么是Git呢？本文将为你讲述Git的前世往生，看完本文，你应该会对版本控制、Git的诞生、Git基本概念和Git的基本特性有了一个初步的认识。","text":"相信写过代码的程序猿们都听说过Git的大名，哪怕是刚刚入门的小白，也在GitHub等代码托管网站git clone过他人的代码。那么什么是Git呢？本文将为你讲述Git的前世往生，看完本文，你应该会对版本控制、Git的诞生、Git基本概念和Git的基本特性有了一个初步的认识。 注：本文只包含了Git的相关概念，不包含任何命令行代码。 关于版本控制首先来了解一下什么是“版本控制”：版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。一般情况下是针对程序的源代码文件进行版本控制，但实际上你可以对任何类型的文件进行版本控制。 本地版本控制系统许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。 为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异（见图1）。 图1：本地版本控制系统 其中最流行的一种叫做RCS（Revision Control System），现今许多计算机系统上都还看得到它的踪影。甚至在流行的Mac OS X系统上安装了开发者工具包之后，也可以使用rcs命令。它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，便可以重新计算出各个版本的文件内容。 集中化的版本控制系统接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作呢？于是，集中化的版本控制系统（Centralized Version Control Systems，简称CVCS）应运而生。 这类系统，诸如CVS、Subversion以及Perforce等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法（见图2）。 图2：集中化的版本控制系统 这种做法带来了许多好处，特别是相较于老式的本地VCS来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个CVCS要远比在各个客户端上维护本地数据库来得轻松容易。 事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。 分布式版本控制系统为了解决上述版本控制系统存在的问题，分布式版本控制系统（Distributed Version Control System，简称DVCS）诞生了。 在这类系统中，像Git、Mercurial、Bazaar以及Darcs等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份（见图3）。 图3：分布式版本控制系统 更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。 小结：可以看出分布式版本控制系统相比于本地版本控制和集中化的版本控制有着非常明显的优点。Git就是一个典型的分布式版本控制系统（DVCS）。 Git的诞生同生活中的许多伟大事物一样，Git诞生于一个极富纷争大举创新的年代。 1991年，22岁芬兰程序员Linus Torvalds（后文简称Linus）开源了Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 图4：Linus Torvalds Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 小节：Linux的诞生是因为当时还是大学生的Linus觉得好玩编写并开源的；而Git的诞生则是因为Linux社区刚好需要，所以Linus花了两周简单写了一下并开源的，可能这就是大佬吧… Git的基本特性我们已经知道Git是一种分布式版本控制系统，那么Git与其他的版本控制系统的差异是什么？自身的的特性又是什么呢？ Git直接记录快照，而非差异比较Git和其它版本控制系统（包括Subversion和近似工具）的主要差别在于Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（CVS、Subversion、Perforce、Bazaar等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异（见图5）。 图5：存储每个文件与初始版本的差异 Git不按照以上方式对待或保存数据。反之，Git更像是把数据看作是对小型文件系统的一组快照（snapshot）。每次你提交更新，或在Git中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git不再重新存储该文件，而是只保留一个链接指向之前存储的文件（见图6）。Git对待数据更像是一个快照流。 图6：存储项目随时间改变的快照 这是Git与几乎所有其它版本控制系统的重要区别。Git更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的VCS。如果你刚刚接触VCS和Git，可能对这句话感触并不深，但是随着你对Git的了解越来越深入，例如在研究Git分支的管理时，会发现这种方式对待数据所能获得的巨大益处。 Git近乎所有操作都是本地执行在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git在这方面会让你感到速度之神赐给了Git超凡的能量。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。 举个例子，要浏览项目的历史，Git不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。 这也意味着你离线或者没有VPN时，几乎可以进行任何操作。如你在飞机或火车上想做些工作，你能愉快地提交，直到有网络连接时再上传。如你回家后VPN客户端不正常，你仍能工作。使用其它系统，做到如此是不可能或很费力的。比如，用Perforce，你没有连接服务器时几乎不能做什么事；用Subversion和CVS，你能修改文件，但不能向数据库提交修改（因为你的本地数据库离线了）。这看起来不是大问题，但是你可能会惊喜地发现它带来的巨大的不同。 Git保证完整性Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。这个功能建构在Git底层，是构成Git哲学不可或缺的部分。若你在传送过程中丢失信息或损坏文件，Git就能发现。 Git用以计算校验和的机制叫做SHA-1散列。这是一个由40个十六进制字符（0-9和a-f）组成的字符串，基于Git中文件的内容或目录结构计算出来。SHA-1哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373Git一般只添加数据你执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。同别的VCS一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到Git中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。 Git文件有三种状态请注意，如果你希望后面的学习过程更加顺利，这里将是关于Git你最需要记住的一点——对于任何一个文件，在Git内都只有三种状态：已修改（modified），已暂存（staged）和已提交（committed）。 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 已提交表示数据已经安全的保存在本地数据库中 由此引入Git项目的三个工作区域的概念：工作目录、暂存区域以及Git仓库。 图7：工作目录、暂存区域以及Git仓库 工作目录是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。 Git仓库目录是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 基本的Git工作流程如下： 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录 如果Git目录中保存着特定版本的文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 总结你应该已经对Git是什么、Git与你可能正在使用的集中式版本控制系统有何区别等问题有了基本的了解。对于Git的特性，本文也只是简单提及，它的分支管理、代码合并等功能更让人欲罢不能。如今Git已经成为了最流行的开源分布式版本控制系统，它值得你去深入探索研究! 参考文献 Pro Git Book 廖雪峰 Git教程","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.yingzq.com/tags/Git/"}]}]}