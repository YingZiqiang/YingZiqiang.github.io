{"meta":{"title":"yingzq's Blog","subtitle":"练习bug时长两年半的实习生","description":"交流NLP, 深度学习技术, 分享coding路上的风景","author":"应子强","url":"http://www.yingzq.com","root":"/"},"pages":[{"title":"about","date":"2019-09-22T13:14:01.000Z","updated":"2019-09-22T14:15:33.242Z","comments":true,"path":"about/index.html","permalink":"http://www.yingzq.com/about/index.html","excerpt":"","text":"Welcome to contact me at yingzq0116@163.com"},{"title":"","date":"2019-09-18T14:56:25.333Z","updated":"2019-09-18T14:56:25.333Z","comments":false,"path":"tags/index.html","permalink":"http://www.yingzq.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-18T14:56:17.871Z","updated":"2019-09-18T14:56:17.871Z","comments":false,"path":"categories/index.html","permalink":"http://www.yingzq.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"对 “旋转排序数组” 相关问题的解决方法","slug":"solution-for-rotated-sorted-array","date":"2020-03-16T12:39:25.000Z","updated":"2020-03-17T05:28:51.972Z","comments":true,"path":"2020/03/16/solution-for-rotated-sorted-array/","link":"","permalink":"http://www.yingzq.com/2020/03/16/solution-for-rotated-sorted-array/","excerpt":"在LeetCode以及各种笔试、面经中经常会看到这样的有序数组的定义：假设按照升序排序的数组在预先未知的某个点上进行了旋转 ，我们暂且称之为 旋转排序数组。基于 旋转排序数组，可以考察许多看起来简单但是似乎又没那么简单的问题：求出其中最小值或者最大值的位置，给定一个 target 求出该数组中是否存在、若存在具体在哪个位置… 本文介绍一种解决 旋转排序数组 问题的思考方法，希望能够帮助大家理解这类问题。","text":"在LeetCode以及各种笔试、面经中经常会看到这样的有序数组的定义：假设按照升序排序的数组在预先未知的某个点上进行了旋转 ，我们暂且称之为 旋转排序数组。基于 旋转排序数组，可以考察许多看起来简单但是似乎又没那么简单的问题：求出其中最小值或者最大值的位置，给定一个 target 求出该数组中是否存在、若存在具体在哪个位置… 本文介绍一种解决 旋转排序数组 问题的思考方法，希望能够帮助大家理解这类问题。 初步思考根据旋转排序数组的定义可以知道，数组在未旋转的是一个升序数组，例如[0,1,2,4,5,6,7]，但是在未知的某个位置发生了旋转，所以数组可能变成了[6,7,0,1,2,4,5]，也可能变成了[2,4,5,6,7,0,1]，也有可能不发生变化（极端情况）。 数组中查找target问题在升序数组中查找 target 是否存在的问题我们往往使用二分搜索，二分搜索充分利用了数组的有序性，将时间复杂度缩减到$O(\\log n)$。那么对于旋转排序数组呢？可以看出，在全局来看已经不是一个升序数组了，那么对于查找 target 的任务，我们可以将它当做一个无序数组，从头到尾遍历数组，这样的话便可以利用$O(n)$的时间复杂度完成该任务。 但是这样将旋转排序数组当做无序数组是一个不太好的近似，因为虽然旋转排序数组整体来看不是有序的，但是满足局部有序性：[4,5,6,7,0,1,2]中左边部分的[4,5,6,7]和右边部分的[0,1,2]分别都是有序的。我们知道有序性对于查找来说是致命的诱惑，所以我们能否利用这一点呢？ 先来看一下在旋转排序数组进行一次二分查找的结果： 旋转排序数组的二分查找 这里有且仅有三种情景，同样来升序数组[0,1,2,4,5,6,7]来举例。 第一种情景就是数组刚好不发生改变，可以看出经过mid = lo + (hi - lo) / 2的操作，数组会被mid=4分成了左右两个有序的数组，分别是[0,1,2]和[5,6,7]且两边范围不相交。 第二种情景是数组变成了[2,4,5,6,7,0,1]，此时mid=6将数组分成了[2,4,5]和[7,0,1]，此时只有左半部分是有序的，右半部分整体上看无序且范围与左半部分不相交。 第三种情景是数组变成了[6,7,0,1,2,4,5]，此时mid=1将数组分成了6,7,0和[2,4,5]，此时则只有右半部分是有序的，左半部分整体上看无序且范围与右半部分不相交。 通过这三种情景可以看出，旋转排序数组进行二分查找的时候，至少有一边是有序的，并且我们可以通过nums[lo], nums[mid], nums[hi]的相对大小来判别当前是哪种情景，所以可以这样进行查找 target 的任务： 如果nums[mid] == target，查找成功，直接返回。 如果nums[lo] &lt;= nums[mid]，此时是情景一或者情景二，两者的左半部分是有序的，所以可以： 先查找target是否在左半部分，因为有序，直接使用target &gt;= nums[lo] &amp;&amp; target &lt; nums[mid]判断，如果为true，则无需搜索右半部分了（因为两部分范围不相交），令hi = mid - 1，将范围缩小至左半部分。 如果为false则排除了左半部分，但是此时并不能确定右半部分的情况（因为无序），因此我们令lo = mid + 1，将范围缩小至右半部分等待下一次查找。 如果nums[lo] &gt; nums[mid]，此时是情景三，它的右半部分是有序的，所以可以： 先利用target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]查找右半部分，若为true则令lo = mid + 1。 如果为false则接着在左半部分查找，因为左半部分无序，所以令hi = mid - 1等待下一次查找。 上面是用了nums[lo]和nums[mid]作比较，其实用nums[mid]和nums[hi]作比较也是同样的道理，都可以借助两者的相对大小将情况分为左半有序的情况和右半有序的情况，具体流程如下： 如果nums[mid] == target，查找成功，直接返回。 如果nums[mid] &lt; nums[hi]，此时是情景一或者情景三，两者的右半部分是有序的，所以可以： 先查找target是否在右半部分，因为有序，直接使用target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]判断，如果为true，则无需搜索左半部分了（因为两部分范围不相交），令lo = mid + 1，将范围缩小右半部分。 如果为false则排除了右半部分，但是此时并不能确定左半部分的情况（因为无序），因此我们令hi = mid - 1，将范围缩小至左半部分等待下一次查找。 如果nums[mid] &gt; nums[hi]，此时是情景二，它的左半部分是有序的，所以可以： 先利用target &gt; nums[lo] &amp;&amp; target &lt;= nums[mid]查找左半部分，若为true则令hi = mid - 1。 如果为false则接着在右半部分查找，因为右半部分无序，所以令lo = mid + 1等待下一次查找。 值得注意的是，这是不考虑数组中有重复元素的情况。那么如果存在重复元素元素应该如何处理呢，例如对于[2,0,2,2,2], target=0？ 当利用nums[lo], nums[mid]相比较的时候，和上面唯一的区别是当nums[lo] == nums[mid]时并不能保证左半部分是有序的，所以需要额外处理，注意到此时nums[mid] != target -&gt; nums[lo] != target，所以我们可以知道此时nums[lo]肯定不是要找的结果，所以可以令lo++，然后等待下一次查找，但是如果每次都遇到这样的情况那么时间复杂度就退化成了$O(n)$。 当利用nums[mid], nums[hi]相比较的时候其实很类似，就是当nums[mid] == nums[hi]的时候进行hi--即可。 其实重复元素的处理还有更好的方案，那就是利用双边进行比较，即同时利用nums[lo]和nums[hi]，这样可以尽可能的优化性能，但是提升并不大，代码复杂了许多，本文就不深入分析了。 数组中最小最大元素的问题针对旋转排序数组，还有一类问题是找出其中最小元素或者最大元素的位置。 就拿寻找最小元素来说，我们简单分析一下：当最小值索引在mid的左边时，对应的是情景一和情景三；当最小值索引在mid的右边时对应的是情景二。所以我们只需要把情景二和情景一、情景三区分开就可以判别需要继续搜寻的范围了。 如何区分呢？利用nums[mid]和nums[hi]的相对大小即可，思路如下： 如果nums[mid] &lt;= nums[hi]，此时是情景一和情景三，最小值索引在mid左边（也可能就是mid），所以令hi = mid 如果nums[mid] &gt; nums[hi]，此时是情景二，最小值索引在mid右边，所以令lo = mid + 1 终止条件：lo == hi，返回lo或nums[lo]，看题目需求。 如果有重复元素呢？其实也是当nums[mid] == nums[hi]的时候需要特殊处理，因为这个时候不能确定是哪种情景。但是由于终止条件是lo == hi，因此此时肯定有mid &lt; hi &amp;&amp; nums[mid] == nums[hi]，那我们此时进行hi--是不影响最终结果的。 对于求最大元素，思路基本一致，具体差别可以看下面例题。 例题接下来看几道LeetCode的例题，用代码实现上面的思想。 搜索旋转排序数组题目链接 LeetCode 33 搜索旋转排序数组 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例：输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0输出: 4输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3输出: -1 解答 题中说明不含重复元素，所以直接写出代码： class Solution &#123; public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int lo = 0, hi = nums.length - 1; while (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (nums[mid] == target) return mid; if (nums[lo] &lt;= nums[mid]) &#123; // 左边有序 if (target &gt;= nums[lo] &amp;&amp; target &lt; nums[mid]) hi = mid - 1; else lo = mid + 1; &#125; else &#123; // 右边有序 if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]) lo = mid + 1; else hi = mid - 1; &#125; &#125; return -1; &#125;&#125; 上面提到也可以使用nums[mid]和nums[hi]的大小来解答，这里同样可以很轻易的写出代码： class Solution &#123; public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int lo = 0, hi = nums.length - 1; while (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (nums[mid] == target) return mid; if (nums[mid] &lt;= nums[hi]) &#123; // 右边有序 if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]) lo = mid + 1; else hi = mid - 1; &#125; else &#123; // 左边有序 if (target &gt;= nums[lo] &amp;&amp; target &lt; nums[mid]) hi = mid - 1; else lo = mid + 1; &#125; &#125; return -1; &#125;&#125; 下面的题目只写出一种代码，毕竟思路都是一样的。 搜索旋转排序数组（有重复元素）题目链接 LeetCode 81 搜索旋转排序数组 II 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 解答 class Solution &#123; public boolean search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return false; int lo = 0, hi = nums.length - 1; while (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (nums[mid] == target) return true; if (nums[lo] &lt; nums[mid]) &#123; // 左边有序 if (target &gt;= nums[lo] &amp;&amp; target &lt; nums[mid]) hi = mid - 1; else lo = mid + 1; &#125; else if (nums[lo] &gt; nums[mid]) &#123; // 右边有序 if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]) lo = mid + 1; else hi = mid - 1; &#125; else &#123; // 重复情况 lo++; &#125; &#125; return false; &#125;&#125; 搜索旋转排序数组（终极版）题目链接 LeetCode 面试题 10.03. 搜索旋转数组 题目 搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。 解答 这一题最特别的地方在于若有多个相同元素，返回索引值最小的一个，其实只需要在终止条件稍作处理即可： class Solution &#123; public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int lo = 0, hi = nums.length - 1; while (lo &lt;= hi) &#123; if (nums[lo] == target) return lo; int mid = lo + (hi - lo) / 2; if (nums[mid] == target) &#123; // 这里不能直接返回，因为mid不一定是所求的最小索引值 hi = mid; continue; &#125; if (nums[lo] &lt; nums[mid]) &#123; // 左边有序 if (target &gt;= nums[lo] &amp;&amp; target &lt; nums[mid]) hi = mid - 1; else lo = mid + 1; &#125; else if (nums[lo] &gt; nums[mid]) &#123; // 右边有序 if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[hi]) lo = mid + 1; else hi = mid - 1; &#125; else &#123; // 重复情况 lo++; &#125; &#125; return -1; &#125;&#125; 寻找旋转排序数组中的最小值题目链接 LeetCode 153 寻找旋转排序数组中的最小值 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 解答 class Solution &#123; public int findMin(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int lo = 0, hi = nums.length - 1; while (lo &lt; hi) &#123; int mid = lo + (hi - lo) / 2; if (nums[mid] &lt;= nums[hi]) &#123; hi = mid; &#125; else &#123; lo = mid + 1; &#125; &#125; return nums[lo]; &#125;&#125; 寻找旋转排序数组中的最小值（有重复元素）题目链接 LeetCode 154 寻找旋转排序数组中的最小值 II 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 注意数组中可能存在重复的元素。 解答 class Solution &#123; public int findMin(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int lo = 0, hi = nums.length - 1; while (lo &lt; hi) &#123; int mid = lo + (hi - lo) / 2; if (nums[mid] &lt; nums[hi]) &#123; hi = mid; &#125; else if (nums[mid] &gt; nums[hi]) &#123; lo = mid + 1; &#125; else &#123; hi--; // 重复情况 &#125; &#125; return nums[lo]; &#125;&#125; 寻找旋转排序数组中的最大值（有重复元素）本题LeetCode没有对应的题，是我自己想的… 题目 求含有重复元素的旋转排序数组的最大值。 解答 class Solution &#123; public int findMax(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int lo = 0, hi = nums.length - 1; while (lo &lt; hi) &#123; int mid = lo + (hi - lo + 1) / 2; if (nums[lo] &lt; nums[mid]) &#123; lo = mid; &#125; else if (nums[lo] &gt; nums[mid]) &#123; hi = mid - 1; &#125; else &#123; lo++; &#125; &#125; return nums[lo]; &#125;&#125; 其中一个需要注意的地方是求mid的时候要让mid偏右，否则当只有两个元素的时候会有lo == mid，从而进行lo++的时候可能去除了最大值，会发生错误，例如对于[2,1]，得到的最终结果就是1。 总结对于旋转排序数组，进行二分查找的时候一共有三种情景，通过nums[lo], nums[mid], nums[hi]的相对大小可以区分出这三种情景，从而在旋转排序数组也可以使用二分查找缩小范围了，并且也只需要遍历一次。 对于数组中有重复元素的情况，遇到nums[lo] == nums[mid]或nums[mid] == nums[hi]时，往往可以通过简单的lo++或者hi--来更新，只不过此类情况过多的话会导致时间复杂度退化为$O(n)$。 最后，总结一个小trick： 当进行查找target任务时，while循环的条件是lo &lt;= hi，并且可以只使用nums[lo]和nums[mid]即可。 当进行最小值查找时，while循环的条件是lo &lt; hi，并且使用nums[mid]和nums[hi]更方便些。 当进行最大值查找时，while循环的条件是lo &lt; hi，并且mid = lo + (hi - lo + 1) / 2，此时使用nums[lo]和nums[mid]更方便些。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://www.yingzq.com/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.yingzq.com/tags/LeetCode/"}]},{"title":"一种处理回溯问题的通用方法","slug":"a-general-approach-to-backtracking-questions","date":"2020-03-14T08:51:58.000Z","updated":"2020-03-16T12:42:15.603Z","comments":true,"path":"2020/03/14/a-general-approach-to-backtracking-questions/","link":"","permalink":"http://www.yingzq.com/2020/03/14/a-general-approach-to-backtracking-questions/","excerpt":"LeetCode中很多问题是和回溯相关的，例如Subsets, Permutations, Combination Sum, Palindrome Partitioning, N-Queens等等，所以本文借助这些题目提取了一种较为通用的思考模式，或者说代码结构来帮助处理这些回溯的问题。","text":"LeetCode中很多问题是和回溯相关的，例如Subsets, Permutations, Combination Sum, Palindrome Partitioning, N-Queens等等，所以本文借助这些题目提取了一种较为通用的思考模式，或者说代码结构来帮助处理这些回溯的问题。 文章主要copy自LeetCode Discuss区的 这篇文章 。另外代码是用 Java 写的，但是个人认为语言并不是关键。 Subsets（子集）链接 leetcode 78题 题目 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例： 输入: nums &#x3D; [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解答 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // 不需要排序 backtrack(res, new ArrayList&lt;&gt;(), nums, 0); return res; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; res , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; res.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(res, tempList, nums, i + 1); // 不能重复使用元素，所以需要i+1 tempList.remove(tempList.size() - 1); &#125; &#125;&#125; 如果输入的nums是[1, 2, 3]，那么该解法输出的结果顺序是： [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]] Subsets II（子集 II）链接 LeetCode 90题 题目 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] 解答 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); // 为了方便剔除重复元素，需要排序 backtrack(res, new ArrayList&lt;&gt;(), nums, 0); return res; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; res.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // 剔除重复元素 tempList.add(nums[i]); backtrack(res, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; 如果输入的nums是[1, 2, 2]，那么该解法输出的结果顺序是： [[],[1],[1,2],[1,2,2],[2],[2,2]] Permutations（全排列）链接 LeetCode 46题 题目 给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解答 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // 不含重复元素，不需要排序 backtrack(res, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return res; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, int[] nums, boolean[] visited) &#123; if (tempList.size() == nums.length) &#123; // 判断是否达到终止条件 res.add(new ArrayList&lt;&gt;(tempList)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (visited[i]) continue; // 判断是否访问过该元素 visited[i] = true; tempList.add(nums[i]); backtrack(res, tempList, nums, visited); visited[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; 本题和Subsets不同的地方在于：本题的每个结果的长度都是nums.length，因此两者的终止条件有差异；另外，Subsets中是使用了start指针来表示目前可以访问元素的范围，也就是start ~ nums.length-1，但是Permutations无法这样做，因为元素访问顺序不同时是能够产生不同结果的，因此使用了visited数组来记录已访问的位置（用HashSet也是可以的）。 如果输入的nums是[1, 2, 3]，那么该解法输出的结果顺序是： [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Permutations II（全排列 II）链接 LeetCode 47题 题目 给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 解答 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); // 需要排序，方便后续处理重复元素 backtrack(res, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return res; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, int [] nums, boolean [] visited)&#123; if(tempList.size() == nums.length)&#123; res.add(new ArrayList&lt;&gt;(tempList)); return; &#125; for(int i = 0; i &lt; nums.length; i++)&#123; if(visited[i]) continue; if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !visited[i - 1]) continue; // 剔除重复元素 visited[i] = true; tempList.add(nums[i]); backtrack(res, tempList, nums, visited); visited[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; 代码中最关键的部分在于剔除重复元素的步骤，当i &gt; 0 &amp;&amp; nums[i] == nums[i-1]时需要进行处理，其实在这里有两种方式都可以处理： 当i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !visited[i - 1]时跳过，最终会只保留顺序生成的那一种情况，其余的全部剔除。 当i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; visited[i - 1]时跳过，最终会只保留逆序生成的那一种情况，其余的全部剔除。 以第一种处理为例，当输入是[1, 1, 2]时，对应的输出顺序是： [[1,1,2],[1,2,1],[2,1,1]] Combination Sum（组合总和）链接 LeetCode 39题 题目 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例: 输入: candidates &#x3D; [2,3,5], target &#x3D; 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 解答 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // 无需排序 backtrack(res, new ArrayList&lt;&gt;(), nums, target, 0); return res; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; if(remain == 0)&#123; res.add(new ArrayList&lt;&gt;(tempList)); return; &#125; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(res, tempList, nums, remain - nums[i], i); // 因为可以重复使用元素，所以这里不是i+1 tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II（组合总和 II）链接 LeetCode 40题 题目 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例: 输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 解答 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(res, new ArrayList&lt;&gt;(), nums, target, 0); return res; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; if(remain == 0)&#123; res.add(new ArrayList&lt;&gt;(tempList)); return; &#125; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // 剔除重复元素 tempList.add(nums[i]); backtrack(res, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning（分割回文串）链接 LeetCode 131题 题目 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例: 输入: &quot;aab&quot;输出:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 解答 class Solution &#123; boolean[][] valid; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); if(s == null || s.length() == 0) return res; valid = new boolean[s.length()][s.length()]; for(int i = 0;i &lt; s.length();i++)&#123; for(int j = 0;j &lt;= i;j++)&#123; if(s.charAt(j) == s.charAt(i) &amp;&amp; (i-j &lt;= 2 || valid[j+1][i-1]))&#123; valid[j][i] = true; &#125; &#125; &#125; backtrack(res, new ArrayList&lt;&gt;(), s, 0); return res; &#125; private void backtrack(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; tempList, String s, int idx)&#123; if(idx == s.length())&#123; res.add(new ArrayList&lt;&gt;(tempList)); return; &#125; for(int i = idx;i &lt; s.length();i++)&#123; if(!valid[idx][i]) continue; String sub = s.substring(idx, i+1); tempList.add(sub); backtrack(res, tempList, s, i+1); tempList.remove(tempList.size()-1); &#125; &#125;&#125; 注：这段代码中前面关于构建valid数组的部分使用了动态规划，但是并不是本文的重点，只需要知道valid[i][j]表示字符串中 i 到 j 位置的元素能否构成回文即可。 Generate Parentheses（括号生成）链接 LeetCode 22题 题目 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 解答 class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); backtrack(res, new StringBuilder(), n, n); return res; &#125; private void backtrack(List&lt;String&gt; res, StringBuilder sb, int left, int right)&#123; if(left &gt; right) return; // 右括号使用比左括号多，舍去 if(left == 0 &amp;&amp; right == 0)&#123; res.add(sb.toString()); return; &#125; if(left &gt; 0)&#123; sb.append('('); backtrack(res, sb, left - 1, right); sb.setLength(sb.length() - 1); &#125; if(right &gt; 0)&#123; sb.append(')'); backtrack(res, sb, left, right - 1); sb.setLength(sb.length() - 1); &#125; &#125;&#125; 和前面几题不同的是，这一题似乎没有for循环，这是因为在某个位置k，括号只有两种状态：(或者)，不需要循环，但是本质是一样的。 N-Queens（N皇后）链接 LeetCode 51题 题目 设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。 示例: 输入：4 输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]] 解释: 4 皇后问题存在如下两个不同的解法。[ [&quot;.Q..&quot;, &#x2F;&#x2F; 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, &#x2F;&#x2F; 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 解答 class Solution &#123; private boolean[] cols, diag1, diag2; // 用于判断某位置的列以及两条对角线是否冲突 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); cols = new boolean[n]; // 判断列是否冲突 diag1 = new boolean[2 * n]; // 判断 左上-&gt;右下 的对角线是否冲突，利用 x-y+n 是定值 diag2 = new boolean[2 * n]; // 判断 右上-&gt;左下 的对角线是否冲突，利用 x+y 是定值 backtrack(res, new ArrayList&lt;&gt;(), n, 0); return res; &#125; private void backtrack(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; tempList, int n, int row) &#123; if (row == n) &#123; // 终止条件 res.add(new ArrayList&lt;&gt;(tempList)); return; &#125; for (int j = 0; j &lt; n; j++) &#123; int id1 = row - j + n, id2 = row + j; if (cols[j] || diag1[id1] || diag2[id2]) continue; // 此位置有冲突，跳过 cols[j] = true; diag1[id1] = true; diag2[id2] = true; char[] chars = new char[n]; Arrays.fill(chars, '.'); chars[j] = 'Q'; tempList.add(new String(chars)); backtrack(res, tempList, n, row + 1); tempList.remove(tempList.size() - 1); cols[j] = false; diag1[id1] = false; diag2[id2] = false; &#125; &#125;&#125; 虽然代码长了很多，但是整体的思路是一样的，解决N皇后问题有两个地方值得注意： 如何判断二维数组中两个元素是否在同一对角线，这一点在代码中已经解释。 因为每一行只能有一个皇后，所以回溯函数中的 for循环 是针对当前行的所有可能。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://www.yingzq.com/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.yingzq.com/tags/LeetCode/"}]},{"title":"《剑指offer第二版》阅读笔记（三）","slug":"sword-finger-offer-notes-part-three","date":"2020-02-21T05:02:22.000Z","updated":"2020-03-10T10:06:24.911Z","comments":true,"path":"2020/02/21/sword-finger-offer-notes-part-three/","link":"","permalink":"http://www.yingzq.com/2020/02/21/sword-finger-offer-notes-part-three/","excerpt":"《剑指offer第二版》阅读笔记最后一个部分，记录了书中面试题51到最后的部分。","text":"《剑指offer第二版》阅读笔记最后一个部分，记录了书中面试题51到最后的部分。 系列文章 《剑指offer第二版》阅读笔记（一） 《剑指offer第二版》阅读笔记（二） 《剑指offer第二版》阅读笔记（三） 面试题51：数组中的逆序对题目在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 输入: [7,5,6,4]输出: 5 分析暴力法的时间复杂度为$O(n^2)$，不可取。这里我们用到了一个重要的知识点：逆序对是归并排序的副产物。 在归并排序的一次merge操作中，如果右边的某元素大于左边，那么该元素便会产生一定数量的逆序对，不断的递归统计，便能够得到最终结果。因此我们直接复用归并排序的代码，只是在条件aux[j] &lt; aux[i]时添加了一句更新逆序对的操作： class Solution &#123; private int[] aux; private int count; public int reversePairs(int[] nums) &#123; aux = new int[nums.length]; count = 0; sort(nums, 0, nums.length - 1); return count; &#125; private void sort(int[] arr, int lo, int hi) &#123; // 将数组arr[lo..hi]排序 if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(arr, lo, mid); sort(arr, mid + 1, hi); merge(arr, lo, mid, hi); &#125; private void merge(int[] arr, int lo, int mid, int hi) &#123; // 将arr[lo..mid]和arr[mid+1..hi]归并 int i = lo, j = mid + 1; // 将arr[lo..hi]复制到aux[lo..hi] for (int k = lo; k &lt;= hi; k++) aux[k] = arr[k]; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) arr[k] = aux[j++]; else if (j &gt; hi) arr[k] = aux[i++]; else if (aux[j] &lt; aux[i]) &#123; count += mid - i + 1; // aux[i] &gt; aux[j]，说明 arr[i...mid] 都大于 arr[j] arr[k] = aux[j++]; &#125; else arr[k] = aux[i++]; &#125; &#125;&#125; 面试题52：两个链表的第一个公共节点题目输入两个链表，找出它们的第一个公共节点。 分析很容易想到的一种思路是先求出两个链表的长度n1, n2，假设n1 &gt;= n2，然后求出长度差n1-n2，最后利用快慢指针，让快指针在较长的链表先移动n1-n2步，然后快慢指针一起移动，如果两个链表有公共部分，两个指针会在同一时刻达到相同位置，因此可以找到第一个公共节点。 还有一种想法不需要求链表长度差值：当两个链表l1, l2有公共节点时，可以证明对于拼接后的链表l1-&gt;l2以及l2-&gt;l1会在同一时间达到第一个公共节点，相关代码如下： public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode a = headA, b = headB; while (a != b) &#123; a = a == null ? headB : a.next; b = b == null ? headA : b.next; &#125; return a; &#125;&#125; 面试题53-1：数字在排序数组中出现的次数题目统计一个数字在排序数组中出现的次数。 示例 输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8输出: 2输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6输出: 0 分析需要注意的是数组已经排序，所以我们可以使用两次二分查找，第一次查找target起始位置，第二次查找target结束位置： class Solution &#123; public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return 0; // 查找target起始位置 int lo = 0, hi = nums.length - 1; while (lo &lt; hi) &#123; int mid = lo + (hi - lo) / 2; if (nums[mid] &lt; target) &#123; lo = mid + 1; &#125; else &#123; hi = mid; &#125; &#125; if (nums[lo] != target) return 0; int startIdx = lo; // 查找target结束位置 hi = nums.length - 1; while (lo &lt; hi) &#123; int mid = lo + (hi - lo + 1) / 2; if (nums[mid] &gt; target) &#123; hi = mid - 1; &#125; else &#123; lo = mid; &#125; &#125; return lo - startIdx + 1; &#125;&#125; 代码中有几个要注意的点，一是循环条件是lo &lt; hi，其中没有等号，这样循环结束的时候一定有lo == hi，二是lo+(hi-lo)/2会偏向于取左边，lo+(hi-lo+1)/2则偏向于取右边，最后边界更新时是哪一边等于mid，哪一边等于mid-1或mid+1需要考虑清楚，如果觉得麻烦可以拆成3个部分进行处理，例如： if (nums[mid] &lt; target) &#123; lo = mid + 1;&#125; else &#123; hi = mid;&#125; 等价于 if (nums[mid] &lt; target) &#123; lo = mid + 1;&#125; else if (nums[mid] &gt; target) &#123; hi = mid - 1;&#125; else &#123; hi = mid;&#125; 面试题53-2：0～n-1中缺失的数字题目一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 分析直接二分查找最后一个满足nums[i] = i的位置，然后处理一些小细节即可： class Solution &#123; public int missingNumber(int[] nums) &#123; int lo = 0, hi = nums.length - 1; while (lo &lt; hi) &#123; int mid = lo + (hi - lo + 1) / 2; if (nums[mid] == mid) &#123; lo = mid; &#125; else &#123; hi = mid - 1; &#125; &#125; return nums[lo] == lo ? lo + 1 : 0; &#125;&#125; 面试题54：二叉搜索树的第k大节点题目给定一棵二叉搜索树，请找出其中第k大的节点。 示例 输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3 5 &#x2F; \\ 3 6 &#x2F; \\ 2 4 &#x2F; 1输出: 4 分析这是一棵二叉搜索树，我们有如下结论：按照left-&gt;root-&gt;right进行遍历时（即中序遍历）可以得到递增序列，按照right-&gt;root-&gt;left进行遍历时（即逆中序遍历）可以得到递减序列。 这一题需要返回第k大的节点，那么我们可以选择遍历right-&gt;root-&gt;left，直到得到第k个元素即为所求，相关代码如下： class Solution &#123; public int kthLargest(TreeNode root, int k) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; int count = 0; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.right; &#125; cur = stack.pop(); if (++count == k) return cur.val; cur = cur.left; &#125; return -1; &#125;&#125; 面试题55-1：二叉树的深度题目输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 分析这种树的问题直接递归，当前节点为空时返回深度 0，否则当前节点的深度为左子树和右子树中的较大值加上 1。代码非常简洁： class Solution &#123; public int maxDepth(TreeNode root) &#123; if (root == null) return 0; return 1 + Math.max(maxDepth(root.left), maxDepth(root.right)); &#125;&#125; 面试题55-2：平衡二叉树题目输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 分析递归进行判断即可： class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return depth(root) != -1; &#125; private int depth(TreeNode root) &#123; if (root == null) return 0; int left = depth(root.left); int right = depth(root.right); if (left == -1 || right == -1) return -1; if (left - right &gt; 1 || right - left &gt; 1) return -1; return Math.max(left, right) + 1; &#125;&#125; 递归的思想不需要再说，上面代码值得注意的是巧用了-1来当做布朗值使用，其实也可以使用一个新的成员变量isBalanced的常规解法，代码贴出来可以进行比较： class Solution &#123; private boolean isBalanced; public boolean isBalanced(TreeNode root) &#123; isBalanced = true; depth(root); return isBalanced; &#125; private int depth(TreeNode root) &#123; if (root == null || !isBalanced) return 0; int left = depth(root.left); int right = depth(root.right); if (Math.abs(left - right) &gt; 1) isBalanced = false; return 1 + Math.max(left, right); &#125;&#125; 面试题56-1：数组中只出现一次的两个数字题目一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 输入：nums &#x3D; [4,1,4,6]输出：[1,6] 或 [6,1]输入：nums &#x3D; [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 分析我们进行一次全员异或操作，得到的结果就是那两个只出现一次的不同的数字的异或结果了。所以我们现在要做的是能不能将这两个不同的数字分成两组 A 和 B，分组需要满足两个条件： 两个独特的的数字分成不同组 相同的数字分成相同组 这样每一组的数据进行异或即可得到那两个数字。问题的关键点是我们怎么进行分组呢？由于异或的性质是，同一位相同则为 0，不同则为 1，我们将所有数字异或的结果一定不是 0，也就是说至少有一位是 1。 我们随便取一位，分组的依据就来了，也就是所取的那一位是 0 分成 1 组，那一位是 1 的分成一组。可以证明这样分组是可以满足上述两个条件的。 class Solution &#123; public int[] singleNumbers(int[] nums) &#123; int a = 0, b = 0; int xor = 0; for (int num : nums) xor ^= num; int h = 1; while ((xor &amp; h) == 0) &#123; h = h &lt;&lt; 1; &#125; for (int num : nums) &#123; if ((num &amp; h) == 0) &#123; a ^= num; &#125; else &#123; b ^= num; &#125; &#125; return new int[]&#123;a, b&#125;; &#125;&#125; 面试题56-2：数组中唯一只出现一次的数字题目在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 限制： 1 &lt;= nums.length &lt;= 10000 1 &lt;= nums[i] &lt; 2^31 分析如果将题目改为只有一个数字出现一次，其他都出现两次，那就非常简单了：我们将整个数组的元素进行异或，由于两个相同的数的异或结果是 0，所以对所有元素进行异或的结果便是那个只出现一次的元素。 但是现在是其他数字都出现了三次，异或操作是抵消不掉的，但是我们还是可以沿用位运算的思路。如果一个数字出现三次，那么它的二进制表示的每一位（0 或 1）也会出现三次，如果把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被 3 整除。我们把数组中所有的数字的二进制加起来，如果某一位的和能够被 3 整除，那么那个只出现一次的数字的二进制表示中对应的那一位是 0，否则就是 1。对应的代码如下： class Solution &#123; public int singleNumber(int[] nums) &#123; int res = 0; int mask = 1; for (int i = 0; i &lt; 32; i++) &#123; int count = 0; for (int num : nums) &#123; if ((num &amp; mask) &gt; 0) count++; &#125; if (count % 3 &gt; 0) res += mask; mask = mask &lt;&lt; 1; &#125; return res; &#125;&#125; 面试题57-1：和为s的两个数字题目输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 示例 输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[2,7] 或者 [7,2] 分析注意是递增序列，所以直接使用首尾指针法即可。 面试题57-2：和为s的连续正数序列题目输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 示例 输入：target &#x3D; 15输出：[[1,2,3,4,5],[4,5,6],[7,8]] 分析使用滑动窗口的思想，初始化两个指针slow = 0， fast = 1，当窗口内的数据和小于target时，向右不断的移动fast直到维护的窗口内的数据和大于target，然后再不断的向右移动slow指针，直到窗口内的数据和不大于target，其中遇到数据和等于target时写入数据到结果中即可。 面试题58-1：翻转单词顺序题目输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 分析第一种方法是使用s.trim().split(&quot;\\\\s+&quot;)方法进行切分，然后将得到的字符串数组逆序写入到结果中即可。 第二种方法是先翻转整个字符串，再对字符串里的每个单词进行翻转，最后清理多余的空格。 面试题58-2：左旋转字符串题目字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 分析第一种方法是找到切分点，得到str1和str2，然后将它们反着拼接起来，即str2 + str1。 第二种方法是进行3次翻转：先翻转整个字符串，然后找到切分点，然后对str1和str2再进行翻转，例如abcdefg -&gt; gfedcba -&gt; cdefgab。 面试题59-1：滑动窗口的最大值题目给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 示例 输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3输出: [3,3,5,5,6,7]解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 分析直接使用暴力法的时间复杂度为$O(k(n-k))$，其实还是可以接受的。但是当k约为n/2时时间复杂度退化到$O(n^2)$。 其中主要的性能浪费在查找范围为k的数据的最大值，我们可以使用一个容量为k的优先队列，也就是大顶堆来进行优化。这样时间复杂度可以优化到$O(n \\log k)$。 最后，我们可以用双向队列设计一个能够在$O(1)$的时间实现查找最大值的容器，其实也就是下一题“队列的最大值”中实现的MaxQueue。MaxQueue的插入、删除以及寻找最大值的操作时间复杂度均为$O(1)$，但是我们这里只需要寻找最大值的操作，因此有所简化，这样整体的时间复杂度便只有$O(n)$了，具体代码如下： class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; if (nums == null || nums.length == 0) return new int[0]; int n = nums.length; int[] res = new int[n - k + 1]; int idx = 0; Deque&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (!q.isEmpty() &amp;&amp; q.peek() &lt; i - k + 1) &#123; q.poll(); &#125; while (!q.isEmpty() &amp;&amp; nums[q.peekLast()] &lt;= nums[i]) &#123; q.pollLast(); &#125; q.offer(i); if (i &gt;= k - 1) &#123; res[idx++] = nums[q.peek()]; &#125; &#125; return res; &#125;&#125; 面试题59-2：队列的最大值题目请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1。 分析思路：用两个队列来完成任务：一个队列保存正常元素，另一个双向队列保存单调递减的元素。 入栈时，第一个队列正常入栈；第二个队列是递减队列，所以需要与之前的比较，从尾部把小于当前value的全部删除（因为用不到了）。出栈时，第一个队列正常出栈；第二个队列的头部与出栈的值作比较，如果相同，那么一起出栈。具体代码如下： class MaxQueue &#123; private Queue&lt;Integer&gt; data; private Deque&lt;Integer&gt; maxQueue; public MaxQueue() &#123; data = new LinkedList&lt;&gt;(); maxQueue = new LinkedList&lt;&gt;(); &#125; public int max_value() &#123; if (data.isEmpty()) return -1; return maxQueue.peek(); &#125; public void push_back(int value) &#123; data.offer(value); while (!maxQueue.isEmpty() &amp;&amp; value &gt; maxQueue.peekLast()) &#123; maxQueue.pollLast(); &#125; maxQueue.offer(value); &#125; public int pop_front() &#123; if (data.isEmpty()) return -1; int ans = data.poll(); if (ans == maxQueue.peek()) maxQueue.poll(); return ans; &#125;&#125; 面试题60：n个骰子的点数题目把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 示例 输入: 1输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]输入: 2输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] 分析动态规划题。假设f(i, j)代表i个骰子的点数之和为j的个数，有递推公式f(i, j) = f(i-1, j-1) + f(i-1, j-2) + ... + f(i-1, j-6)，代码如下： class Solution &#123; public double[] twoSum(int n) &#123; int[][] dp = new int[n][6 * n + 1]; for (int i = 1; i &lt;= 6; i++) dp[0][i] = 1; for (int i = 1; i &lt; n; i++) &#123; int left = i + 1; int right = 6 * i + 6; for (int j = left; j &lt;= right; j++) &#123; for (int k = 1; k &lt; j &amp;&amp; k &lt;= 6; k++) &#123; dp[i][j] += dp[i - 1][j - k]; &#125; &#125; &#125; double count = Math.pow(6, n); int left = n, right = 6 * n; double[] res = new double[right - left + 1]; for (int i = n; i &lt;= right; i++) &#123; res[i - left] = dp[n - 1][i] / count; &#125; return res; &#125;&#125; 面试题61：扑克牌中的顺子题目从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 示例 输入: [1,2,3,4,5]输出: True输入: [0,0,1,2,5]输出: True 分析先对数组进行排序，利用每一张大小王可以填补一个空缺，遍历数组统计0的数目，最后，在剩余的牌中检测是否可以借助一定数量的大小王（即任意牌）凑成顺子，代码如下： class Solution &#123; public boolean isStraight(int[] nums) &#123; Arrays.sort(nums); int count = 0; for (int num : nums) &#123; if (num == 0) count++; &#125; for (int i = count; i &lt; nums.length - 1; i++) &#123; if (nums[i] == nums[i + 1]) return false; count -= nums[i + 1] - nums[i] - 1; &#125; return count &gt;= 0; &#125;&#125; 面试题62：圆圈中最后剩下的数字题目0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 分析此题就是有名的约瑟夫环问题。通常有两种解法，第一种方法是用环装链表链表模拟模拟圆圈的经典解法，第二种方法是分析每次被删除的数字的规律并直接计算出圆圈中最后剩下的数字。 对于第一种方法，在java中可以使用数组来模拟，当某个位置被删除时将其置为-1，这样时间复杂度为$O(mn)$；当然也可以使用链表或者队列，经过计算很容易得出时间复杂度仍然是$O(mn)$ 对于第二种的数学方法，我们定义一个关于n和m的方程f(n, m)，表示每次在n个数字0, 1, 2, ..., n-1中删除第m个数字最后剩下的数字，需要费点力气来找规律，这里直接给出答案： f(n, m) = 0, n = 1 f(n, m) = [f(n - 1, m) + m] % n, n &gt; 1 class Solution &#123; public int lastRemaining(int n, int m) &#123; if (n == 1) return 0; return (lastRemaining(n - 1, m) + m) % n; &#125;&#125; 面试题63：股票的最大利润题目假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 示例 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。 注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。 分析股票的利润来源于买入和卖出的价格差，当我们在第i天想要卖出时，那么应该在第1~i-1天中最低的价格买入，因此利用一个变量来表示到目前元素前的最小值，便可以得到在第i天卖出时的最大利润，进而便知道了全局最大利润： class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; int lastMin = prices[0]; int max = 0; for (int i = 1; i &lt; prices.length; i++) &#123; max = Math.max(max, prices[i] - lastMin); lastMin = Math.min(lastMin, prices[i]); &#125; return max; &#125;&#125; 面试题64：求1+2+…+n题目求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 分析使用递归解法最重要的是指定返回条件，但是本题无法直接使用if语句来指定返回条件。 条件与&amp;&amp;具有短路原则，即在第一个条件语句为false的情况下不会去执行第二个条件语句。 利用这一特性，将递归的返回条件取非然后作为&amp;&amp;的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为true的情况下就不会执行递归的主体部分，递归返回。 本题的递归返回条件为 n &lt;= 0，取非后就是 n &gt; 0；递归的主体部分为n += sumNums(n - 1)，转换为条件语句后就是(n += sumNums(n-1)) &gt; 0。 class Solution &#123; public int sumNums(int n) &#123; boolean b = n &gt; 0 &amp;&amp; (n += sumNums(n - 1)) &gt; 0; return n; &#125;&#125; 面试题65：不用加减乘除做加法题目写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 分析四则运算不能使用了，我们还有位运算。a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。 所以a + b = (a ^ b) + ((a &amp; b) &lt;&lt; 1)，不断进行该步骤，直到进位为 0，相关代码如下： class Solution &#123; public int add(int a, int b) &#123; while (a != 0) &#123; int temp = a ^ b; a = (a &amp; b) &lt;&lt; 1; b = temp; &#125; return b; &#125;&#125; 面试题66：构建乘积数组题目给定一个数组A[0,1,…,n-1]，请构建一个数组B[0,1,…,n-1]，其中B中的元素B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 分析题目中说明不能使用除法，可以简单思考一下如果能使用除法应该怎么做？我们可以先将所有的数组A的所有乘积求出来：C = A[0] * A[1] * ... * A[n-1]，此时可以得到B[i] = C / A[i]，但是需要注意的是数组A中可能会有元素为 0，需要额外处理。 现在不能使用除法，应该如何思考呢？我们可以将B[i]分成A[0]*A[1]*...*A[i-1]和A[i+1]*A[i+2]*...*A[n-1]两部分，所以可以： 从左往右遍历累乘，结果保存在数组res中，此时res[i]表示A[i]左边所有元素的乘积 然后从右往左遍历累乘，获取A[i]右边所有元素的乘积 两边遍历之后得到的res，就是最终结果 class Solution &#123; public int[] constructArr(int[] a) &#123; if (a == null || a.length == 0) return a; int[] res = new int[a.length]; int left = 1; for (int i = 0; i &lt; a.length; i++) &#123; res[i] = left; left *= a[i]; &#125; int right = 1; for (int i = a.length - 1; i &gt;= 0; i--) &#123; res[i] *= right; right *= a[i]; &#125; return res; &#125;&#125; 面试题67：把字符串转换成整数题目写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 分析这类题主要是处理一些特殊问题，锻炼处理异常情况的能力，在这里就不贴代码了。 面试题68-1：二叉搜索树的最近公共祖先题目给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 分析看清题目到底是二叉树还是二叉搜索树，虽然都是递归的结构，但是二叉搜索树的要求更严格些，所以在很多情况下两者的思路不太一样。 对于二叉搜索树： 当根节点为空时直接返回 当p和q的值均小于根节点值时，应该递归的去左子树寻找 当p和q的值均大于根节点值时，应该递归的去右子树寻找 当根节点的值在p和p之间时，证明此时根节点即为最近公共祖先。 class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) return null; if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123; return lowestCommonAncestor(root.left, p, q); &#125; else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123; return lowestCommonAncestor(root.right, p, q); &#125; else &#123; return root; &#125; &#125;&#125; 面试题68-2：二叉树的最近公共祖先题目给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 分析对于二叉树，节点值的相对大小便没有意义了，我们需要在左右子树中查找是否存在p或者p，如果p和q分别在两个子树中，那么就说明根节点就是最低公共祖先。 class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null &amp;&amp; right != null) return root; return left == null ? right : left; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://www.yingzq.com/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://www.yingzq.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}]},{"title":"《剑指offer第二版》阅读笔记（二）","slug":"sword-finger-offer-notes-part-two","date":"2020-02-20T12:06:52.000Z","updated":"2020-03-19T07:40:37.053Z","comments":true,"path":"2020/02/20/sword-finger-offer-notes-part-two/","link":"","permalink":"http://www.yingzq.com/2020/02/20/sword-finger-offer-notes-part-two/","excerpt":"《剑指offer第二版》阅读笔记第二部分，记录了书中面试题26~50的部分。","text":"《剑指offer第二版》阅读笔记第二部分，记录了书中面试题26~50的部分。 系列文章 《剑指offer第二版》阅读笔记（一） 《剑指offer第二版》阅读笔记（二） 《剑指offer第二版》阅读笔记（三） 面试题26：树的子结构题目输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 示例 给定的树 A: 3 &#x2F; \\ 4 5 &#x2F; \\ 1 2给定的树 B： 4 &#x2F; 1返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值 分析首先树的这类问题，没有特殊要求一般使用递归更简洁，更利于理解。 此题可以递归进行对比，前序遍历树A，不妨假设当前遍历的子树根节点为rootA，只存在三种情况： 以rootA为根节点的子树结构与树B相同 与B相同的子树结构存在于rootA的左子树 与B相同的子树结构存在于rootA的右子树 不满足以上三种情况，则B不是A的子树结构。 按照这种思想，有如下代码： class Solution &#123; public boolean isSubStructure(TreeNode A, TreeNode B) &#123; if (A == null || B == null) return false; return isMatch(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); &#125; private boolean isMatch(TreeNode rootA, TreeNode rootB) &#123; if (rootB == null) return true; if (rootA == null) return false; if (rootA.val != rootB.val) return false; return isMatch(rootA.left, rootB.left) &amp;&amp; isMatch(rootA.right, rootB.right); &#125;&#125; 面试题27：二叉树的镜像题目请完成一个函数，输入一个二叉树，该函数输出它的镜像。 示例 输入： 4 &#x2F; \\ 2 7 &#x2F; \\ &#x2F; \\1 3 6 9镜像输出： 4 &#x2F; \\ 7 2 &#x2F; \\ &#x2F; \\9 6 3 1 分析还是那句话：时刻要想到二叉树的子树仍然是二叉树。 对于当前根节点root，它的左子树和右子树也都是二叉树，将root的左节点和右节点进行交换，如果它的左子树和右子树不为空，则接着递归进行处理，非常简单，代码如下： class Solution &#123; public TreeNode mirrorTree(TreeNode root) &#123; if (root == null) return null; TreeNode left = mirrorTree(root.left); TreeNode right = mirrorTree(root.right); root.left = right; root.right = left; return root; &#125;&#125; 面试题28：对称的二叉树题目请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 示例 二叉树 [1,2,2,3,4,4,3] 是对称的。 1 &#x2F; \\ 2 2 &#x2F; \\ &#x2F; \\3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 &#x2F; \\ 2 2 \\ \\ 3 3 分析和上面几题是一样的思考方式，对于当前根节点root，需要保证root.left.val == root.right.val，但是这是不够的，我们需要接着将root的左右子节点当做根节点递归的进行判断，代码如下： class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) return true; return isSymmetric(root.left, root.right); &#125; private boolean isSymmetric(TreeNode left, TreeNode right) &#123; if (left == null || right == null) return left == right; if (left.val != right.val) return false; return isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left); &#125;&#125; 其中有个小trick是if (left == null || right == null) return left == right;，可以一句话判断left和right有且仅有一个是空。 面试题29：顺时针打印矩阵题目输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 分析对于这样一个复杂的操作，我们可以画图辅助进行分析，同时寻找规律。在画图的过程中我们可以发现矩阵在一圈一圈的变小，直到没有数据可以继续顺时针转圈。对于顺时针转圈这个动作来说，其实分为4个步骤：向右移动、向下移动、向左移动、向上移动，移动的时候范围会逐渐缩小，执行完这4个步骤后会回到新的起点，然后重复的进行这样的动作。 public class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (matrix.length == 0) return res; int rowBegin = 0; int rowEnd = matrix.length - 1; int colBegin = 0; int colEnd = matrix[0].length - 1; while (rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd) &#123; // Traverse Right for (int j = colBegin; j &lt;= colEnd; j++) &#123; res.add(matrix[rowBegin][j]); &#125; rowBegin++; // Traverse Down for (int j = rowBegin; j &lt;= rowEnd; j++) &#123; res.add(matrix[j][colEnd]); &#125; colEnd--; if (rowBegin &lt;= rowEnd) &#123; // Traverse Left for (int j = colEnd; j &gt;= colBegin; j--) &#123; res.add(matrix[rowEnd][j]); &#125; &#125; rowEnd--; if (colBegin &lt;= colEnd) &#123; // Traver Up for (int j = rowEnd; j &gt;= rowBegin; j--) &#123; res.add(matrix[j][colBegin]); &#125; &#125; colBegin++; &#125; return res; &#125;&#125; 面试题30：包含min函数的栈题目定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例 MinStack minStack &#x3D; new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.min(); --&gt; 返回 -2. 分析这是一个很经典也很实用的结构，一般来说，查找当前栈中的最小值是需要遍历整个栈，花费$O(n)$的时间复杂度才能够完成的。 一开始能想到的方法便是利用空间换时间，我们可以增加一个额外的辅助栈，辅助栈大小与原数据栈保持一致，记录着相应位置的最小值，空间复杂度为$O(n)$，具体操作如下： 进行push时，数据栈直接进行push新元素，辅助栈则需要判断新数据是否大于栈顶元素，如果是则接着push栈顶元素，否则便push新元素，因为可以证明这个时候的新元素是已有数据里最小的。 进行pop时，两个栈均直接进行pop即可 min操作则对辅助栈进行peek操作即可，具有$O(1)$的时间复杂度 有没有方法可以不需要开辟额外栈呢？其实也是可以的，我们只需要一个数据栈，只不过进行push操作时，如果当前压入的值不大于当前最小值，则压入一个当前最小值，再压入当前的值！这样我们在pop的时候，便可以知道在某个时刻，最小值被弹出了，但是它的下一个弹出元素是第二小的元素！此方法具体代码如下： class MinStack &#123; private Stack&lt;Integer&gt; stack; private int min; /** * initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;&gt;(); min = Integer.MAX_VALUE; &#125; public void push(int x) &#123; if (x &lt;= min) &#123; stack.push(min); min = x; &#125; stack.push(x); &#125; public void pop() &#123; int pop = stack.pop(); if (pop == min) &#123; min = stack.pop(); &#125; &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return min; &#125;&#125; 面试题31：栈的压入、弹出序列题目输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 分析这一题经常出现在数据结构与算法课程的选择题中，给出4个选项判断选项的弹出序列是否可能，我们会根据选项的弹出序列来模拟可能的压栈、出栈顺序，最终判断该选项的弹出序列是否可能。 其实将这个过程用代码写出的时候是一样的思路，把pushed序列模拟入栈，当遇到栈顶元素等于poped[idx]，模拟出栈过程，如果能匹配（idx能指向序列末尾），那么poped是压栈序列的弹出序列，具体代码如下： class Solution &#123; public boolean validateStackSequences(int[] pushed, int[] popped) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int idx = 0; for (int x : pushed) &#123; stack.push(x); while (!stack.isEmpty() &amp;&amp; stack.peek() == popped[idx]) &#123; stack.pop(); idx++; &#125; &#125; return idx == pushed.length; &#125;&#125; 面试题32-1：从上到下打印二叉树题目从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 示例 给定二叉树: [3,9,20,null,null,15,7], 3 &#x2F; \\ 9 20 &#x2F; \\ 15 7返回：[3,9,20,15,7] 分析很明显直接使用BFS即可。 面试题32-2：从上到下打印二叉树 II题目从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 示例 给定二叉树: [3,9,20,null,null,15,7], 3 &#x2F; \\ 9 20 &#x2F; \\ 15 7返回其层次遍历结果：[ [3], [9,20], [15,7]] 分析这一题虽然很简单，但是很经典，所以会贴一下具体代码。这种遍历方式其实是有名字的，叫做二叉树的层序遍历，首先明显可以使用BFS进行处理；另外使用DFS也是可以处理的，两种思路很容易理解，主要可以学习一下此类问题代码的写法。 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; // BFS List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); while (!q.isEmpty()) &#123; int size = q.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = q.poll(); list.add(node.val); if (node.left != null) q.offer(node.left); if (node.right != null) q.offer(node.right); &#125; res.add(list); &#125; return res; &#125;&#125; class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; // DFS List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); dfs(root, res, 0); return res; &#125; private void dfs(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, int depth) &#123; if (root == null) return; if (depth == res.size()) &#123; res.add(new ArrayList&lt;&gt;()); &#125; res.get(depth).add(root.val); dfs(root.left, res, depth + 1); dfs(root.right, res, depth + 1); &#125;&#125; 面试题32-3：从上到下打印二叉树 III题目请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 示例 给定二叉树: [3,9,20,null,null,15,7], 3 &#x2F; \\ 9 20 &#x2F; \\ 15 7返回其层次遍历结果：[ [3], [20,9], [15,7]] 分析和上一题非常类似，只不过其中奇数层（从0开始算）需要倒着打印，所以同样我们可以和上一题使用相同的BFS和DFS这两种方法，但是在特定行需要反着打印该如何处理呢？这里有两个问题需要解决： 哪些行需要反着打印？我们可以根据当前的行数的奇偶性来确定，也可以通过每迭代一行就反转一次的boolean变量来控制。 如何反着打印？我们可以使用LinkedList，也就是链表来进行插入数据，当需要正着打印时可以addLast，需要反着打印时可以addFirst，均为$O(1)$的时间复杂度。 其他的细节和上一题一模一样，不再敖述。 面试题33：二叉搜索树的后序遍历序列题目输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 示例 输入: [1,6,3,2,5]输出: false输入: [1,3,2,6,5]输出: true 分析首先注意是二叉搜索树而不是二叉树，这是很重要的一点，对于二叉搜索树有左子树元素均比根节点小，右子树均比根节点大，其次，要深刻的认识后序遍历的特点：左子树 -&gt; 右子树 -&gt; 根节点，因此后序遍历数组的最后一个元素是根节点。 利用上面提到的知识点，每次先找到根节点（也就是最后一个元素），然后确定左右子树，并判断左右子树是否合法，然后找到左右子树的根节点，和一般处理二叉树的问题一样，递归进行判断，代码如下： class Solution &#123; public boolean verifyPostorder(int[] postorder) &#123; if (postorder == null || postorder.length == 0) return true; return helper(postorder, 0, postorder.length - 1); &#125; private boolean helper(int[] postorder, int start, int end) &#123; if (start &gt;= end) return true; int idx; for (idx = start; idx &lt; end; idx++) &#123; if (postorder[idx] &gt; postorder[end]) break; &#125; for (int i = idx; i &lt; end; i++) &#123; if (postorder[i] &lt; postorder[end]) return false; &#125; return helper(postorder, start, idx - 1) &amp;&amp; helper(postorder, idx, end - 1); &#125;&#125; 面试题34：二叉树中和为某一值的路径题目输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 示例 给定如下二叉树，以及目标和 sum &#x3D; 22， 5 &#x2F; \\ 4 8 &#x2F; &#x2F; \\ 11 13 4 &#x2F; \\ &#x2F; \\ 7 2 5 1返回:[ [5,4,11,2], [5,8,4,5]] 分析很明显使用回溯法即可，需要注意的是叶子节点的定义：一棵树中没有子结点（即度为0）的结点称为叶子结点。 另外，在回溯法中使用tempList不断的进行改变时，在方法结束的时候需要删除对应元素再返回。 面试题35：复杂链表的复制题目请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例 输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 分析在复制复杂链表的时候，最麻烦的地方在于random指针的处理，例如在复制位置为 3 的复杂链表时，random却指向了位置为 100 的复杂链表，如果强行去找，那么整体的复杂度可能达到$O(n^2)$。 首先想到的方法是借助一个HashMap，想到使用哈希表的原因是在链表中的查找是$O(n)$的但是在哈希表中的查找却是非常廉价的$O(1)$，虽然使用了$O(n)$的空间复杂度，但是解法思路很清晰，还是值得借鉴的： /*// Definition for a Node.class Node &#123; int val; Node next; Node random; public Node(int val) &#123; this.val = val; this.next = null; this.random = null; &#125;&#125;*/class Solution &#123; public Node copyRandomList(Node head) &#123; if (head == null) return null; Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); Node cur = head; while (cur != null) &#123; map.put(cur, new Node(cur.val)); cur = cur.next; &#125; cur = head; while (cur != null) &#123; map.get(cur).next = map.get(cur.next); map.get(cur).random = map.get(cur.random); cur = cur.next; &#125; return map.get(head); &#125;&#125; 那么有没有不使用辅助空间的方法呢？前面讲到复制复杂链表的难处在于random指针的复制，但是其实原复杂链表的random指针是已经建立完毕的，可以随时达到指定的位置，我们可以利用这一点，建立以下无需额外空间，并且时间复杂度为$O(n)$的算法： 在每个节点的后面插入复制的节点 对复制节点的random链接进行赋值，每一次赋值只需要$O(1)$的时间复杂度 将复制节点拆分出来，生成结果 相应的代码如下： class Solution &#123; public Node copyRandomList(Node head) &#123; if (head == null) return null; // 第一步：插入新节点 Node cur = head; while (cur != null) &#123; Node next = cur.next; cur.next = new Node(cur.val); cur.next.next = next; cur = next; &#125; // 第二步：复制random指针 cur = head; while (cur != null) &#123; if (cur.random != null) &#123; cur.next.random = cur.random.next; &#125; cur = cur.next.next; &#125; // 第三步：拆分 cur = head; Node copyHead = head.next; while (cur != null) &#123; Node next = cur.next; cur.next = cur.next.next; if (next.next != null) &#123; next.next = next.next.next; &#125; cur = cur.next; &#125; return copyHead; &#125;&#125; 面试题36：二叉搜索树与双向链表题目输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 分析这一题看起来比较复杂，但是其实题目中已经暗含了解决方法：二叉搜索树以及排序的xx，所以肯定是会用到中序遍历的，因为二叉搜索树的中序遍历是一个递增序列。实现中序遍历既可以使用迭代，也可以使用递归，使用递归的代码如下： class Solution &#123; private Node prev = null; public Node treeToDoublyList(Node root) &#123; if (root == null) return null; inorder(root); Node head = root; while (head.left != null) &#123; head = head.left; &#125; Node tail = root; while (tail.right != null) &#123; tail = tail.right; &#125; head.left = tail; tail.right = head; return head; &#125; private void inorder(Node root) &#123; if (root == null) return; inorder(root.left); root.left = prev; if (prev != null) prev.right = root; prev = root; inorder(root.right); &#125;&#125; 面试题37：序列化二叉树题目请实现两个函数，分别用来序列化和反序列化二叉树。 示例 你可以将以下二叉树： 1 &#x2F; \\ 2 3 &#x2F; \\ 4 5序列化为 &quot;[1,2,3,null,null,4,5]&quot; 分析可以使用前序遍历来进行序列化，但是普通的前序遍历在遍历到null时便跳过了，所以上面二叉树的前序遍历结果应该为[1,2,3,4,5]，但是前序遍历是[1,2,3,4,5]的二叉树并不是唯一的，因此在遇到null时不能简单的跳过，我们可以将null映射成为一个特殊字符放入到前序遍历的结果中，进而使得通过前序遍历的结果便可以确定相应的二叉树。 代码如下： public class Codec &#123; private static final String splitter = \",\"; private static final String NN = \"$\"; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); buildString(root, sb); return sb.toString(); &#125; private void buildString(TreeNode root, StringBuilder sb) &#123; if (root == null) sb.append(NN).append(splitter); else &#123; sb.append(root.val).append(splitter); buildString(root.left, sb); buildString(root.right, sb); &#125; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; Queue&lt;String&gt; q = new LinkedList&lt;&gt;(); q.addAll(Arrays.asList(data.split(splitter))); return buildTree(q); &#125; private TreeNode buildTree(Queue&lt;String&gt; q) &#123; String s = q.poll(); if (s.equals(NN)) return null; TreeNode root = new TreeNode(Integer.valueOf(s)); root.left = buildTree(q); root.right = buildTree(q); return root; &#125;&#125; 面试题38：字符串的排列题目输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例 输入：s &#x3D; &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] 分析将字符串看做字符数组，其实就是回溯问题，额外添加一个visited数组来判断某位置的字符是否已经使用就可以了。唯一需要注意的是字符可能有相同的，例如s = &quot;aba&quot;，这样直接回溯的话会产生非常多的重复解，处理此类问题的方法是在最开始对字符数组排序，这样重复的元素会在相邻的位置，此时便可以利用i &gt; 0 &amp;&amp; visited[i-1] &amp;&amp; chars[i-1] == chars[i]来舍弃掉重复情况了。 面试题39：数组中出现次数超过一半的数字题目数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 分析对于排序、使用哈希表在这个题目中很显然是不可取的，不再考虑。 首先可以使用快排中partition的思想，如果选中的数字经过partition操作后下标刚好是n/2，证明这个数字是数组的中位数，也就是需要返回的多数元素；如果下标小于n/2，则接着搜索右半分区，如果下标大于n/2，则接着搜索左半分区。该算法的时间复杂度是$O(n)$，但是需要注意的是基于partition的方法会修改原数组，因此如果原数组不能修改则不能使用此方法。 除了partition的方法，其实最简单快捷的方法是使用摩尔投票算法（Boyer-Moore Majority Vote Algorithm），摩尔投票算法便是要解决本题目所描述的问题，摩尔投票算法基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个，下面直接给出代码： class Solution &#123; public int majorityElement(int[] nums) &#123; int major = nums[0], count = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (count == 0) &#123; count++; major = nums[i]; &#125; else if (major == nums[i]) &#123; count++; &#125; else count--; &#125; return major; &#125;&#125; 面试题40：最小的k个数题目输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 输入：arr &#x3D; [3,2,1], k &#x3D; 2输出：[1,2] 或者 [2,1] 分析这一题虽然很简单，但是比较经典，所以写的详细点。 解法1 快排的partition思想 首先需要强调，使用partition来解决问题时会改变原数组，所以只有原数组可以修改时才可以使用partition来解题。 快速排序的partition方法，会返回一个整数j使得a[lo..j-1]小于等于a[j]，且a[j+1..hi]大于等于a[j]，此时a[j]就是数组的第j大元素。可以利用这个特性找出数组的第k个元素，算法时间复杂度为$O(n)$，代码如下： class Solution &#123; public int[] getLeastNumbers(int[] arr, int k) &#123; if (k == 0) return new int[0]; int[] res = new int[k]; k--; int lo = 0, hi = arr.length - 1; while (lo &lt; hi) &#123; int pos = partition(arr, lo, hi); if (pos == k) break; if (pos &lt; k) lo = pos + 1; else hi = pos - 1; &#125; for (int i = 0; i &lt; res.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; private int partition(int[] arr, int lo, int hi) &#123; // 将数组切分为arr[lo..i-1], arr[i], arr[i+1..hi] int i = lo, j = hi + 1; // 左右扫描指针 int v = arr[lo]; // 切分元素，即pivot while (true) &#123; // 扫描左右，检查扫描是否结束并交换元素 while (arr[++i] &lt; v) if (i == hi) break; while (arr[--j] &gt; v) if (j == lo) break; if (i &gt;= j) break; swap(arr, i, j); &#125; swap(arr, lo, j); // 将切分元素v放入正确的位置 return j; // arr[lo..j-1] &lt;= arr[j] &lt;= arr[j+1..hi]达成 &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 上述代码中的partition方法代码摘抄自《算法4》，值得注意的是需要保证传入的参数满足lo &lt; hi时方法才能正常运行。其实也有很多其他版本的写法，例如下面一种，个人认为理解起来很容易： private int partition(int[] arr, int lo, int hi) &#123; int pivot = arr[lo]; int pivotIdx = lo; while (lo &lt; hi) &#123; // 两个内循环的顺序是不能颠倒的 while (lo &lt; hi &amp;&amp; arr[hi] &gt;= pivot) hi--; while (lo &lt; hi &amp;&amp; arr[lo] &lt;= pivot) lo++; swap(arr, lo, hi); &#125; swap(arr, pivotIdx, hi); return hi;&#125; 解法2 使用大顶堆 我们可以创建一个大小为k的大顶堆，接下来不断的读入数据，当大顶堆的数据数量小于k时直接将新数据放入其中，当大顶堆中已经有k个数据时，此时一共有k+1个数据，我们需要舍去一个不可能是最小的k个最小元素之一的数据，这个数据只能是新数据或者是堆顶元素，我们比较这两个元素，当新数据更大时舍弃新数据，反正舍弃堆顶元素并把新数据插入大顶堆中，时间复杂度为$O(n\\log k)$，相应代码如下： class Solution &#123; public int[] getLeastNumbers(int[] arr, int k) &#123; if (k == 0) return new int[0]; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a); for (int num : arr) &#123; if (pq.size() &lt; k) &#123; pq.offer(num); &#125; else &#123; if (pq.peek() &gt; num) &#123; pq.poll(); pq.offer(num); &#125; &#125; &#125; int[] res = new int[k]; int idx = 0; for (int num : pq) &#123; res[idx++] = num; &#125; return res; &#125;&#125; 面试题41：数据流中的中位数题目如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 例如，[2,3,4] 的中位数是 3；[2,3] 的中位数是 (2 + 3) / 2 = 2.5。 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 分析我们需要选择一种(或多种)容器来存放已有数据，最简单的容器是动态数组或者是链表，但是这两种容器在该问题下的性能并不理想：每次插入数据后需要排序，两种容器的时间复杂度均为$O(n)$。二叉搜索树可以把插入数据的的平均时间复杂度降低为$O(\\log n)$级别，但是最差仍然是$O(n)$级别，因此可以使用平衡二叉树（如AVL树）来进行改进，通常AVL树的平衡因子是左右子树的高度差，可以稍作修改，把AVL树的平衡因子改为左右子树节点数目之差，这样便可以用$O(\\log n)$的时间复杂度插入数据，而只需要$O(1)$的时间复杂度求出中位数。 但是调用AVL树略显麻烦，有更好的方法吗？中位数其实将数据分成了两部分：左半部分小于中位数、右半部分大于中位数，且这两部分的数量相等或者仅差一，且中位数只和左边数据的最大值以及右边数据的最小值有关。因此，可以使用大小堆来解决问题：用一个大顶堆实现左边的数据容器，用一个小顶堆实现右边的数据容器，这样插入新数据时时间复杂度为$O(\\log n)$，当求中位数时其实只和两个堆顶元素有关，因此时间复杂度为$O(1)$，具体代码如下： class MedianFinder &#123; private PriorityQueue&lt;Integer&gt; maxHeap, minHeap; private int size; /** * initialize your data structure here. */ public MedianFinder() &#123; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a); // 大顶堆 minHeap = new PriorityQueue&lt;&gt;(); // 小顶堆 &#125; public void addNum(int num) &#123; // 这里的处理流程需要仔细考虑 maxHeap.offer(num); minHeap.offer(maxHeap.poll()); if (maxHeap.size() &lt; minHeap.size()) &#123; maxHeap.offer(minHeap.poll()); &#125; &#125; public double findMedian() &#123; if (maxHeap.size() == minHeap.size()) &#123; return 0.5 * (maxHeap.peek() + minHeap.peek()); &#125; return maxHeap.peek(); &#125;&#125; 面试题42：连续子数组的最大和题目输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例 输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 分析很明显使用动态规划来做，假设f(i)代表以i位置结尾的所有子数组中的和最大值，我们有如下递推公式： 当f(i-1) &lt;= 0时，f(i) = nums[i] 当f(i-1) &gt; 0时，f(i) = f(i-1) + nums[i] 最后，自底向上的写出相应代码： class Solution &#123; public int maxSubArray(int[] nums) &#123; int[] dp = new int[nums.length]; dp[0] = nums[0]; int max = dp[0]; for (int i = 1; i &lt; nums.length; i++) &#123; dp[i] = dp[i - 1] &gt; 0 ? dp[i - 1] + nums[i] : nums[i]; max = Math.max(max, dp[i]); &#125; return max; &#125;&#125; 面试题43：1～n整数中1出现的次数题目输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次 分析一个比较直观的方法是从1到n进行遍历，对于其中的每一个数字，求出其中1的个数，最后累加所有数字的结果便得到最终结果，时间复杂度为$O(n \\log n)$，但是这样运行程序时会超时。 所以我们不能一个数一个数的处理，需要将很多个数放在一起看，也就是找规律。 对于整数234来说，假设f(n)表示从 1 到 n 的所有数中 1 出现的次数。我们可以首先考虑最高位的情况，对于这个例子最高位为2，因此最高位等于 1 的情况为100~199，一共 100 个，对于个位和十位，由于最该位是2，所以这两位可以取1~99以及100~199，也就是有2*f(99)种情况，还有剩余的情况是200~234的时候个位和十位的情况，也就是相当于f(34)。因此总结如下：f(234) = 100 + 2*f(99) + f(34)。对于最高位为1的情况，稍微有点不同，例如对于123来说，最高位为 1 的情况只有 24 个，但是思路是一样的，整体代码如下： class Solution &#123; public int countDigitOne(int n) &#123; if (n &lt; 1) return 0; if (n &lt; 10) return 1; // x表示最高位，y表示10^(h-1)，h代表n的位数 int y = 1, x = n; while (x &gt; 9) &#123; x /= 10; y *= 10; &#125; if (x == 1) &#123; return n - y + 1 + countDigitOne(y - 1) + countDigitOne(n % y); &#125; else &#123; return y + x * countDigitOne(y - 1) + countDigitOne(n % y); &#125; &#125;&#125; 其实还有一些更数学的方法，将更多的精力花在了寻找更深层次的规律上，这里就不介绍了。 面试题44：数字序列中某一位的数字题目数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 分析首先能想到的方法便是按照顺序不断的生成数字0, 1, 2, ...，并记录已有数字的位数和，直到位数之和大于等于第 n 位，证明第 n 位数字一定在目前这个数字里，我们再从该数字中找到对应的那一位即可。 我们可以加快这个过程，例如求第n = 1001位对应的数字，只有一位的数字有0~9一共 10 个，所以这 10 个可以直接跳过，还需要向后寻找1001-10=991个， 同理，二位数范围是10~99，一共有 90 个，90*2 &lt; 991，因此这 90 个数也可以跳过，还需要寻找991-90*2=811个，接下来是 900 个 三位数，由于900*3 &gt; 811，因此第 811 位是某个三位数，由于811=270*3+1，说明 811 位是从 100 开始的第 270 个数即 370 的中间一位，也就是 7。 相应的代码如下： class Solution &#123; public int findNthDigit(int n) &#123; if (n &lt; 10) return n; int digits = 1; while (true) &#123; int cnt = count(digits); if (n &lt; cnt) break; n -= cnt; digits++; &#125; int resNum = (int) (Math.pow(10, digits - 1) + n / digits); return String.valueOf(resNum).charAt(n % digits) - '0'; &#125; private int count(int digits) &#123; if (digits == 1) return 10; return (int) (9 * digits * Math.pow(10, digits - 1)); &#125;&#125; 面试题45：把数组排成最小的数题目输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 示例 输入: [10,2]输出: &quot;102&quot;输入: [3,30,34,5,9]输出: &quot;3033459&quot; 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 分析这道题最直接的方法是先求出这个数组所有数字的全排列，然后把每个排列拼接起来比较大小，但是 n 个数字共有 n! 个排列，复杂度太高。 这道题其实希望我们能找到一个排序规则，数组根据这个排序规则排序后能排列成一个最小的数字，根据题目的要求，两个数字m和n能够拼接成mn或者nm，如果mn &lt; nm应该定义m小于n，反之应该定义m大于n。 由于m和n的长度不一致，比较起来有些麻烦，我们可以转而比较字符串mn与字符串nm的相对大小。 class Solution &#123; public String minNumber(int[] nums) &#123; if (nums == null || nums.length == 0) return \"\"; int n = nums.length; String[] strs = new String[n]; for (int i = 0; i &lt; n; i++) strs[i] = String.valueOf(nums[i]); Arrays.sort(strs, (s1, s2) -&gt; (s1 + s2).compareTo(s2 + s1)); StringBuilder sb = new StringBuilder(); for (String str : strs) sb.append(str); return sb.toString(); &#125;&#125; 面试题46：把数字翻译成字符串题目给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot; 分析首先可以使用递归，但是会计算很多重复情况，另外题目只要求输出翻译方法的个数，因此在这里选用动态规划。 假设f(n)表示翻译长度为n的字符串s有多少种方法，有如下递推公式： f(n) = f(n-1) 如果满足s.charAt(n-1) == &#39;1&#39; || (s.charAt(n-1) == &#39;2&#39; &amp;&amp; s.charAt(n) &lt; &#39;6&#39;)，则有f(n) = f(n) + f(n-2)。 class Solution &#123; public int translateNum(int num) &#123; String s = String.valueOf(num); int n = s.length(); int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 1; i &lt; n; i++) &#123; dp[i + 1] = dp[i]; if (s.charAt(i - 1) == '1' || (s.charAt(i - 1) == '2' &amp;&amp; s.charAt(i) &lt; '6')) &#123; dp[i + 1] += dp[i - 1]; &#125; &#125; return dp[n]; &#125;&#125; 需要注意的是，如果题目是将 1 翻译成 “a” ，2 翻译成 “b”，……，12 翻译成 “l”，……，26 翻译成 “z”；这个时候情况会有所不同，f(n) = f(n-1)在当前字符是“0”时是不成立的。 面试题47：礼物的最大价值题目在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例 输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 12解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 分析同样使用动态规划来解决此类问题，假设f(i, j)表示到达位置(i, j)时能拿到的最大礼物价值，我们有递推公式f(i, j) = max{f(i-1, j), f(i, j-1)} + gift[i, j]。 在这里我们可以不开辟新的空间，直接在原棋盘上进行操作，代码如下： class Solution &#123; public int maxValue(int[][] grid) &#123; if (grid == null || grid.length == 0 || grid[0].length == 0) return 0; int m = grid.length, n = grid[0].length; for (int i = 1; i &lt; m; i++) &#123; grid[i][0] += grid[i - 1][0]; &#125; for (int j = 1; j &lt; n; j++) &#123; grid[0][j] += grid[0][j - 1]; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; grid[i][j] += Math.max(grid[i - 1][j], grid[i][j - 1]); &#125; &#125; return grid[m - 1][n - 1]; &#125;&#125; 面试题48：最长不含重复字符的子字符串题目请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 分析是一道滑动窗口的题，使用HashSet或者HashMap可以很轻松的解决，在这一题中使用HashSet会有两层循环，但是整体的时间复杂度仍然是$O(n)$，下面给出使用HashMap的代码： class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int slow = 0; int res = 0; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (map.containsKey(c)) &#123; slow = Math.max(slow, map.get(c) + 1); &#125; res = Math.max(res, i - slow + 1); map.put(c, i); &#125; return res; &#125;&#125; 另外，当确定字符串中只有小写字母时可以使用大小为 26 的数组起到哈希表的作用，当字符串中只有ASCII码字符时可以使用大小为 256 的数组起到哈希表的作用。 面试题49：丑数题目我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 示例 输入: n &#x3D; 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明： 1 是丑数。 n 不超过1690。 分析由于丑数的因子只有2、3和5，因此新丑数的生成是根据在旧丑数的基础上乘上2、3或5得到的。我们采用动态规划+三个指针来解决该问题： class Solution &#123; public int nthUglyNumber(int n) &#123; if (n == 1) return 1; int[] ugly = new int[n]; ugly[0] = 1; int p2 = 0, p3 = 0, p5 = 0; for (int i = 1; i &lt; n; i++) &#123; int min = Math.min(2 * ugly[p2], Math.min(3 * ugly[p3], 5 * ugly[p5])); ugly[i] = min; if (min == 2 * ugly[p2]) p2++; if (min == 3 * ugly[p3]) p3++; if (min == 5 * ugly[p5]) p5++; &#125; return ugly[n - 1]; &#125;&#125; 面试题50-1：字符串中第一个只出现一次的字符题目在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 分析非常简单，利用HashMap遍历两次，第一次记录每个字符出现的次数，第二次找到第一个只出现一次的字符。 面试题50-2：字符流中第一个只出现一次的字符题目请实现一个函数，用来找出字符流中第一个只出现一次的字符。 注：字符属于ASCII码字符集 分析字符流的意思是字符只能一个一个的出来并且是动态的，其实解法和上题类似，由于题目告诉我们字符是属于ASCII码字符集的，所以我们可以使用大小为 256 的数组来表示哈希表，以字符的ASCII码作为哈希表的key，字符对应的位置作为哈希表的value。然后将数组元素全部初始化为 -1，当读取到某个字符时将字符位置存入value中，如果之前读取过该字符（即value &gt;= 0），将value赋值为-2，代表重复出现过。最后对哈希表遍历，在value &gt;= 0的键值对中找到最小的value，该value所对应的key即为字符流中第一个只出现一次的字符。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://www.yingzq.com/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://www.yingzq.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}]},{"title":"《剑指offer第二版》阅读笔记（一）","slug":"sword-finger-offer-notes","date":"2020-02-19T07:10:52.000Z","updated":"2020-03-19T05:21:01.794Z","comments":true,"path":"2020/02/19/sword-finger-offer-notes/","link":"","permalink":"http://www.yingzq.com/2020/02/19/sword-finger-offer-notes/","excerpt":"面试季来临，于是最近两天阅读了《剑指offer第二版》这本程序员面试必备书籍，全书题目不多，但是涵盖了许多重要的知识点，通过自己的阅读也收获良多，所以写下这个阅读笔记。该笔记对书中的面试题进行了自己的分析，相比于原书有的放矢，因此精简了很多，这样做一是加深自己对每个题的印象，二是可以方便今后复习时无需再次看原书，简单的过一下笔记就好。","text":"面试季来临，于是最近两天阅读了《剑指offer第二版》这本程序员面试必备书籍，全书题目不多，但是涵盖了许多重要的知识点，通过自己的阅读也收获良多，所以写下这个阅读笔记。该笔记对书中的面试题进行了自己的分析，相比于原书有的放矢，因此精简了很多，这样做一是加深自己对每个题的印象，二是可以方便今后复习时无需再次看原书，简单的过一下笔记就好。 注：使用的《剑指offer第二版》是2017年出版的。另外，原书代码是C++，本文侧重于使用Java，但是其实编程语言并不是重点，主要是学习思想以及与编程语言无关的代码风格。 系列文章 《剑指offer第二版》阅读笔记（一） 《剑指offer第二版》阅读笔记（二） 《剑指offer第二版》阅读笔记（三） 面试题3-1：找出数组中重复的数字题目在一个长度为 n 的数组 nums 里的所有数字都在 0~n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例： 输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 分析有两个很容易想到的方案： 排序，然后遍历数组，判断nums[i] == nums[i-1]，时间复杂度$O(n\\log n)$，空间复杂度$O(1)$ 使用HashSet，时间复杂度$O(n)$，空间复杂度$O(n)$ 但是这样题目中“所有数字都在 0~n-1 之间”的条件根本没有用到，这也提示我们需要认真阅读题中每一句话，而不能惯性思维，题目看到一半或者大致一看就开始码代码了。 那这个条件怎么用呢？由于所有的数字都在 0~n-1 之间，和数组的下标范围刚好一致，如果数组中没有重复数字，那么排序后数组的索引和数值会一一对应，即nums[i] = i，而真实情况是有一些数字是重复的，所以会有多个数字来竞争某个特定索引，这样便可以判断该索引对应的数字是有重复的。 那如何排序无重复数字的数组呢？我们可以遍历数组，每次遇到索引i，如果有nums[i] == i，说明此数字已在正确位置；否则需要将数字nums[i]放到正确的位置，即放在索引为nums[i]的位置，此时可以将索引为i和nums[i]的元素进行交换，这样索引为nums[i]的数字nums[nums[i]]便处于正确位置了。这样完成遍历后，所有的数字都会和自己的索引一一对应。 对于有重复数字的数组而言，会遇到nums[i] != i但是nums[nums[i]] == nums[i]，这说明在索引nums[i]的位置有两个数字竞争，也就是数字nums[i]肯定是重复的。 相应的代码如下： class Solution &#123; public int findRepeatNumber(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; // nums[i]应该放到索引i的位置 while (nums[i] != i) &#123; if (nums[nums[i]] == nums[i]) &#123; return nums[i]; &#125; swap(nums, i, nums[i]); &#125; &#125; return -1; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 虽然是双重循环，但是每一个数到达相应正确的位置后便不会变化了，总体时间复杂度为$O(n)$，空间复杂度$O(1)$。 这一题借助数组的下标作为key来寻找重复元素，其实本质上还是哈希表，只不过使用HashSet、HashMap明面上开辟了空间，而借助数组下标巧妙的节省了空间。因此对于元素在0~n-1、1~n甚至k~n+k-1之间的数组的相关问题，可以考虑这种思路。 面试题3-2：不修改数组找出重复元素题目给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。请找出数组中任意一个重复的数字，但不能修改输入的数组。 分析和上题一样，不修改原数组可以使用HashSet轻松完成，那么如何使用数字在1到n之间的条件来降低时间或空间复杂度呢？我们在这里还可以使用二分查找的思想，我们把1~n的数字从中间的数字m分成两部分，前一半为1~m，后一半为m+1~n，如果1~m之间的数字的数量大于m，则证明这一半的区间一定包含重复数字；否则，另一半m+1~n的区间里一定包含重复的数字，我们可以继续把包含重复数字的区间一分为二，直到找到一个重复数字，具体代码如下： class Solution &#123; public int findDuplicate(int[] nums) &#123; int lo = 1, hi = nums.length - 1; while (lo &lt; hi) &#123; int mid = lo + (hi - lo) / 2; int cnt = 0; for (int num : nums) &#123; if (num &lt;= mid) &#123; cnt++; &#125; &#125; if (cnt &gt; mid) &#123; hi = mid; &#125; else &#123; lo = mid + 1; &#125; &#125; return lo; &#125;&#125; 算法的时间复杂度为$O(n\\log n)$，空间复杂度为$O(n)$。需要注意的是，这个算法并不能找出所有的重复数字，算法能work的重要点是数组长度是n+1而数字范围是1~n。 面试题4：二维数组中的查找题目在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例 现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target &#x3D; 5，返回 true。给定 target &#x3D; 20，返回 false。 分析乍一看可以使用二分查找，但是会有点问题，对于任意matrix[row][col]，比它小的元素、比它大的元素都是一个不规则形状，而且是存在重叠的，所以是不好处理的。 注意到右上角元素的特殊性：是同一行的最大值，是同一列的最小值。如果target大于当前位置的值，则target肯定不处于当前行中，因为行已经排序，所以考虑下一行；反之如果target小于当前位置的值，则target肯定不处于当前列中，因为列同样已经排序，所以考虑前一列。每一次我们可以排除一行或者一列，总体的时间复杂度为$O(m+n)$，代码如下： class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false; int row = 0, col = matrix[0].length - 1; while (row &lt; matrix.length &amp;&amp; col &gt;= 0) &#123; if (matrix[row][col] == target) return true; if (target &gt; matrix[row][col]) &#123; row++; &#125; else &#123; col--; &#125; &#125; return false; &#125;&#125; 注：其实选取左下角的元素也是可以的，同样可以每次排除一行或者一列。 面试题5：替换空格题目请实现一个函数，把字符串 s 中的每个空格替换成”%20” 分析非常简单，遍历字符串，当遇到空格时进行替换即可，值得注意的是java中String是不可变的，循环中不能使用String不断拼接而需要用StringBuilder代替。时间复杂度和空间复杂度均为$O(n)$。 但是这种解法并不是题目的本意，题目的本意是希望将字符串当做字符数组，然后实现原地更新，但是由于Java中String类型不可变导致该题目被简化。在这里为了不投机取巧，我们将输入改为可变的StringBuilder类型，然后在上面进行原地更新。 由于从前向后更新字符串时，我们会发现当 i 位置的元素被替代时，需要将 i 位置后面的所有元素向右移动 2 个位置来保证不会被覆盖。也就是说当从前向后更新元素时，前面的元素的更新会影响到所有后面的元素，所以我们可以换种思路：从后向前更新，因为后面元素的更新并不会影响到前面的元素。 再结合双指针的技巧，我们有如下思路： 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。 令 p1 指向字符串原来的末尾位置，p2 指向字符串现在的末尾位置。p1 和 p2 从后向前遍历，当 p1 遍历到一个空格时，就需要令 p2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 p1 指向字符的值。从后向前遍是为了在改变 p2 所指向的内容时，不会影响到 p1 遍历原来字符串的内容。 当 p2 遇到 p1 时（p1 &gt;= p2），或者遍历结束（p1 &lt; 0），退出。 具体的代码如下： public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int p1 = str.length() - 1; for (int i = 0; i &lt;= p1; i++) &#123; if (str.charAt(i) == ' ') str.append(\" \"); &#125; int p2 = str.length() - 1; while (p1 &gt;= 0 &amp;&amp; p1 &lt; p2) &#123; char c = str.charAt(p1); if (c == ' ') &#123; str.setCharAt(p2--, '0'); str.setCharAt(p2--, '2'); str.setCharAt(p2--, '%'); &#125; else &#123; str.setCharAt(p2--, c); &#125; p1--; &#125; return str.toString(); &#125;&#125; 类似的题目还有很多，比如：有两个排序数组A1和A2，A1的末尾有足够多的空余空间容纳A2，请将A2的所有数字合并到A1中并且所有的数字是排序的。最好的选择也是从后向前更新，使得移动的次数是最少的。 这类题目共同的特点是从前向后进行移动、更新时，前面元素的移动迫使后面的元素也要随之移动，从而重复移动了很多次。这个时候我们就可以考虑从后向前进行更新，这样就能减少移动次数，从而提升效率。 面试题6：从尾到头打印链表题目输入一个链表的头节点，从尾到头反过来返回每个节点的值。 分析链表只能顺序访问，但是却需要后面的先打印， 所以主要有两种常见方法： 先进后出（FIFO）的需要，因此可以使用栈 从后向前打印，可以使用递归，先走至链表末端，回溯时依次将节点值加入列表 这两种方法的时间复杂度均为$O(n)$，空间复杂度均为$O(n)$。 面试题7：重建二叉树题目输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 示例 给出前序遍历 preorder &#x3D; [3,9,20,15,7]中序遍历 inorder &#x3D; [9,3,15,20,7]返回如下的二叉树： 3 &#x2F; \\ 9 20 &#x2F; \\ 15 7 分析经验总结：二叉树的问题一般都是分治思想，递归去做。因为二叉树本身就是递归定义的。 首先需要明白前序遍历、中序遍历、后序遍历的意义： 前序遍历：父节点 -&gt; 左子节点 -&gt; 右子节点 中序遍历：左子节点 -&gt; 父节点 -&gt; 右子节点 后序遍历：左子节点 -&gt; 右子节点 -&gt; 父节点 注： 需要掌握这三种遍历的递归以及迭代的实现！LeetCode有相应原题。 我们可以发现前序遍历的第一个结点一定是根节点，在中序遍历中，根结点把中序遍历序列分成了两个部分，左边部分构成了二叉树的根结点的左子树，右边部分构成了二叉树的根结点的右子树。我们可以找到根节点在中序遍历中的位置，然后可以进一步得出左子树和右子数的大小，从而可以在前序遍历序列中找到根节点的左子节点和右子节点，最后递归的进行便能够构建二叉树。 重建二叉树示意图 具体的代码如下，很容易看懂： /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(preorder, inorder, 0, 0, inorder.length - 1); &#125; private TreeNode helper(int[] preorder, int[] inorder, int preStart, int inStart, int inEnd) &#123; if (preStart &gt;= preorder.length || inStart &gt; inEnd) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[preStart]); // index代表目前的根节点在中序遍历中的位置 int index; for (index = inStart; index &lt;= inEnd; index++) &#123; if (inorder[index] == root.val) break; &#125; // 递归的构建子树 root.left = helper(preorder, inorder, preStart + 1, inStart, index - 1); root.right = helper(preorder, inorder, preStart + index - inStart + 1, index + 1, inEnd); return root; &#125;&#125; 另外，根据中序遍历和后序遍历也使用类似的方法构建出二叉树，因为后序遍历的最后一个节点一定是根节点，然后不断的根据中序遍历找到根节点的左子节点、右子节点即可。 面试题8：二叉树的下一个节点题目给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 分析主要考察中序遍历的知识，中序遍历求当前节点的下一个节点有以下几种情况： 当前节点为空，则直接返回空。 当前节点存在右子树，则下一个节点为右子树最左子节点。 若该节点不存在右子树，这时又分为两种情况： 该节点为父节点的左子节点，则下一个节点为其父节点； 该节点为父节点的右子节点，则沿着父节点向上遍历，直到找到一个节点的父节点的左子节点为该节点，此时该节点的父节点便是下一个节点。 相应代码如下： /*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; // 指向父节点 TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode == null) return null; if (pNode.right != null) &#123; pNode = pNode.right; while (pNode.left != null) &#123; pNode = pNode.left; &#125; return pNode; &#125; while (pNode.next != null) &#123; if (pNode.next.left == pNode) return pNode.next; pNode = pNode.next; &#125; return null; &#125;&#125; 面试题9：用两个栈实现队列题目用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 分析队列是先进先出，栈是先进后出，所以利用两个栈，先将数据压入stack1，再将stack1的数据压入stack2，此时stack2中的数据进行弹出时便相当于队列。 由于过程中 appendTail 和 deleteHead 是交叉进行的，我们可以做如下约定： 进行 appendTail 时，直接向stack1中压入数据即可。 进行 deleteHead 时，如果stack2不为空，直接输出stack2弹出的结果；否则将stack1中所有数据弹出并压入stack2中，然后再输出stack2中弹出的结果。 此时利用均摊的思想，appendTail 和 deleteHead 函数的时间复杂度为$O(1)$。 与之相关的问题还有用两个队列实现一个栈，假如有两个队列q1和q2，当模拟栈压入数据时，只需要向q1中压入数据，当模拟栈弹出数据时，由于队列只能弹出队首的数据，所以有如下思路：假设n是目前q1中的数据总数，对于前n-1个数据，将q1中的数据依次弹出并同时插入到q2中，q1中的最后一个数据则是我们需要的结果，弹出并返回即可。这样实现的系统插入数据的时间复杂度为$O(1)$，弹出数据则为$O(n)$。 注：其实仅用一个队列便可以实现栈，只需要将队列q1前n-1个弹出的元素重新插回到q1中即可，根本不需要用到q2。 面试题10-1：斐波那契数列题目写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) &#x3D; 0, F(1) &#x3D; 1F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 分析很多C语言教科书在讲述递归函数时，都会用斐波拉契数列作为例子，其实那种递归的写法效率是非常非常低的，时间复杂度是指数级的，千万不要用！ 使用递归方法之所以低效是因为有着大量的重复计算，例如计算F(10)和F(9)向下递归时都会计算F(8)的值。因此我们可以将中间状态保存起来，减少计算量，自底向上的代码如下： class Solution &#123; public int fib(int n) &#123; if (n &lt; 2) return n; long first = 0; long sec = 1; for (int i = 2; i &lt;= n; i++) &#123; long nval = first + sec; first = sec; sec = nval % 1000000007; &#125; return (int) sec; &#125;&#125; 该算法的时间复杂度为$O(n)$，其实还有复杂度更低的基于数学的方法，将斐波拉契数列推导成为一个较为生僻的公式，一般不常用，在这里就略过了。 面试题10-2：青蛙跳台阶问题题目一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 分析设跳上n级台阶有 f(n) 种跳法，在所有跳法中，青蛙的最后一步只有两种情况：跳上 1 级或 2 级台阶： 当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n-1) 种跳法； 当为 2 级台阶： 剩 n-2 个台阶，此情况共有 f(n-2) 种跳法。 可以得出f(n) = f(n-1) + f(n-2)，因此本题可转化为求斐波那契数列第 n 项的值。 面试题11：旋转数组的最小数字题目把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 输入：[3,4,5,1,2]输出：1输入：[2,2,2,0,1]输出：0 分析最简单的一个解法是遍历数组，时间复杂度$O(n)$。但是没有用到“旋转数组”的性质，很明显，对于在经过旋转的递增数组的查找，是需要用二分查找来实现$O(\\log n)$时间复杂度算法。 对于经过旋转的有序数组，当数组内没有相等元素时，一共有如下3种情景： 旋转的有序数组 可以看出nums[lo], nums[mid], nums[hi]的相对大小决定了最小值所在的区间，这里我们只使用nums[mid], nums[hi]进行分析： 当nums[mid] &gt; nums[hi]时，说明是情景二，此时最小值在右半区，因此lo = mid + 1即可。 当nums[mid] &lt; nums[hi]时，说明是情景一或情景三，此时两种情景的最小值均在左半区，但是有可能就是nums[mid]，因此hi = mid即可。 当lo == hi时，循环停止，nums[lo]即为最小值。 但是这一题是可能会有重复元素的，当出现nums[mid] == nums[hi]时最小元素在哪个半区呢？其实是都有可能的，是无法确定的，例如 对于 [2,1,2,2,2] 最小值在左半区，对于 [2,2,2,1,2] 则是在右半区。在这里我们直接舍弃nums[hi]，也就是将hi--即可，这是因为此时循环未停止，说明mid &lt; hi，但是此时nums[mid] == nums[hi]，所以lo~hi-1之间的最小值是一定和lo~hi之间的最小值相等的，因此直接舍弃最后一个元素是不影响结果的。 最终代码如下： class Solution &#123; public int minArray(int[] numbers) &#123; int lo = 0, hi = numbers.length - 1; while (lo &lt; hi) &#123; int mid = lo + (hi - lo) / 2; if (numbers[mid] &gt; numbers[hi]) &#123; lo = mid + 1; &#125; else if (numbers[mid] &lt; numbers[hi]) &#123; hi = mid; &#125; else &#123; hi--; &#125; &#125; return numbers[lo]; &#125;&#125; 面试题12：矩阵中的路径题目请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。 示例 输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;输出：true 分析很明显直接使用回溯法（或者说DFS）即可，直接上代码： class Solution &#123; public boolean exist(char[][] board, String word) &#123; if (board == null || board.length == 0 || board[0].length == 0) return false; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (exist(board, word, 0, i, j)) return true; &#125; &#125; return false; &#125; private boolean exist(char[][] board, String word, int idx, int x, int y) &#123; if (idx == word.length()) return true; int m = board.length, n = board[0].length; if (x &lt; 0 || y &lt; 0 || x == m || y == n || word.charAt(idx) != board[x][y]) return false; board[x][y] ^= 256; int[][] dirs = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;&#125;; for (int[] dir : dirs) &#123; if (exist(board, word, idx + 1, x + dir[0], y + dir[1])) return true; &#125; board[x][y] ^= 256; return false; &#125;&#125; 里面有几个点可以学习： 首先是边界条件、结束条件的判断放到了最前面，使得代码非常清晰。 其次，对于该问题的回溯法来说，需要一个与board相同大小的visited数组来记录某个位置是否已经访问，但是这样便需要额外的开辟$O(n^2)$的空间，这里一个更巧妙的办法是修改原数组的值，这里使用了board[x][y] ^= 256修改原数组，然后在方法调用结束时再次异或将数组还原，其实这里不一定要使用异或，只需要将该位置的字符先变成一个有区分度的字符，最后再修改回来即可。 最后，使用dirs的方向数组可以任意控制方向，而且使得代码清晰而简洁。 面试题13：机器人的运动范围题目地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 分析同样使用回溯法（或者说DFS），只需要写一个判断当前方格是否有效的方法即可；另外可以使用成员变量count来进行记录，每次调用方法前记得进行初始化。 由于并不需要返回运行的完整路径，所以这一题使用BFS也是很好的选择。 面试题14：剪绳子题目给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 分析首先可以使用自底向上的动态规划。设f(n)为长度为n的绳子可以得到的最大乘积，我们可以将f(n)的问题分解成求更小规模f(n-k)的问题，可以得出递推公式为f(n) = max{f(1)*f(n-1), f(2)*f(n-2), ... , f(n-1)*f(1)}，但是这个公式中还存在一些问题，例如求长度为3的绳子时可以分为长度为1、2的两段绳子，这时是可以不需要将长度为2的绳子再次进行裁剪的，因此当绳子长为2时函数返回1，但是当绳子长度大于2时需要f(2) = 2。可以证明，当n &lt; 4时n &gt; i*(n - i)，即此时绳子不裁剪时反而有最大值，所以这部分值做特殊处理即可。算法有双重循环，时间复杂度为$O(n^2)$，空间复杂度为$O(n)$，具体代码如下： class Solution &#123; public int cuttingRope(int n) &#123; if (n &lt; 2) return 0; if (n == 2) return 1; if (n == 3) return 2; int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; dp[3] = 3; for (int i = 4; i &lt;= n; i++) &#123; int max = 0; for (int j = 1; j &lt;= i / 2; j++) &#123; // 另一半情况是对称的，因此搜索一半即可 max = Math.max(max, dp[j] * dp[i - j]); &#125; dp[i] = max; &#125; return dp[n]; &#125;&#125; 第二种解法利用到了一点数学知识：n个数和一定的情况下，数字越均匀，积越大。 但是并不知道具体需要分成多少段（即题目中的m不确定），因此m需要遍历2~n，在每一次循环中，尽可能的均分绳子得到局部最大值，最后得到全局最大值。 最后一种解法可以说是找规律，也可以说是贪婪算法：当 n &gt; 4 时尽可能的分解出更多的3，当 n = 4 时分解出两个2。简单证明下：当n &lt; 4时直接返回特定结果，当n = 4时最大值为2*2=4，当n &gt; 4时任何整数都可以使用3和2来合成，且有2*(n-2) &gt; n, 3*(n-3) &gt; n，也就是当绳子剩下的长度大于4时，应该将它剪成长度为3或者长度为2的绳子，另外当n &gt; 4时2*(n-2) &lt;= 3*(n-3)，因此应该尽可能剪出更多的长度为3的绳子段，代码如下： class Solution &#123; public int cuttingRope(int n) &#123; if (n &lt; 4) return n - 1; if (n % 3 == 0) &#123; // 全部分解为3 return (int) Math.pow(3, n / 3); &#125; else if (n % 3 == 1) &#123; // 分解到最后剩一个4 return (int) Math.pow(3, n / 3 - 1) * 4; &#125; else &#123; // 分解到最后剩一个2 return (int) Math.pow(3, n / 3) * 2; &#125; &#125;&#125; 也可以不借助Math.pow()，使用迭代的方式： class Solution &#123; public int cuttingRope(int n) &#123; if (n &lt; 4) return n - 1; int res = 1; while (n &gt; 4) &#123; res *= 3; n -= 3; &#125; return res * n; &#125;&#125; 面试题15：二进制中1的个数题目请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 分析很显然直接使用位运算即可。值得注意的是，在java中&gt;&gt;是带符号右移，正数右移高位补0，负数右移高位补1；&gt;&gt;&gt;是无符号右移，无论是正数还是负数，高位通通补0。另外java中有Integer.bitCount()方法，可以直接统计输入整数对应二进制中1的个数。 还有一种令人眼前一亮的方案：n &amp; (n - 1)会把n最右边的 1 变成 0。那么一个整数的二进制表示中有多少个 1，就可以进行多少次这样的操作，该方法对于的代码如下： public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int count = 0; while (n != 0) &#123; count++; n = n &amp; (n - 1); &#125; return count; &#125;&#125; 其实n &amp; (n - 1)还是有很多妙用的，例如可以直接判断出一个整数是不是2的整数次方。 面试题16：数值的整数次方题目实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数。 分析最开始想到的就是循环exponent次，但是其实不用，比如我们求某个数的32次方，我们只需要知道这个数的16次方，然后两个16次方进行相乘即可，求16次方又只需要知道8次方的值，以此类推，时间复杂度为$O(\\log n)$。 这样这一题基本解决了，但是需要注意细节！如果exponent是负数怎么办？exponent奇数偶数情况是否一样？除以2的操作可以使用位运算代替？代码如下： class Solution &#123; public double myPow(double x, int n) &#123; if (n == 0) return 1; if (n == Integer.MIN_VALUE) &#123; x = x * x; n &gt;&gt;= 1; &#125; if (n &lt; 0) &#123; n = -n; x = 1 / x; &#125; return n % 2 == 0 ? myPow(x * x, n &gt;&gt;&gt; 1) : x * myPow(x * x, n &gt;&gt;&gt; 1); &#125;&#125; 其中有个边界问题需要处理：当一个负数 n 加上负号变为正数时，如果 n 有可能等于 Integer.MIN_VALUE，可能会发生错误。 最后再提一点位运算： n / 2的操作可以替换为n &gt;&gt; 1，注意这里是 1，只需要移动 1 位即可，不要弄错了。另外要注意&gt;&gt;和&gt;&gt;&gt;的区别。 判断奇偶性的n % 2其实也可以用位运算n &amp; 1代替：当(n &amp; 1) == 0时为偶数，当(n &amp; 1) == 1时为奇数。 面试题17：打印从1到最大的n位数题目输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 分析不考虑大数问题此题非常简单，先求出最大的n位十进制数，然后循环打印即可。此题没有规定n的大小，所以n有可能非常大，所代表的十进制数可能超出int，甚至是long的上界，此时应该如何处理呢？数组是可以很长的，因此我们可以利用长度为n的数组来代表长度为n的十进制数，然后在数组上模拟整数加法即可。 面试题18：删除链表的节点题目给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 分析非常简单，有一个要点是使用一个虚拟节点，这样当要删除的节点刚好是头结点时也不需要额外处理。 面试题19：正则表达式匹配题目请实现一个函数用来匹配包含&#39;.&#39;和&#39;*&#39;的正则表达式。模式中的字符&#39;.&#39;表示任意一个字符，而&#39;*&#39;表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。 示例 输入:s &#x3D; &quot;aab&quot;p &#x3D; &quot;c*a*b&quot;输出: true解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 分析如果没有*，问题会很简单：我们只需要从左到右检查匹配串s是否能匹配模式串p的每一个字符，遇到.也只需要简单处理下就可以了。 当模式中有*时，情况就比较麻烦了，在这里使用动态规划来做。 状态定义二维数组dp，dp[i][j]表示s的前i个是否能被p的前j个匹配。 转移方程怎么想转移方程？首先想的时候从已经求出了dp[i-1][j-1]入手，再加上已知s[i]、p[j]，要想的问题就是怎么去求dp[i][j]。 先考虑最简单的，如果s[i] == p[j]，那么有dp[i][j] = dp[i-1][j-1]。 如果p[j] == &#39;.&#39;，那么有dp[i][j] = dp[i-1][j-1]。 如果p[j] == &#39;*&#39;，情况比较复杂，下文主要探讨这种情况。 *的含义是匹配零个或多个前面的那一个元素，所以要考虑它前面的元素p[j-1]。*跟着它前一个字符走，前一个能匹配上s[i]，*才能有用，前一个都不能匹配上s[i]，*也无能为力，只能让前一个字符消失，也就是匹配0次前一个字符。 所以按照p[j-1]和s[i]是否相等，我们分为两种情况： 如果p[j-1] != s[i]，这就是刚才说的那种前一个字符匹配不上的情况，那么就将*和它前面的字符全部舍弃，因此有dp[i][j] = dp[i][j-2]。 如果p[j-1] == s[i] || p[j-1] == &#39;.&#39;，这说明最后一个字符是可以匹配的，现在关键是要看前面的部分是否匹配，这里可以有3种情况，只需要满足其一即可： dp[i][j] = dp[i-1][j]，多个字符匹配的情况，例如a* -&gt; aa dp[i][j] = dp[i][j-1]，单个字符匹配的情况，例如a* -&gt; a dp[i][j] = dp[i][j-2]，不进行匹配的情况，即舍弃a* 最终代码如下： class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; return false; &#125; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; for (int i = 0; i &lt; p.length(); i++) &#123; if (p.charAt(i) == '*' &amp;&amp; dp[0][i-1]) &#123; dp[0][i+1] = true; &#125; &#125; for (int i = 0 ; i &lt; s.length(); i++) &#123; for (int j = 0; j &lt; p.length(); j++) &#123; if (p.charAt(j) == '.') &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == s.charAt(i)) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == '*') &#123; if (p.charAt(j-1) != s.charAt(i) &amp;&amp; p.charAt(j-1) != '.') &#123; dp[i+1][j+1] = dp[i+1][j-1]; &#125; else &#123; dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]); &#125; &#125; &#125; &#125; return dp[s.length()][p.length()]; &#125;&#125; 这题实在是有一点点麻烦~~ 面试题20：表示数值的字符串题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”及”-1E-16”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。 分析表示数值的字符串遵循模式A[.[B]][e|EC]或者.B[e|EC]，其中A为数值的整数部分，B紧跟着小数点为数值的小数部分，C紧跟着e或E为数值的指数部分。上述A和C都是整数（可以有正负号，也可以没有），而B是一个无符号整数。这一题具体的代码我认为不重要，根据这两个模式按部就班的判断即可。 面试题21：调整数组顺序使奇数位于偶数前面题目输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 **示例 输入：nums &#x3D; [1,2,3,4]输出：[1,3,2,4]注：[3,1,2,4] 也是正确的答案之一。 提示： 1 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10000 分析可以使用双指针法，具体有两种： 首尾双指针法： 定义双指针lo = 0, hi = nums.length-1，一个在首部，一个在尾部 lo一直往右移，直到nums[lo]为偶数；hi一直往左移，直到nums[hi]为奇数 交换nums[lo]和nums[hi]，然后需要lo++, hi-- 重复上述操作，直到lo == hi 快慢双指针法： 定义双指针slow = 0, fast = 0，一个会运动的快，一个会运动的慢 fast的作用是向前搜索奇数位置，slow的作用是指向下一个奇数应当存放的位置 fast向前移动，当它搜索到奇数时，将nums[fast]和nums[low]交换，然后将low向前移动一个位置 重复上述操作，直到fast指向数组末尾 class Solution &#123; public int[] exchange(int[] nums) &#123; // 首尾双指针法 if(nums == null || nums.length == 0) return nums; int lo = 0, hi = nums.length-1; while(lo &lt; hi)&#123; while(lo &lt; hi &amp;&amp; nums[lo] % 2 == 1) lo++; while(lo &lt; hi &amp;&amp; nums[hi] % 2 == 0) hi--; int tmp = nums[lo]; nums[lo] = nums[hi]; nums[hi] = tmp; lo++;hi--; &#125; return nums; &#125;&#125; class Solution &#123; public int[] exchange(int[] nums) &#123; // 快慢双指针法 if(nums == null || nums.length == 0) return nums; int slow = 0, fast = 0; while(fast &lt; nums.length)&#123; if((nums[fast] &amp; 1) == 1)&#123; // 这种判断奇偶数的方法也可以学习 int temp = nums[fast]; nums[fast] = nums[slow]; nums[slow] = temp; slow++; &#125; fast++; &#125; return nums; &#125;&#125; 面试题22：链表中倒数第k个节点题目输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 分析经典题目，直接快慢双指针法即可，需要注意的是一些小问题：输入的链表为空、输入的k值不合理等情况，总体来说在可能出现空指针的地方需要仔细思考。 面试题23：链表中环的入口节点题目给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 说明：不允许修改给定的链表。 分析最简单的方法是使用HashSet，用一个集合保存已经访问过的节点，我们可以遍历整个链表并返回第一个出现重复的节点。算法的时间复杂度、空间复杂度均为$O(n)$。 第二种方法是Floyd 算法，它的出发点是一个跑得快的人和一个跑得慢的人在一个圆形的赛道上赛跑，会发生什么？在某一个时刻，跑得快的人一定会从后面赶上跑得慢的人。Floyd算法被划分成两个不同的阶段 。在第一阶段，找出列表中是否有环，如果没有环，可以直接返回null并退出。否则，用相遇节点来找到环的入口。 阶段一初始化两个指针：快指针和慢指针。快指针每次移动两步，慢指针每次移动一步，如果能够相遇，证明链表存在环，进入阶段二；否则fast指针会迭代到null，证明不存在环，直接返回null即可。 阶段二给定阶段一找到的相遇点，阶段二将找到环的入口。首先我们初始化两个指针： ptr1 ，指向链表的头， ptr2 指向相遇点。然后，我们每次将它们往前移动一步，直到它们相遇，它们相遇的点就是环的入口，返回这个节点。 这里简单的说明下原因：假设环的周长为R，阶段一在慢指针迭代了k步之后相遇，则有2k-k=nR -&gt; k=nR，其中n为某个正整数。假设链表的头结点与环入口的距离为s，环入口与阶段一的相遇点的距离为m，可以得到k=s+m+lR -&gt; s=k-m-lR=(n-l)R-m，其中l为某个小于n的正整数，而相遇点到环入口的距离刚好是R-m，因此ptr1和ptr2下一次相遇的地方刚好是环的入口。 Floyd算法相应代码如下： public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null || head.next == null) return null; ListNode slow = head, fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if (slow == fast) &#123; fast = head; while (slow != fast) &#123; slow = slow.next; fast = fast.next; &#125; return fast; &#125; &#125; return null; &#125;&#125; 其实还有一个不错的方法，分为3个步骤： 利用快慢指针法找到相遇点 根据相遇点再次遍历节点得到环的大小C 重新初始化两个快慢指针指向链表的头，其中快指针先移动C步，然后快慢指针每次同时向前移动一步，直到相遇，相遇点即为环的入口 面试题24：反转链表题目定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 分析使用3个变量prev, cur, next，然后迭代一轮便可以完成，代码如下： class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode prev = null, cur = head; while (cur != null) &#123; ListNode next = cur.next; cur.next = prev; prev = cur; cur = next; &#125; return prev; &#125;&#125; 还有一种解法是使用头插法，代码如下： class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode dummy = new ListNode(0); while (head != null) &#123; ListNode next = head.next; head.next = dummy.next; dummy.next = head; head = next; &#125; return dummy.next; &#125;&#125; 面试题25：合并两个排序的链表题目输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 分析迭代和递归都可以完成，很经典的一道题，为了加深印象分别都写一下，细节可以看代码： class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; // 迭代 ListNode dummy = new ListNode(0); ListNode prev = dummy; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; if (l1 != null) prev.next = l1; if (l2 != null) prev.next = l2; return dummy.next; &#125;&#125; class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; // 递归 if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125;else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://www.yingzq.com/tags/Java/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://www.yingzq.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}]},{"title":"常见排序算法（归纳分析及java实现）","slug":"common-sorting-algorithms","date":"2019-12-25T11:55:56.000Z","updated":"2020-02-19T17:41:15.969Z","comments":true,"path":"2019/12/25/common-sorting-algorithms/","link":"","permalink":"http://www.yingzq.com/2019/12/25/common-sorting-algorithms/","excerpt":"排序算法是算法的入门知识，其经典思想可以用于很多算法当中。本文将介绍常见排序算法的原理、对它们的分析以及对应的Java代码实现。","text":"排序算法是算法的入门知识，其经典思想可以用于很多算法当中。本文将介绍常见排序算法的原理、对它们的分析以及对应的Java代码实现。 注：排序就是将一组对象按照某种逻辑顺序重新排列的过程，在商业数据处理和现代科学计算中有着重要的地位。 排序算法概述算法分类常见的排序算法可以分成两大类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破$O(n\\log n)$，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 图：排序算法分类 算法复杂度 排序方法 时间复杂度（平均） 时间复杂度（最好） 时间复杂度（最坏） 空间复杂度 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(n^{1.3})$ $O(n)$ $O(n^2)$ $O(1)$ 不稳定 归并排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(n)$ 稳定 快速排序 $O(n\\log n)$ $O(n\\log n)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(1)$ 不稳定 - - - - - - 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(n+k)$ 稳定 桶排序 $O(n+n(\\log n - \\log m))$ $O(n)$ $O(n\\log n)$ $O(n+m)$ 稳定 基数排序 $O(k*n)$ $O(k*n)$ $O(k*n)$ $O(k+n)$ 稳定 冒泡排序（Bubble Sort）算法描述冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 具体流程如下： 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样一趟比较交换下来排在最右的元素就会是最大的数； 除去最右的元素，我们对剩余的元素做同样的工作，如此重复下去，直到排序完成。 动态演示 冒泡排序演示 代码实现public class Bubble &#123; public static void sort(int[] arr) &#123; int len = arr.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) swap(arr, j, j + 1); &#125; &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 算法分析 时间复杂度：平均、最好、最坏的时间复杂度均为$O(n^2)$，也就是运行时间和输入无关。因为总要进行n次遍历，每次遍历进行数据比较、交换的时间为$O(n)$；但是也可以通过添加一个标志位将最好的时间复杂度提升为$O(n)$。 空间复杂度：$O(1)$ 是否稳定：稳定；因为当相邻元素相等的时候算法并不会交换这两元素的位置，因此冒泡排序是稳定的。 选择排序（Selection Sort）算法描述选择排序是一种简单直观的排序算法。 具体流程如下： 找到数组中最小的那个元素； 将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）； 在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置； 如此往复，直到将整个数组排序。 因为这种算法会不断的选择剩余元素之中的最小值，所以叫做选择排序。 动态展示 选择排序展示 代码实现public class Selection &#123; public static void sort(int[] arr) &#123; int len = arr.length; for (int i = 0; i &lt; len; i++) &#123; int min = i; // 最小元素的引索 for (int j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[min]) min = j; &#125; swap(arr, i, min); &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 算法分析 时间复杂度：平均、最好、最坏的时间复杂度均为$O(n^2)$，也就是运行时间和输入无关。因为总要进行n次遍历，每次遍历需要花费$O(n)$的时间来找到最小元素的引索。 空间复杂度：$O(1)$ 是否稳定：不稳定；由于选择元素之后会发生交换操作，所以有可能把前面的元素交换到后面，例如数组 [3, 3, 2] ，第一次交换时改变了两个3的位置顺序，所以不是稳定的排序。 插入排序（Insertion Sort）算法描述通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位，这种算法叫做插入排序。 具体流程如下： 从数组第2个元素开始抽取元素； 把它与左边第一个元素比较，如果左边第一个元素比它大，则继续与左边第二个元素比较下去，直到遇到不比它大的元素，然后插到这个元素的右边； 继续选取第3，4，…n个元素,重复步骤 2 ，选择适当的位置插入。 动态演示 插入排序展示 代码实现public class Insertion &#123; public static void sort(int[] arr) &#123; int len = arr.length; for (int i = 1; i &lt; len; i++) &#123; // 将arr[i]插入到arr[i-1]、arr[i-2]、arr[i-3]...之中 for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) &#123; swap(arr, j, j - 1); &#125; &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 算法分析 时间复杂度：平均时间复杂度和最坏时间复杂度均为$O(n^2)$，但是最好时间复杂度为$O(n)$，也就是插入排序算法所需的时间取决于输入中元素的初始顺序。当排序一个随机顺序或者逆序的数组时，需要插入n-1次，每次插入平均的比较、交换次数为$O(n)$，所以平均和最坏的时间复杂度为$O(n^2)$；当排序一个已经排好序的数组时，每次插入仅需要$O(1)$次比较，因此最好时间复杂度为$O(n)$；对于接近有序的数组插入排序算法也是极快的。 空间复杂度：$O(1)$ 是否稳定：稳定；因为在比较元素大小的时候，如果两个元素相等则不会进行交换。 希尔排序（Shell Sort）算法描述希尔排序是插入排序的一种更高效的改进版本，也叫缩小增量排序。相较于插入排序一点一点的移动元素，希尔排序实现了快速移动一大步。 具体流程如下： 先设定一个合适的h，例如数组总长度的1/3； 利用插入排序，使得数组中任意间隔为h的元素都是有序的，这样的数组也被称为h有序数组； 按一定的规律减小h的值，重复第2步，直到h=1。 算法图示 图：希尔排序图示 注：较为复杂的算法动态图反而不好看清，所以使用图示来展示。 代码实现public class Shell &#123; public static void sort(int[] arr) &#123; int len = arr.length; int h = 1; while (h &lt; len / 3) h = 3 * h + 1; // 1, 4, 13, 40, 121, 364, ... while (h &gt;= 1) &#123; // 将数组变为h有序 for (int i = h; i &lt; len; i++) &#123; // 将arr[i]插入到arr[i-h], arr[i-2*h], arr[i-3*h]... 之中 for (int j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) &#123; swap(arr, j, j - h); &#125; &#125; h = h / 3; &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 注：递增序列的选择也是一大难题，代码使用的是$h_{t+1} = 3 * h_t + 1$ 算法分析 时间复杂度：希尔排序的时间复杂度无法准确量化，平均复杂度介于$O(n\\log n)$和$O(n^2)$之间，并且和递增序列的选择也有着很大关系；有人用大量实验说明对于一个已知的非常好的递增序列，平均时间复杂度大约为$O(n^{1.3})$。 空间复杂度：$O(1)$ 是否稳定：不稳定；虽然插入排序是稳定的，但是希尔排序在插入的时候是跳跃性插入的，有可能破坏稳定性。 归并排序（Merge Sort）算法描述什么是归并呢？归并操作即将两个有序的数组归并成一个更大的有序数组。 很快人们就基于归并操作发明了一种简单的递归排序算法：归并排序。要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。 归并排序是一种分治的排序方法。 算法图示 图：归并排序图示 代码实现归并排序有两种实现方式： 自顶向下的递归实现 自底向上的迭代实现 自顶向下（Top-down）public class Merge &#123; private static int[] aux; //归并所需的辅助数组 public static void sort(int[] arr) &#123; aux = new int[arr.length]; sort(arr, 0, arr.length - 1); &#125; private static void sort(int[] arr, int lo, int hi) &#123; // 将数组arr[lo..hi]排序 if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(arr, lo, mid); sort(arr, mid + 1, hi); merge(arr, lo, mid, hi); &#125; private static void merge(int[] arr, int lo, int mid, int hi) &#123; // 将arr[lo..mid]和arr[mid+1..hi]归并 int i = lo, j = mid + 1; // 将arr[lo..hi]复制到aux[lo..hi] for (int k = lo; k &lt;= hi; k++) aux[k] = arr[k]; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) arr[k] = aux[j++]; else if (j &gt; hi) arr[k] = aux[i++]; else if (aux[j] &lt; aux[i]) arr[k] = aux[j++]; else arr[k] = aux[i++]; // 包含两元素相等的情况，取较前位置的元素来保证算法稳定性 &#125; &#125;&#125; 自底向上（Bottom-up）public class MergeBU &#123; private static int[] aux; //归并所需的辅助数组 public static void sort(int[] arr) &#123; int len = arr.length; aux = new int[len]; for (int sz = 1; sz &lt; len; sz *= 2) // sz:子数组大小 for (int lo = 0; lo &lt; len - sz; lo += sz + sz) // lo:子数组引索 merge(arr, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, len - 1)); &#125; private static void merge(int[] arr, int lo, int mid, int hi) &#123; // 将arr[lo..mid]和arr[mid+1..hi]归并 int i = lo, j = mid + 1; // 将arr[lo..hi]复制到aux[lo..hi] for (int k = lo; k &lt;= hi; k++) aux[k] = arr[k]; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) arr[k] = aux[j++]; else if (j &gt; hi) arr[k] = aux[i++]; else if (aux[j] &lt; aux[i]) arr[k] = aux[j++]; else arr[k] = aux[i++]; // 包含两元素相等的情况，取较前位置的元素来保证算法稳定性 &#125; &#125;&#125; 算法分析 时间复杂度：平均、最好、最坏的时间复杂度均为$O(n\\log n)$；因为归并排序递归的深度为$\\log n$，每一层进行比较并移动的次数均为$O(n)$。 空间复杂度：$O(n)$；递归深度为$O(\\log n)$，辅助数组的空间为$O(n)$，所以整体的空间复杂度为$O(n)$。 是否稳定：稳定；因为在合并的时候，如果两个元素相等则选择前面的元素到辅助数组，所以相等元素的相对顺序未发生改变。 快速排序（Quick Sort）算法描述快速排序可能是应用最广泛的排序算法了。 快速排序引人注目的特点包括它是原地排序（只需要一个很小的辅助栈），且将长度为n的数组排序所需的时间和$n\\log n$成正比，前面讲到的排序算法均无法将这两个优点同时结合起来。另外，快速排序的内循环比大多数排序算法都要短小，这意味着它无论是在理论上还是实际中都要更快。 快速排序的基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 和归并排序一样，快速排序也是一种分治的排序方法。 算法图示 注：快速排序的关键是递归进行切分（partition）操作，所以我们主要展示如何进行一次partition操作。 图：快速排序partition示意图 图：快速排序partition详细轨迹 代码实现import java.util.Random;public class Quick &#123; private static Random random = new Random(); public static void sort(int[] arr) &#123; shuffle(arr); // 打乱数组，保证快排算法性能 sort(arr, 0, arr.length - 1); &#125; private static void sort(int[] arr, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(arr, lo, hi); sort(arr, lo, j - 1); sort(arr, j + 1, hi); &#125; private static int partition(int[] arr, int lo, int hi) &#123; // 将数组切分为arr[lo..i-1], arr[i], arr[i+1..hi] int i = lo, j = hi + 1; // 左右扫描指针 int v = arr[lo]; // 切分元素，即pivot while (true) &#123; // 扫描左右，检查扫描是否结束并交换元素 while (arr[++i] &lt; v) if (i == hi) break; while (arr[--j] &gt; v) if (j == lo) break; if (i &gt;= j) break; swap(arr, i, j); &#125; swap(arr, lo, j); // 将切分元素v放入正确的位置 return j; // arr[lo..j-1] &lt;= arr[j] &lt;= arr[j+1..hi]达成 &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; private static void shuffle(int[] arr) &#123; int n = arr.length; for (int i = 0; i &lt; n; i++) &#123; int r = i + random.nextInt(n - i); // i &lt;= r &lt;= n-1 swap(arr, i, r); &#125; &#125;&#125; 注：当输入的数组有序或者基本有序时，快排的时间复杂度为$O(n^2)$。这里有两种解决方法，一种是在最开始随机打乱数组，另一种是进行partition操作时随机选择切分元素。 算法分析 时间复杂度：平均、最好的时间复杂度为$O(n\\log n)$，最坏的时间复杂度为$O(n^2)$。 空间复杂度：$O(1)$ 是否稳定：不稳定；因为随机打乱数组或随机选择切分元素均会使得相等元素的相对顺序发生改变。 堆排序（Heap Sort）算法描述堆排序是指利用堆这种数据结构所设计的一种排序算法。 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 具体流程如下： 大顶堆的构造，将原始数组重新组织安排进一个堆中； 将堆首（最大值）和堆尾互换； 将堆的尺寸减1，利用下沉操作（代码中的sink()函数）将新的堆首元素调整到相应位置； 重复步骤二和步骤三，直到堆的尺寸为 1。 注：关于堆的具体内容可以看 二叉堆是什么鬼？ 和 算法4 优先队列等相关资料 ，这里就不再详细讲解了。 算法图示上面的步骤其实主要分成两步： 第一步是堆的构建，这里不使用优先队列中的不断插入新元素来构建堆（时间复杂度$O(n\\log n$)），而是从右到左用下沉操作（sink()函数）构建子堆，可以证明这里只需要$O(n)$的时间复杂度即可构建堆； 第二步是下沉排序，从堆中按递减顺序取出所有元素并得到排序结果。 图：堆的构造（左）和下沉排序（右） 代码实现public class Heap &#123; public static void sort(int[] a) &#123; int N = a.length; // 1. 建立大顶堆 for (int k = N / 2; k &gt;= 1; k--) &#123; sink(a, k, N); &#125; // 2. 下沉排序 while (N &gt; 1) &#123; swap(a, 1, N--); sink(a, 1, N); &#125; &#125; private static void sink(int[] a, int k, int n) &#123; while (2 * k &lt;= n) &#123; int j = 2 * k; if (j &lt; n &amp;&amp; less(a, j, j + 1)) j++; if (!less(a, k, j)) break; swap(a, k, j); k = j; &#125; &#125; private static boolean less(int[] a, int i, int j) &#123; return a[i - 1] &lt; a[j - 1]; &#125; private static void swap(int[] a, int i, int j) &#123; int temp = a[i - 1]; a[i - 1] = a[j - 1]; a[j - 1] = temp; &#125;&#125; 注：注意代码中的less()函数和swap()函数引索都减去了 1，这是由于堆顶元素从 引索 1 开始更方便。 算法分析 时间复杂度：平均、最好、最坏的时间复杂度均为$O(n\\log n)$。 空间复杂度：$O(1)$，堆排序是原地排序。 是否稳定：不稳定。 计数排序（Counting Sort）算法描述计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围、最大值和最小值的差值不是很大的整数。 动态演示 计数排序展示 代码实现public class Counting &#123; public static void sort(int[] arr) &#123; // 1. 得到数列的最大值和最小值 int max = max(arr); int min = min(arr); // 2. 计算出现频率 int[] count = new int[max - min + 1]; for (int num : arr) &#123; count[num - min] += 1; &#125; // 3. 遍历频率数组，生成结果 int idx = 0; for (int i = 0; i &lt; count.length; i++) &#123; while (count[i]-- &gt; 0) &#123; arr[idx++] = i + min; &#125; &#125; &#125; private static int max(int[] arr) &#123; int max = Integer.MIN_VALUE; for (int num : arr) max = Math.max(max, num); return max; &#125; private static int min(int[] arr) &#123; int min = Integer.MAX_VALUE; for (int num : arr) min = Math.min(min, num); return min; &#125;&#125; 如果只是单纯的给整数排序，上面的代码就已经可以解决问题了。但是如果我们希望对数组进行的是稳定排序，也就是相同元素的相对顺序不改变呢？可以使用如下代码： public class Counting &#123; public static void sort(int[] arr) &#123; // 1. 得到数列的最大值和最小值 int max = max(arr); int min = min(arr); int R = max - min + 1; // 2. 计算出现频率 int[] count = new int[R + 1]; for (int num : arr) &#123; count[num - min + 1]++; &#125; // 3. 将频率转为引索 for (int i = 0; i &lt; R; i++) &#123; count[i+1] += count[i]; &#125; // 4. 将元素分类 int N = arr.length; int[] aux = new int[N]; for(int i = 0;i &lt; N;i++)&#123; aux[count[arr[i] - min]++] = arr[i]; &#125; // 5. 回写 for (int i = 0; i &lt; N; i++) &#123; arr[i] = aux[i]; &#125; &#125; private static int max(int[] arr) &#123; int max = Integer.MIN_VALUE; for (int num : arr) max = Math.max(max, num); return max; &#125; private static int min(int[] arr) &#123; int min = Integer.MAX_VALUE; for (int num : arr) min = Math.min(min, num); return min; &#125;&#125; 算法分析 时间复杂度：当输入的元素是 n 个 m 到 m+k 之间的整数时，很容易算出平均、最好、最坏的时间复杂度均为$O(n+k)$。所以当 k 的值远小于 n 或者和 n 差不多大时，算法可以达到$O(n)$级别的线性时间复杂度。 空间复杂度：$O(n+k)$；因为需要一个 k 大小的用来计数的数组，还需要一个 n 大小的辅助数组。 是否稳定：稳定。 桶排序（Bucket Sort）算法描述桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 具体流程如下： 根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数； 遍历待排序集合，将每一个元素移动到对应的桶中； 将每个不为空的桶进行排序； 拼接不为空的桶中的数据，得到结果。 算法图示 图：桶排序展示 代码实现import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Bucket &#123; public static void sort(double[] arr) &#123; // 1. 得到数列的最大值和最小值 double max = arr[0], min = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; max = Math.max(max, arr[i]); min = Math.min(min, arr[i]); &#125; // 2. 初始化桶 int bucketNum = arr.length; // 桶个数，这里取数组长度 List&lt;List&lt;Double&gt;&gt; bucketList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; bucketNum; i++) &#123; bucketList.add(new ArrayList&lt;&gt;()); &#125; // 3. 遍历原始数组，将每个元素放入桶中 double gap = max - min; for (double num : arr) &#123; int idx = (int) ((num - min) * (bucketNum - 1) / gap); // 定义的映射规则 bucketList.get(idx).add(num); &#125; // 4. 对每个桶内部进行排序 for (List&lt;Double&gt; bucket : bucketList) &#123; Collections.sort(bucket); // JDK底层采用了归并排序的优化版本 &#125; // 5. 拼接不为空的桶中的数据，得到结果 int idx = 0; for (List&lt;Double&gt; bucket : bucketList) &#123; for (double num : bucket) &#123; arr[idx++] = num; &#125; &#125; &#125;&#125; 注1：这里使用double类型是因为刚好计数排序是无法完成double类型数组的排序的。另外，桶个数以及映射规则是根据实际情况调整的，代码中只是起了“举例”的作用。注2：代码第二步中的初始化桶其实用数组而不是ArrayList更好，但是java不支持泛型数组，因此使用ArratList写起来更加简洁清晰。 算法分析 时间复杂度：这里用 m 来表示桶的个数，平均时间复杂度为$O(n) + O(m\\frac{n}{m} \\log \\frac{n}{m})=O(n+n(\\log n - \\log m))$，当每个桶刚好有1个元素时有最好的时间复杂度$O(n)$，当一个桶有 n 个元素而其他桶都为空时有最坏时间复杂度$O(n\\log n)$。 空间复杂度：$O(n+m)$ 是否稳定：稳定；要注意的是桶内使用的排序算法需要是稳定排序。 基数排序（Radix Sort）算法描述基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。 算法图示 图：基数排序LSD展示 代码实现public class LSD &#123; public static void sort(int[] arr) &#123; int N = arr.length; int R = 10; // 一位整数的范围在0~9之间，所以设置基数R=10 int[] aux = new int[N]; // 辅助数组 // 求最大值 int max = arr[0]; for (int i = 1; i &lt; N; i++) &#123; max = Math.max(max, arr[i]); &#125; // 计算最大值位数 int maxLen = 1; while (max / 10 &gt; 0) &#123; maxLen++; max = max / 10; &#125; for (int k = 1; k &lt;= maxLen; k++) &#123; // 对每一位使用计数排序 int[] count = new int[R + 1]; // 计算出现频率 for (int num : arr) &#123; int idx = (num / (int) Math.pow(10, k - 1)) % 10; count[idx + 1]++; &#125; for (int i = 0; i &lt; R; i++) &#123; // 将频率转换为引索 count[i + 1] += count[i]; &#125; for (int num : arr) &#123; // 将元素分类 int idx = (num / (int) Math.pow(10, k - 1)) % 10; aux[count[idx]++] = num; &#125; for (int i = 0; i &lt; N; i++) &#123; // 回写 arr[i] = aux[i]; &#125; &#125; &#125;&#125; 算法分析 时间复杂度：用 k 来表示所需排序元素的平均位数，则基数排序平均、最好、最坏的时间复杂度均为$O(k*n)$；因为一共进行了 k 次循环，每次循环是一次计数排序（O(n)时间复杂度）。 空间复杂度：$O(n+k)$ 是否稳定：稳定。 参考资料 Algorithms 4th edition, sorting 必学十大经典排序算法，看这篇就够了 十大经典排序算法（动图演示）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://www.yingzq.com/tags/Java/"}]},{"title":"Python3.7.6官方教程阅读笔记","slug":"official-python3-7-6-tutorial-notes","date":"2019-11-19T09:23:40.000Z","updated":"2020-02-27T07:06:24.177Z","comments":true,"path":"2019/11/19/official-python3-7-6-tutorial-notes/","link":"","permalink":"http://www.yingzq.com/2019/11/19/official-python3-7-6-tutorial-notes/","excerpt":"最近想要复习一下Python一些基本的知识点，网上有着许许多多的Python学习教程，眼花缭乱，但是其实Python是有 官方中文文档 的，并且写的非常不错！所以对照着文档中的入门教程进行了学习，同时记录了一些值得注意的地方。","text":"最近想要复习一下Python一些基本的知识点，网上有着许许多多的Python学习教程，眼花缭乱，但是其实Python是有 官方中文文档 的，并且写的非常不错！所以对照着文档中的入门教程进行了学习，同时记录了一些值得注意的地方。 注：本文选取了对应Python 3.7.6版本的官方教程进行阅读，另外本文只是简单记录了官方教程1到9章中（也就是不含标准库的部分）值得留意的、零碎的笔记便于复习。想要系统的学习一遍可移步 官方入门教程 。 初入Python除法运算Python除法运算 / 永远返回浮点数类型。如果想要得到一个忽略小数部分的整数结果（floor division），可以使用 // 运算符。 &gt;&gt;&gt; 17 / 3 # classic division returns a float5.666666666666667&gt;&gt;&gt;&gt;&gt;&gt; 17 // 3 # floor division discards the fractional part5 字符串如果你不希望前置了 \\ 的字符转义成特殊字符，可以使用 原始字符串 方式，在引号前添加 r 即可: &gt;&gt;&gt; print('C:\\some\\name') # here \\n means newline!C:\\someame&gt;&gt;&gt; print(r'C:\\some\\name') # note the r before the quoteC:\\some\\name 字符串字面值可以跨行连续输入。一种方式是用三重引号：&quot;&quot;&quot;...&quot;&quot;&quot; 或 &#39;&#39;&#39;...&#39;&#39;&#39;。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个 \\ 即可。 字符串可以用 + 进行连接（粘到一起），也可以用 * 进行重复: &gt;&gt;&gt; # 3 times 'un', followed by 'ium'&gt;&gt;&gt; 3 * 'un' + 'ium''unununium' 相邻的两个或多个 字符串字面值（引号引起来的字符） 将会自动连接到一起: &gt;&gt;&gt; 'Py' 'thon''Python' 把很长的字符串拆开分别输入的时候尤其有用: &gt;&gt;&gt; text = ('Put several strings within parentheses '... 'to have them joined together.')&gt;&gt;&gt; text'Put several strings within parentheses to have them joined together.' 但是只能对两个字面值这样操作，变量或表达式不行，如果你想连接变量，或者连接变量和字面值，可以用 + 号。 字符串是可以被 索引（下标访问） 的，第一个字符索引是 0。单个字符并没有特殊的类型，只是一个长度为一的字符串。索引也可以用负数，这种会从右边开始数，注意 -0 和 0 是一样的，所以负数索引从 -1 开始。 除了索引，字符串还支持 切片，注意切片的开始总是被包括在结果中，而结束不被包括。另外切片的索引有默认值：省略开始索引时默认为 0，省略结束索引时默认为到字符串的结束。 试图使用过大的索引会产生一个错误，但是切片中的越界索引会被自动处理: &gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; word[42] # the word only has 6 charactersTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;IndexError: string index out of range&gt;&gt;&gt; word[4:42]'on'&gt;&gt;&gt; word[42:]'' Python 中的字符串不能被修改，它们是 immutable 的。 因此，向字符串的某个索引位置赋值会产生一个错误: &gt;&gt;&gt; word[0] = 'J'Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'str' object does not support item assignment&gt;&gt;&gt; word[2:] = 'py'Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'str' object does not support item assignment immutable: 具有固定值的对象。不可变对象包括数字、字符串和元组。这样的对象不能被改变。如果必须存储一个不同的值，则必须创建新的对象。它们在需要常量哈希值的地方起着重要作用，例如作为字典中的键。 如果需要一个不同的字符串，应当新建一个: &gt;&gt;&gt; 'J' + word[1:]'Jython'&gt;&gt;&gt; word[:2] + 'py''Pypy' 列表Python 中可以通过组合一些值得到多种 复合 数据类型。其中最常用的 列表，可以通过方括号括起、逗号分隔的一组值（元素）得到。一个 列表 可以包含不同类型的元素，但通常使用时各个元素类型相同。 和字符串（以及各种内置的 sequence 类型）一样，列表也支持索引和切片。所有的切片操作都返回一个新列表，这个新列表包含所需要的元素。就是说，如下的切片会返回列表的一个新的(浅)拷贝: &gt;&gt;&gt; squares = [1, 4, 9, 16, 25]&gt;&gt;&gt; squares[:][1, 4, 9, 16, 25] 与 immutable 的字符串不同, 列表是一个 mutable 类型，就是说，它自己的内容是可以改变的。 注：后面章节会更加详细的介绍列表。 流程控制工具if 语句值得注意的是Python中使用的是elif而不是类似Java、C语言中的 “else if” ，其实关键字elif就是 “else if” 的缩写。Python中一个 if ... elif ... elif ... 序列可以看作是其他语言中的 switch 或 case 语句的替代。 for 语句Python中的 for 语句与你在 C 或 Java 中可能用到的有所不同。Python中的 for 语句是对任意序列进行迭代（例如列表或字符串），条目的迭代顺序与它们在序列中出现的顺序一致。 如果在循环内需要修改序列中的值（比如重复某些选中的元素），推荐你先拷贝一份副本。 对序列进行循环不代表制作了一个副本进行操作。切片操作使这件事非常简单： &gt;&gt;&gt; words = ['cat', 'window', 'defenestrate']&gt;&gt;&gt; for w in words[:]: # Loop over a slice copy of the entire list.... if len(w) &gt; 6:... words.insert(0, w)...&gt;&gt;&gt; words['defenestrate', 'cat', 'window', 'defenestrate'] 如果写成 for w in words:，这个示例就会创建无限长的列表，一次又一次重复地插入 defenestrate。 循环中的 else 子句Python 循环语句可能带有一个 else 子句；它会在循环遍历完列表 (使用 for) 或是在条件变为假 (使用 while) 的时候被执行，但是不会在循环被 break 语句终止时被执行。 这可以通过以下搜索素数的循环为例来进行说明: &gt;&gt;&gt; for n in range(2, 10):... for x in range(2, n):... if n % x == 0:... print(n, 'equals', x, '*', n//x)... break... else:... # loop fell through without finding a factor... print(n, 'is a prime number')...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3 pass 语句pass 语句什么也不做。当语法上需要一个语句，但程序需要什么动作也不做时，可以使用它。例如: &gt;&gt;&gt; while True:... pass # Busy-wait for keyboard interrupt (Ctrl+C)... 通常还用于创建最小的类: &gt;&gt;&gt; class MyEmptyClass:... pass... pass 的另一个可以使用的场合是在你编写新的代码时作为一个函数或条件子句体的占位符，允许你保持在更抽象的层次上进行思考。 pass 会被静默地忽略: &gt;&gt;&gt; def initlog(*args):... pass # Remember to implement this!... 函数定义的更多形式给函数定义有可变数目的参数也是可行的。这里有三种形式，可以组合使用。 参数默认值最有用的形式是对一个或多个参数指定一个默认值。这样创建的函数，可以用比定义时允许的更少的参数调用。此类函数可以通过几种方式调用: 只给出必需的参数 给出部分可选的参数 给出所有的参数 需要注意的是默认值是在定义过程中在函数定义处计算的，所以: i = 5def f(arg=i): print(arg)i = 6f() 会打印 5。 重要警告： 默认值只会执行一次。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。比如，下面的函数会存储在后续调用中传递给它的参数: def f(a, L=[]): L.append(a) return Lprint(f(1))print(f(2))print(f(3)) 这将打印出 [1][1, 2][1, 2, 3] 如果你不想要在后续调用之间共享默认值，你可以这样写这个函数: def f(a, L=None): if L is None: L = [] L.append(a) return L 关键字参数也可以使用形如 kwarg=value 的关键字参数来调用函数。 需要注意的是，在函数调用中，关键字参数必须跟随在位置参数的后面；传递的所有关键字参数必须与函数接受的其中一个参数匹配，它们的顺序并不重要，这也包括非可选参数；也不能对同一个参数多次赋值。 当存在一个形式为 **name 的最后一个形参时，它会接收一个字典，其中包含除了与已有形参相对应的关键字参数以外的所有关键字参数。这可以与一个形式为 *name，接收一个包含除了已有形参列表以外的位置参数的元组的形参 (将在下一小节介绍) 组合使用，其中 *name 必须出现在 **name 之前！。例如，如果我们这样定义一个函数: def cheeseshop(kind, *arguments, **keywords): print(\"-- Do you have any\", kind, \"?\") print(\"-- I'm sorry, we're all out of\", kind) for arg in arguments: print(arg) print(\"-\" * 40) for kw in keywords: print(kw, \":\", keywords[kw]) 它可以像这样调用: cheeseshop(\"Limburger\", \"It's very runny, sir.\", \"It's really very, VERY runny, sir.\", shopkeeper=\"Michael Palin\", client=\"John Cleese\", sketch=\"Cheese Shop Sketch\") 当然它会打印: -- Do you have any Limburger ?-- I&#39;m sorry, we&#39;re all out of LimburgerIt&#39;s very runny, sir.It&#39;s really very, VERY runny, sir.----------------------------------------shopkeeper : Michael Palinclient : John Cleesesketch : Cheese Shop Sketch 注意打印时关键字参数的顺序保证与调用函数时提供它们的顺序是相匹配的。 任意的参数列表最后，最不常用的选项是可以使用任意数量的参数调用函数。这些参数会被包含在一个元组里，在可变数量的参数之前，可能会出现零个或多个普通参数: def write_multiple_items(file, separator, *args): file.write(separator.join(args)) 一般来说，这些 可变参数 将在形式参数列表的末尾，因为它们收集传递给函数的所有剩余输入参数。出现在 *args 参数之后的任何形式参数都是 ‘仅关键字参数’，也就是说它们只能作为关键字参数而不能是位置参数: def concat(*args, sep=\"/\"): return sep.join(args) 解包参数列表当参数已经在列表或元组中但需要为需要单独位置参数的函数调用解包时，会发生相反的情况。例如，内置的 range() 函数需要单独的 start 和 stop 参数。如果它们不能单独使用，请使用 * 运算符编写函数调用以从列表或元组中解包参数: &gt;&gt;&gt; list(range(3, 6)) # normal call with separate arguments[3, 4, 5]&gt;&gt;&gt; args = [3, 6]&gt;&gt;&gt; list(range(*args)) # call with arguments unpacked from a list[3, 4, 5] 以同样的方式，字典可以使用 ** 运算符来提供关键字参数。 lambda 表达式可以用 lambda 关键字来创建一个小的匿名函数。这个函数返回两个参数的和：lambda a, b: a+b 。lambda函数可以在需要函数对象的任何地方使用。 它们在语法上限于单个表达式。从语义上来说，它们只是正常函数定义的语法糖。与嵌套函数定义一样，lambda函数可以引用所包含域的变量: &gt;&gt;&gt; def make_incrementor(n):... return lambda x: x + n...&gt;&gt;&gt; f = make_incrementor(42)&gt;&gt;&gt; f(0)42&gt;&gt;&gt; f(1)43 上面的例子使用一个lambda表达式来返回一个函数。另一个用法是传递一个小函数作为参数: &gt;&gt;&gt; pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]&gt;&gt;&gt; pairs.sort(key=lambda pair: pair[1])&gt;&gt;&gt; pairs[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] 文档字符串以下是有关文档字符串的内容和格式的一些约定。 第一行应该是对象目的的简要概述。 为简洁起见，它不应显式声明对象的名称或类型，因为这些可通过其他方式获得（除非名称恰好是描述函数操作的动词）。这一行应以大写字母开头，以句点结尾。 如果文档字符串中有更多行，则第二行应为空白，从而在视觉上将摘要与其余描述分开。 后面几行应该是一个或多个段落，描述对象的调用约定，它的副作用等。 Python 解析器不会从 Python 中删除多行字符串文字的缩进，因此处理文档的工具必须在需要时删除缩进。 这是使用以下约定完成的：文档字符串第一行之后的第一个非空行确定整个文档字符串的缩进量（我们不能使用第一行，因为它通常与字符串的开头引号相邻，因此它的缩进在字符串文字中不明显）。 然后从字符串的所有行的开头剥离与该缩进 “等效” 的空格。 缩进更少的行不应该出现，但是如果它们出现，则应该剥离它们的所有前导空格。 应在转化制表符为空格后测试空格的等效性（通常转化为8个空格）。 下面是一个多行文档字符串的例子: &gt;&gt;&gt; def my_function():... \"\"\"Do nothing, but document it....... No, really, it doesn't do anything.... \"\"\"... pass...&gt;&gt;&gt; print(my_function.__doc__)Do nothing, but document it. No, really, it doesn't do anything. 函数标注函数标注是关于用户自定义函数中使用的类型的完全可选元数据信息。 函数标注以字典的形式存放在函数的 __annotations__ 属性中，并且不会影响函数的任何其他部分。 形参标注的定义方式是在形参名称后加上冒号，后面跟一个表达式，该表达式会被求值为标注的值。 返回值标注的定义方式是加上一个组合符号 -&gt;，后面跟一个表达式，该标注位于形参列表和表示 def 语句结束的冒号之间。 下面的示例有一个位置参数，一个关键字参数以及返回值带有相应标注: &gt;&gt;&gt; def f(ham: str, eggs: str = 'eggs') -&gt; str:... print(\"Annotations:\", f.__annotations__)... print(\"Arguments:\", ham, eggs)... return ham + ' and ' + eggs...&gt;&gt;&gt; f('spam')Annotations: &#123;'ham': &lt;class 'str'&gt;, 'return': &lt;class 'str'&gt;, 'eggs': &lt;class 'str'&gt;&#125;Arguments: spam eggs'spam and eggs' 数据结构列表的更多特性1. 列表对象方法的清单 list.append(x) ：在列表的末尾添加一个元素。相当于 a[len(a):] = [x] 。 list.extend(iterable) ：使用可迭代对象中的所有元素来扩展列表。相当于 a[len(a):] = iterable 。 list.insert(i, x) ：在给定的位置插入一个元素。第一个参数是要插入的元素的索引，所以 a.insert(0, x) 插入列表头部， a.insert(len(a), x) 等同于 a.append(x) 。 list.remove(x) ：移除列表中第一个值为 x 的元素。如果没有这样的元素，则抛出 ValueError 异常。 list.pop([i]) ：删除列表中给定位置的元素并返回它。如果没有给定位置，a.pop() 将会删除并返回列表中的最后一个元素。（ 方法签名中 i 两边的方括号表示这个参数是可选的，而不是要你输入方括号。你会在 Python 参考库中经常看到这种表示方法) list.clear() ：移除列表中的所有元素。等价于del a[:]。 list.index(x[, start[, end]]) ：返回列表中第一个值为 x 的元素的从零开始的索引。如果没有这样的元素将会抛出 ValueError 异常。可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数。 list.count(x) ：返回元素 x 在列表中出现的次数。 list.sort(key=None, reverse=False) ：对列表中的元素进行排序。 list.reverse() ：翻转列表中的元素。 list.copy() ：返回列表的一个浅拷贝，等价于 a[:]。 根据上面的方法，是可以很轻松的将列表作为栈或者队列使用的。但是列表作为队列使用是相当低效的，因为在列表的末尾添加和弹出元素非常快，但是在列表的开头插入或弹出元素却很慢 (因为所有的其他元素都必须移动一位)，若要实现一个队列，可使用 collections.deque，它被设计成可以快速地从两端添加或弹出元素。 2. 列表推导式 列表推导式提供了一个更简单的创建列表的方法。常见的用法是把某种操作应用于序列或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。 例如，假设我们想创建一个平方列表，像这样： &gt;&gt;&gt; squares = []&gt;&gt;&gt; for x in range(10):... squares.append(x**2)...&gt;&gt;&gt; squares[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 可以写成： squares = [x**2 for x in range(10)] 列表推导式的结构是由一对方括号所包含的以下内容：一个表达式，后面跟一个 for 子句，然后是零个或多个 for 或 if 子句。 其结果将是一个新列表，由对表达式依据后面的 for 和 if 子句的内容进行求值计算而得出。 举例来说，以下列表推导式会将两个列表中不相等的元素组合起来: &gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y][(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] 而它等价于 &gt;&gt;&gt; combs = []&gt;&gt;&gt; for x in [1,2,3]:... for y in [3,1,4]:... if x != y:... combs.append((x, y))...&gt;&gt;&gt; combs[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] 注意在上面两个代码片段中，for 和 if 的顺序是相同的。 如果表达式是一个元组（例如上面的 (x, y)），那么就必须加上括号。另外列表推导式可以使用复杂的表达式和嵌套函数。 3. 嵌套的列表推导式 列表推导式中的初始表达式可以是任何表达式，包括另一个列表推导式。 考虑下面这个 3x4的矩阵，它由3个长度为4的列表组成 &gt;&gt;&gt; matrix = [... [1, 2, 3, 4],... [5, 6, 7, 8],... [9, 10, 11, 12],... ] 下面的列表推导式将交换其行和列 &gt;&gt;&gt; [[row[i] for row in matrix] for i in range(4)][[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] 如上节所示，嵌套的列表推导式是基于跟随其后的 for 进行求值的，所以这个例子等价于: &gt;&gt;&gt; transposed = []&gt;&gt;&gt; for i in range(4):... transposed.append([row[i] for row in matrix])...&gt;&gt;&gt; transposed[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] 实际应用中，你应该会更喜欢使用内置函数去组成复杂的流程语句。 zip() 函数将会很好地处理这种情况 &gt;&gt;&gt; list(zip(*matrix))[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)] del 语句有一种方式可以从列表按照给定的索引而不是值来移除一个元素: 那就是 del 语句。 它不同于会返回一个值的 pop() 方法， del 语句也可以用来从列表中移除切片或者清空整个列表，也可以删除整个变量。 元组，集合以及字典元组可能看起来与列表很像，但它们通常是在不同的场景被使用，并且有着不同的用途。元组是 immutable ，其序列通常包含不同种类的元素，并且通过解包或者索引来访问（如果是 namedtuples 的话甚至还可以通过属性访问）。列表是 mutable ，并且列表中的元素一般是同种类型的，并且通过迭代访问。 Python也包含有 集合 类型。集合是由不重复元素组成的无序的集。它的基本用法包括成员检测和消除重复元素。集合对象也支持像 联合，交集，差集，对称差分等数学运算。花括号或 set() 函数可以用来创建集合。注意：要创建一个空集合你只能用 set() 而不能用 {}，因为后者是创建一个空字典。 下面简单演示集合之间常用的运算： &gt;&gt;&gt; # Demonstrate set operations on unique letters from two words...&gt;&gt;&gt; a = set('abracadabra')&gt;&gt;&gt; b = set('alacazam')&gt;&gt;&gt; a # unique letters in a&#123;'a', 'r', 'b', 'c', 'd'&#125;&gt;&gt;&gt; a - b # letters in a but not in b&#123;'r', 'd', 'b'&#125;&gt;&gt;&gt; a | b # letters in a or b or both&#123;'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'&#125;&gt;&gt;&gt; a &amp; b # letters in both a and b&#123;'a', 'c'&#125;&gt;&gt;&gt; a ^ b # letters in a or b but not both&#123;'r', 'd', 'b', 'm', 'z', 'l'&#125; 还有一个非常有用的 Python 內置数据类型是 字典。与以连续整数为索引的序列不同，字典是以 关键字 为索引的，关键字可以是任意不可变类型，通常是字符串或数字。如果一个元组只包含字符串、数字或元组，那么这个元组也可以用作关键字。但如果元组直接或间接地包含了可变对象，那么它就不能用作关键字。列表不能用作关键字，因为列表可以通过索引、切片或 append() 和 extend() 之类的方法来改变。 对于字典的创建，除了一般的初始化，还有一些其他方法： dict() 构造函数可以直接从键值对序列里创建字典，例如dict([(&#39;sape&#39;, 4139), (&#39;guido&#39;, 4127), (&#39;jack&#39;, 4098)])。 字典推导式可以从任意的键值表达式中创建字典，例如{x: x**2 for x in (2, 4, 6)}。 当关键字是简单字符串时，有时直接通过关键字参数来指定键值对更方便，例如dict(sape=4139, guido=4127, jack=4098)。 循环的技巧 当在字典中循环时，用 items() 方法可将关键字和对应的值同时取出 当在序列中循环时，用 enumerate() 函数可以将索引位置和其对应的值同时取出 当同时在两个或更多序列中循环时，可以用 zip() 函数将其内元素一一匹配 如果要逆向循环一个序列，可以先正向定位序列，然后调用 reversed() 函数 如果要按某个指定顺序循环一个序列，可以用 sorted() 函数，它可以在不改动原序列的基础上返回一个新的排好序的序列 有时可能会想在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全的 模块模块是一个包含Python定义和语句的文件。文件名就是模块名后跟文件后缀 .py 。在一个模块内部，模块名（作为一个字符串）可以通过全局变量 __name__ 的值获得。 以脚本的方式执行模块当你用下面方式运行一个Python模块: python test.py &lt;arguments&gt; 模块里的代码会被执行，就好像你导入了模块一样，但是 __name__ 被赋值为 &quot;__main__&quot;。 这意味着通过在你的模块末尾添加这些代码: if __name__ == \"__main__\": import sys test(int(sys.argv[1])) 你既可以把这个文件当作脚本又可当作一个可调入的模块来使用， 因为那段解析命令行的代码只有在当模块是以“main”文件的方式执行的时候才会运行，如果模块是被导入的，那些代码是不运行的。 这经常用于为模块提供一个方便的用户接口，或用于测试（以脚本的方式运行模块从而执行一些测试套件）。 包包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。 例如，模块名 A.B 表示 A 包中名为 B 的子模块。正如模块的使用使得不同模块的作者不必担心彼此的全局变量名称一样，使用加点的模块名可以使得 NumPy 或 Pillow 等多模块软件包的作者不必担心彼此的模块名称一样。 必须要有 __init__.py 文件才能让 Python 将包含该文件的目录当作包。 这样可以防止具有通常名称例如 string 的目录在无意中隐藏稍后在模块搜索路径上出现的有效模块。 在最简单的情况下，__init__.py 可以只是一个空文件，但它也可以执行包的初始化代码或设置 __all__ 变量，具体将在后文介绍。 输入输出更漂亮的输出格式1. 格式化字符串文字 格式化字符串字面值（常简称为 f-字符串）能让你在字符串前加上 f 和 F 并将表达式写成 {expression} 来在字符串中包含 Python 表达式的值。 可选的格式说明符可以跟在表达式后面。这样可以更好地控制值的格式化方式。以下示例将pi舍入到小数点后三位: &gt;&gt;&gt; import math&gt;&gt;&gt; print(f'The value of pi is approximately &#123;math.pi:.3f&#125;.')The value of pi is approximately 3.142. 关于更多格式规范的参考，请参阅参考指南 格式规格迷你语言 。 2. 字符串的 format() 方法 str.format() 方法的基本用法如下所示: &gt;&gt;&gt; print('We are the &#123;&#125; who say \"&#123;&#125;!\"'.format('knights', 'Ni'))We are the knights who say \"Ni!\" 花括号和其中的字符（称为格式字段）将替换为传递给 str.format() 方法的对象。花括号中的数字可用来表示传递给 str.format() 方法的对象的位置。 &gt;&gt;&gt; print('&#123;0&#125; and &#123;1&#125;'.format('spam', 'eggs'))spam and eggs&gt;&gt;&gt; print('&#123;1&#125; and &#123;0&#125;'.format('spam', 'eggs'))eggs and spam 如果在 str.format() 方法中使用关键字参数，则使用参数的名称引用它们的值: &gt;&gt;&gt; print('This &#123;food&#125; is &#123;adjective&#125;.'.format(... food='spam', adjective='absolutely horrible'))This spam is absolutely horrible. 位置和关键字参数可以任意组合: &gt;&gt;&gt; print('The story of &#123;0&#125;, &#123;1&#125;, and &#123;other&#125;.'.format('Bill', 'Manfred', other='Georg'))The story of Bill, Manfred, and Georg. 关于使用 str.format() 进行字符串格式化的完整概述，请参阅 格式字符串语法 。 3. str() 与 repr() str() 函数是用于返回人类可读的值的表示，而 repr() 是用于生成解释器可读的表示（如果没有等效的语法，则会强制执行 SyntaxError）对于没有人类可读性的表示的对象， str() 将返回和 repr() 一样的值。很多值使用任一函数都具有相同的表示，比如数字或类似列表和字典的结构。特殊的是字符串有两个不同的表示。 4. 手动格式化字符串 字符串对象的 str.rjust() 方法通过在左侧填充空格来对给定宽度的字段中的字符串进行右对齐。类似的方法还有 str.ljust() 和 str.center() 。这些方法不会写入任何东西，它们只是返回一个新的字符串，如果输入的字符串太长，它们不会截断字符串，而是原样返回；这虽然会弄乱你的列布局，但这通常比另一种方法好，后者会在显示值时可能不准确。（如果你真的想截断，你可以添加一个切片操作，例如 x.ljust(n)[:n] 。） 还有另外一个方法，str.zfill() ，它会在数字字符串的左边填充零。 读写文件1. open() 函数 open() 返回一个 file object，最常用的有两个参数： open(filename, mode)。 &gt;&gt;&gt; f = open('workfile', 'w') 第一个参数是包含文件名的字符串。第二个参数是另一个字符串，其中包含一些描述文件使用方式的字符。mode 可以是 &#39;r&#39; ，表示文件只能读取，&#39;w&#39; 表示只能写入（已存在的同名文件会被删除），还有 &#39;a&#39; 表示打开文件以追加内容；任何写入的数据会自动添加到文件的末尾。&#39;r+&#39; 表示打开文件进行读写。mode参数 是可选的；省略时默认为 &#39;r&#39;。 在处理文件对象时，最好使用 with 关键字。 优点是当子句体结束后文件会正确关闭，即使在某个时刻引发了异常。 而且使用 with 相比等效的 try-finally 代码块要简短得多: &gt;&gt;&gt; with open('workfile') as f:... read_data = f.read()&gt;&gt;&gt; f.closedTrue 2. 文件对象的方法 要读取文件内容，请调用 f.read(size)，它会读取一些数据并将其作为字符串（在文本模式下）或字节串对象（在二进制模式下）返回。 size 是一个可选的数值参数。 当 size 被省略或者为负数时，将读取并返回整个文件的内容；如果文件的大小是你的机器内存的两倍就会出现问题。 当取其他值时，将读取并返回至多 size 个字符（在文本模式下）或 size 个字节（在二进制模式下）。 如果已到达文件末尾，f.read() 将返回一个空字符串 (&#39;&#39;)。 &gt;&gt;&gt; f.read()'This is the entire file.\\n'&gt;&gt;&gt; f.read()'' f.readline() 从文件中读取一行；换行符（\\n）留在字符串的末尾，如果文件不以换行符结尾，则在文件的最后一行省略。这使得返回值明确无误；如果 f.readline() 返回一个空的字符串，则表示已经到达了文件末尾，而空行使用 &#39;\\n&#39; 表示，该字符串只包含一个换行符。 要从文件中读取行，你可以循环遍历文件对象。这是内存高效，快速的，并简化代码: &gt;&gt;&gt; for line in f:... print(line, end='')...This is the first line of the file.Second line of the file 如果你想以列表的形式读取文件中的所有行，你也可以使用 list(f) 或 f.readlines()。 f.write(string) 会把 string 的内容写入到文件中，并返回写入的字符数。在写入其他类型的对象之前，需要先把它们转化为字符串（在文本模式下）或者字节对象（在二进制模式下）。 文件对象有一些额外的方法，使用频率没这么高，就不详细介绍了。 3. 使用 json 保存结构化数据 Python 允许你使用称为 JSON (JavaScript Object Notation) 的流行数据交换格式，而不是让用户不断的编写和调试代码以将复杂的数据类型保存到文件中。名为 json 的标准模块可以采用 Python 数据层次结构，并将它们转化为字符串表示形式；这个过程称为 serializing 。从字符串表示中重建数据称为 deserializing 。在序列化和反序列化之间，表示对象的字符串可能已存储在文件或数据中，或通过网络连接发送到某个远程机器。 错误和异常语法错误语法错误又称解析错误，可能是你在学习Python 时最容易遇到的错误: &gt;&gt;&gt; while True print('Hello world') File \"&lt;stdin&gt;\", line 1 while True print('Hello world') ^SyntaxError: invalid syntax 解析器会输出出现语法错误的那一行，并显示一个“箭头”，指向这行里面检测到第一个错误。 错误是由箭头指示的位置上面的 token 引起的（或者至少是在这里被检测出的）：在示例中，在 print() 这个函数中检测到了错误，因为在它前面少了个冒号 (&#39;:&#39;) 。文件名和行号也会被输出，以便输入来自脚本文件时你能知道去哪检查。 异常即使语句或表达式在语法上是正确的，但在尝试执行时，它仍可能会引发错误，在执行时检测到的错误被称为 异常。 异常不一定会导致严重后果， 但是大多数异常并不会被程序处理，此时会显示如下所示的错误信息: &gt;&gt;&gt; 10 * (1/0)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ZeroDivisionError: division by zero&gt;&gt;&gt; 4 + spam*3Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'spam' is not defined&gt;&gt;&gt; '2' + 2Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: Can't convert 'int' object to str implicitly 错误信息的最后一行告诉我们程序遇到了什么类型的错误。异常有不同的类型，而其类型名称将会作为错误信息的一部分中打印出来：上述示例中的异常类型依次是：ZeroDivisionError， NameError 和 TypeError。作为异常类型打印的字符串是发生的内置异常的名称。对于所有内置异常都是如此，但对于用户定义的异常则不一定如此（虽然这是一个有用的规范）。标准的异常类型是内置的标识符（而不是保留关键字）。 这一行的剩下的部分根据异常类型及其原因提供详细信息。 错误信息的前一部分以堆栈回溯的形式显示发生异常时的上下文。通常它包含列出源代码行的堆栈回溯；但是它不会显示从标准输入中读取的行。 内置异常 列出了内置异常和它们的含义。 处理异常可以编写处理所选异常的程序。请看下面的例子，它会要求用户一直输入，直到输入的是一个有效的整数，但允许用户中断程序（使用 Control-C 或操作系统支持的其他操作）；请注意用户引起的中断可以通过引发 KeyboardInterrupt 异常来指示: &gt;&gt;&gt; while True:... try:... x = int(input(\"Please enter a number: \"))... break... except ValueError:... print(\"Oops! That was no valid number. Try again...\")... try 语句 的工作原理如下： 首先，执行 try 子句（try 和 except 关键字之间的（多行）语句）。 如果没有异常发生，则跳过 except 子句 并完成 try 语句的执行。 如果在执行try 子句时发生了异常，则跳过该子句中剩下的部分。然后，如果异常的类型和 except 关键字后面的异常匹配，则执行 except 子句 ，然后继续执行 try 语句之后的代码。 如果发生的异常和 except 子句中指定的异常不匹配，则将其传递到外部的 try 语句中；如果没有找到处理程序，则它是一个 未处理异常，执行将停止并显示如上所示的消息。 一个 try 语句可能有多个 except 子句，以指定不同异常的处理程序。 最多会执行一个处理程序，处理程序只处理相应的 try 子句 中发生的异常，而不处理同一 try 语句 内其他处理程序中的异常。 try ... except 语句 有一个可选的 else 子句，在使用时必须放在所有的 except 子句 后面。对于在try 子句不引发异常时必须执行的代码来说很有用。 抛出异常raise 语句允许程序员强制发生指定的异常。例如: &gt;&gt;&gt; raise NameError('HiThere')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: HiThere raise 唯一的参数就是要抛出的异常。这个参数必须是一个异常实例或者是一个异常类（派生自 Exception 的类）。如果传递的是一个异常类，它将通过调用没有参数的构造函数来隐式实例化: raise ValueError # shorthand for 'raise ValueError()' 如果你需要确定是否引发了异常但不打算处理它，则可以使用更简单的 raise 语句形式重新引发异常: &gt;&gt;&gt; try:... raise NameError('HiThere')... except NameError:... print('An exception flew by!')... raise...An exception flew by!Traceback (most recent call last): File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;NameError: HiThere 用户自定义异常程序可以通过创建新的异常类来命名它们自己的异常，异常通常应该直接或间接地从 Exception 类派生。 可以定义异常类，它可以执行任何其他类可以执行的任何操作，但通常保持简单，通常只提供许多属性，这些属性允许处理程序为异常提取有关错误的信息。在创建可能引发多个不同错误的模块时，通常的做法是为该模块定义的异常创建基类，并为不同错误条件创建特定异常类的子类。 大多数异常都定义为名称以“Error”结尾，类似于标准异常的命名。 定义清理操作try 语句有另一个可选的 finally 子句，用于定义必须在所有情况下执行的清理操作。 如果存在 finally 子句，则 finally 子句将作为 try 语句结束前的最后一项任务被执行。 finally 子句 不论 try 语句是否产生了异常都会被执行。 以下几点讨论了当异常发生时一些更复杂的情况： 如果在执行 try 子句期间发生了异常，该异常可由一个 except 子句进行处理。 如果异常没有被某个 except 子句所处理，则该异常会在 finally 子句 执行之后被重新引发。 异常也可能在 except 或 else 子句执行期间发生。 同样地，该异常会在 finally 子句 执行之后被重新引发。 如果在执行 try 语句时遇到一个 break, continue 或 return 语句，则 finally 子句 将在执行 break, continue 或 return 语句之前被执行。 如果 finally 子句 中包含一个 return 语句，则返回值将来自 finally 子句 的某个 return 语句的返回值，而非来自 try 子句的 return 语句的返回值。 类这一章节官方文档讲的有些晦涩，特别是“Python 作用域和命名空间”这一节，后来发现菜鸟教程对于这一部分的讲解还挺通俗易懂的，下面贴出相应网址： Python3 面向对象 Python3 命名空间和作用域","categories":[{"name":"Python","slug":"Python","permalink":"http://www.yingzq.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.yingzq.com/tags/Python/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"http://www.yingzq.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}]},{"title":"Transformer代码实现","slug":"the-annotated-transformer","date":"2019-11-18T07:22:27.000Z","updated":"2020-02-19T17:43:10.648Z","comments":true,"path":"2019/11/18/the-annotated-transformer/","link":"","permalink":"http://www.yingzq.com/2019/11/18/the-annotated-transformer/","excerpt":"Transformer是如今几乎所有的预训练模型的基本结构。也许我们平时更多的是关注如何更好的利用已经训练好的GPT、BERT等模型进行fine-tune，但是同样重要的是，我们需要了解这些强力的模型具体是如何构建的。所以本文我们主要研究如何在PyTorch框架下用代码实现 “Attention is All You Need” 论文中原始Transformer的结构。","text":"Transformer是如今几乎所有的预训练模型的基本结构。也许我们平时更多的是关注如何更好的利用已经训练好的GPT、BERT等模型进行fine-tune，但是同样重要的是，我们需要了解这些强力的模型具体是如何构建的。所以本文我们主要研究如何在PyTorch框架下用代码实现 “Attention is All You Need” 论文中原始Transformer的结构。 本文内容参考了 The Annotated Transformer ，对应的代码则针对PyTorch 1.3环境做了一定更新，完整代码可见 Transformer Code 。 准备工作本文的测试环境是Python 3.6+和PyTorch 1.3，如果版本不对可能代码需要略微的调整。 在这里先导入所有需要用到的库，方便检测是否有缺失： import numpy as npimport torchimport torch.nn as nnimport torch.nn.functional as Fimport math, copy, time 背景介绍当谈及序列模型(sequence modeling)，我们首先想到的就是RNN及其变种，但是RNN模型的缺点也非常明显：需要顺序计算，从而很难并行。因此出现了Extended Neural GPU、ByteNet和ConvS2S等网络模型。这些模型都是以CNN为基础，这比较容易并行，但是和RNN相比，它较难学习到长距离的依赖关系。 本文的Transformer使用了Self-Attention机制，它在编码每一词的时候都能够注意(attend to)整个句子，从而可以解决长距离依赖的问题，同时计算Self-Attention可以用矩阵乘法一次计算所有的时刻，因此可以充分利用计算资源。 模型结构目前的主流神经序列转换(neural sequence transduction)模型都是基于Encoder-Decoder结构的。所谓的序列转换模型就是把一个输入序列转换成另外一个输出序列，它们的长度很可能是不同的。比如基于神经网络的机器翻译，输入是法语句子，输出是英语句子，这就是一个序列转换模型。类似的包括文本摘要、对话等问题都可以看成序列转换问题。我们这里主要关注机器翻译，但是任何输入是一个序列输出是另外一个序列的问题都可以考虑使用Encoder-Decoder结构。 Encoder将输入序列$(x_1,\\ldots,x_n)$编码成一个连续的序列$\\boldsymbol{z}=(z_1,\\ldots,z_n)$。而Decoder根据$\\boldsymbol{z}$来解码得到输出序列$(y_1,\\ldots,y_m)$。Decoder是自回归的(auto-regressive)，它会把前一个时刻的输出作为当前时刻的输入。Encoder-Decoder结构对应的代码如下： class EncoderDecoder(nn.Module): \"\"\" A standard Encoder-Decoder architecture. Base for this and many other models. \"\"\" def __init__(self, encoder, decoder, src_embed, tgt_embed, generator): super(EncoderDecoder, self).__init__() self.encoder = encoder self.decoder = decoder self.src_embed = src_embed self.tgt_embed = tgt_embed self.generator = generator def forward(self, src, tgt, src_mask, tgt_mask): \"\"\" Take in and process masked src and target sequences. \"\"\" return self.decode(self.encode(src, src_mask), src_mask, tgt, tgt_mask) def encode(self, src, src_mask): return self.encoder(self.src_embed(src), src_mask) def decode(self, memory, src_mask, tgt, tgt_mask): return self.decoder(self.tgt_embed(tgt), memory, src_mask, tgt_mask) class Generator(nn.Module): \"\"\" Define standard linear + softmax generation step. \"\"\" def __init__(self, d_model, vocab): super(Generator, self).__init__() self.proj = nn.Linear(d_model, vocab) def forward(self, x): return F.log_softmax(self.proj(x), dim=-1) EncoderDecoder定义了一种通用的Encoder-Decoder架构，具体的encoder、decoder、src_embed、target_embed和generator都是构造函数传入的参数。这样我们做实验更换不同的组件就会更加方便。 解释一下各种参数的意义：encoder、encoder分别代表编码器和解码器；src_embed、tgt_embed分别代表将源语言、目标语言的ID序列编码为词向量(embedding)的方法；generator则是根据解码器当前时刻的隐状态输出当前时刻的词，上面已给出具体的实现方法(即Generator类)。 Transformer模型也遵循着Encoder-Decoder的架构。它的Encoder是由$N=6$个相同的EncoderLayer组成，每个EncoderLayer包含一个Self-Attention Sublayer层和一个Feed-Forward Sublayer层；而它的Decoder也是由$N=6$个相同的DecoderLayer组成，每个DecoderLayer包含一个Self-Attention Sublayer层、一个Encoder-Decoder-Attention Sublayer层和一个Feed-Forward Sublayer层。 注：Feed-Forward层其实就是全连接层的意思。 下图清晰的展示了Transformer整体架构： 图：Transformer整体架构 Encoder and Decoder StacksEncoder前面提到Encoder是由$N=6$个相同结构的EncoderLayer堆叠而成，所以我们定义Encoder的代码如下： def clones(module, N): \"\"\" Produce N identical layers. \"\"\" return nn.ModuleList([copy.deepcopy(module) for _ in range(N)]) class Encoder(nn.Module): \"\"\" Core encoder is a stack of N layers. \"\"\" def __init__(self, layer, N): super(Encoder, self).__init__() self.layers = clones(layer, N) self.norm = LayerNorm(layer.size) def forward(self, x, mask): \"\"\" Pass the input (and mask) through each layer in turn. \"\"\" for layer in self.layers: x = layer(x, mask) return self.norm(x) 也就是Encoder会把传入的layer深拷贝N次，然后让传入的Tensor依次通过这N个layer，最后再通过一层 Layer Normalization。 class LayerNorm(nn.Module): \"\"\" Construct a layernorm module, see https://arxiv.org/abs/1607.06450 for details. \"\"\" def __init__(self, features, eps=1e-6): super(LayerNorm, self).__init__() self.a_2 = nn.Parameter(torch.ones(features)) self.b_2 = nn.Parameter(torch.zeros(features)) self.eps = eps def forward(self, x): mean = x.mean(-1, keepdim=True) std = x.std(-1, keepdim=True) return self.a_2 * (x - mean) / (std + self.eps) + self.b_2 按照原论文，每一个EncoderLayer的每一个子层(sub-layer)的输出应该是$LayerNorm(x+Sublayer(x))$，其中的Sublayer(x)是对子层结构实现的抽象函数。这里稍微做了一些修改，首先在每一个子层的输出之后加了一个 Dropout层 ，另外一个不同就是把LayerNorm层放到前面了。也就是现在每一个子层实际的输出是： $$x+Dropout(Sublayer(LayerNorm(x)))$$ 注：原论文的LayerNorm放在最后，这里把它放在前面并且在Encoder的最后一层再加上了一个LayerNorm。这里的实现和论文的实现基本是一致的，只是给最底层的输入x多做了一个LayerNorm。 为了加快残差连接的速度，模型中所有的子层(sub-layer)，包括Embedding层，将它们的输出维度均设置为$d_{model}=512$。所以我们有如下代码： class SublayerConnection(nn.Module): \"\"\" A residual connection followed by a layer norm. Note for code simplicity the norm is first as opposed to last. \"\"\" def __init__(self, size, dropout): super(SublayerConnection, self).__init__() self.norm = LayerNorm(size) self.dropout = nn.Dropout(dropout) def forward(self, x, sublayer): \"\"\" Apply residual connection to any sublayer with the same size. \"\"\" return x + self.dropout(sublayer(self.norm(x))) 上面提到EncoderLayer是由Self-Attention、Feed-Forward这两个子层构成，所以有： class EncoderLayer(nn.Module): \"\"\" Encoder is made up of self-attn and feed forward. \"\"\" def __init__(self, size, self_attn, feed_forward, dropout): super(EncoderLayer, self).__init__() self.self_attn = self_attn self.feed_forward = feed_forward self.sublayer = clones(SublayerConnection(size, dropout), 2) self.size = size def forward(self, x, mask): x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, mask)) return self.sublayer[1](x, self.feed_forward) DecoderDecoder也是由$N=6$个相同结构的DecoderLayer堆叠而成。 class Decoder(nn.Module): \"\"\" Generic N layer decoder with masking. \"\"\" def __init__(self, layer, N): super(Decoder, self).__init__() self.layers = clones(layer, N) self.norm = LayerNorm(layer.size) def forward(self, x, memory, src_mask, tgt_mask): for layer in self.layers: x = layer(x, memory, src_mask, tgt_mask) return self.norm(x) 前面讲到，一个DecoderLayer除了有和EncoderLayer一样的两个子层，还多了一个Encoder-Decoder-Attention子层，这个子层会让模型在解码时会考虑最后一层Encoder所有时刻的输出。 class DecoderLayer(nn.Module): \"\"\" Decoder is made of self-attn, src-attn, and feed forward. \"\"\" def __init__(self, size, self_attn, src_attn, feed_forward, dropout): super(DecoderLayer, self).__init__() self.size = size self.self_attn = self_attn self.src_attn = src_attn self.feed_forward = feed_forward self.sublayer = clones(SublayerConnection(size, dropout), 3) def forward(self, x, memory, src_mask, tgt_mask): m = memory x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, tgt_mask)) x = self.sublayer[1](x, lambda x: self.src_attn(x, m, m, src_mask)) return self.sublayer[2](x, self.feed_forward) 注：多出来的这一层Attention子层(代码中是src_attn)实现和Self-Attention是一样的，只不过src_attn的Query来自于前层Decoder的输出，但是Key和Value来自于Encoder最后一层的输出(代码中是memory)；而Self-Attention的Q、K、V则均来自前层的输出。 Decoder和Encoder还有一个关键的不同：Decoder在解码第t个时刻的时候只能使用小于t时刻的输入，而不能使用t+1时刻及其之后的输入。因此我们需要一个函数来产生一个Mask矩阵： def subsequent_mask(size): \"\"\" Mask out subsequent positions. \"\"\" attn_shape = (1, size, size) subsequent_mask = np.triu(np.ones(attn_shape), k=1).astype('uint8') return torch.from_numpy(subsequent_mask) == 0 上面代码的意思是先用triu函数产生一个上三角矩阵，再利用matrix == 0得到所需要的下三角矩阵。 AttentionMulti-Head AttentionAttention(包括Self-Attention和普通的Attention)可以看成一个函数，它的输入是Query,Key和Value，输出是一个Tensor。其中输出是Value的加权平均，而权重则来自Query和Key的计算。 论文中首先提到了Scaled Dot-Product Attention，如下图所示： 图：Scaled Dot-Product Attention Scaled Dot-Product Attention需要保证Query和Key的维度是相同的，记为$d_k$，Value的维度记为$d_v$。 具体计算是先将一组query和所有的keys作点乘运算，然后除以$\\sqrt{d_k}$保证后续梯度的稳定性，然后将这些分数进行softmax归一化，作为query和Keys的相似程度，也就是values加权平均的权重，最后将所有values作加权平均作为输出。这里用矩阵直接表示： $$Attention(Q,K,V)=softmax(\\frac{Q K^T}{\\sqrt{d_k}})V$$ def attention(query, key, value, mask=None, dropout=None): \"\"\" Compute 'Scaled Dot Product Attention' \"\"\" d_k = query.size(-1) scores = torch.matmul(query, key.transpose(-2, -1)) / math.sqrt(d_k) if mask is not None: scores = scores.masked_fill(mask == 0, -1e9) p_attn = F.softmax(scores, dim=-1) if dropout is not None: p_attn = dropout(p_attn) return torch.matmul(p_attn, value), p_attn 论文中非常重要的Multi-Head Attention便是基于Scaled Dot-Product Attention。其实很简单，前面定义的一组Q、K和V可以让一个词attend to相关的词，我们可以定义多组Q、K和V，它们分别可以关注不同的上下文： 图：Multi-Head Attention 由上图我们可以得到如下计算公式： $$MultiHead(Q,K,V)=Concat(head_1,\\ldots,head_h)W^O \\\\where \\ head_i=Attention(QW_i^Q,KW_i^K,VW_i^V)$$ 论文中使用了$h=8$个Head，所以此时$d_k=d_v=d_{model}/h=64$。虽然此时Head数扩大了$h=8$由于每一个Head的维度缩小了$h=8$倍，所以总体的计算成本是基本不变的。 根据上述分析，我们可以写出Multi-Head Attention的代码了。 class MultiHeadedAttention(nn.Module): \"\"\" Implements 'Multi-Head Attention' proposed in the paper. \"\"\" def __init__(self, h, d_model, dropout=0.1): \"\"\" Take in model size and number of heads. \"\"\" super(MultiHeadedAttention, self).__init__() assert d_model % h == 0 # We assume d_v always equals d_k self.d_k = d_model // h self.h = h self.linears = clones(nn.Linear(d_model, d_model), 4) self.attn = None self.dropout = nn.Dropout(p=dropout) def forward(self, query, key, value, mask=None): if mask is not None: # Same mask applied to all h heads. mask = mask.unsqueeze(1) nbatches = query.size(0) # 1) Do all the linear projections in batch from d_model =&gt; h x d_k query, key, value = [l(x).view(nbatches, -1, self.h, self.d_k).transpose(1, 2) for l, x in zip(self.linears, (query, key, value))] # 2) Apply attention on all the projected vectors in batch. x, self.attn = attention(query, key, value, mask=mask, dropout=self.dropout) # 3) \"Concat\" using a view and apply a final linear. x = x.transpose(1, 2).contiguous().view(nbatches, -1, self.h * self.d_k) return self.linears[-1](x) Attention在模型中的应用在Transformer里，有3个地方用到了Multi-Head Attention： 1) Decoder的Encoder-Decoder-Attention层。其中query来自于前一层Decoder的输出，而key和value则来自于是Encoder最后一层的输出，这个Attention层使得Decoder在解码时会考虑最后一层Encoder所有时刻的输出，是一种在Encoder-Decoder架构中常用的注意力机制。2) Encoder的Self-Attention层。query，key和value均来自于相同的地方，也就是前层Encoder的输出。3) Decoder的Self-Attention层。query，key和value均来自于相同的地方，也就是前层Decoder的输出，但是Mask使得它不能访问未来时刻的输出。 Feed-Forward除了Attention子层，Encoder和Decoder的每一层还包括一个Feed-Forward子层，也就是全连接层。每个时刻的全连接层是可以独立并行计算的(当然参数是共享的)。全连接层由两个线性变换以及它们之间的ReLU激活组成： $$FFN(x)=max(0,xW_1+b_1)W_2+b_2$$ 全连接层的输入和输出都是$d_{model}=512$维的，中间隐单元的个数是$d_{ff}=2048$。代码实现非常简单： class PositionwiseFeedForward(nn.Module): \"\"\" Implements FFN equation. \"\"\" def __init__(self, d_model, d_ff, dropout=0.1): super(PositionwiseFeedForward, self).__init__() self.w_1 = nn.Linear(d_model, d_ff) self.w_2 = nn.Linear(d_ff, d_model) self.dropout = nn.Dropout(dropout) def forward(self, x): return self.w_2(self.dropout(F.relu(self.w_1(x)))) Embeddings和大部分NLP任务一样，输入的词序列都是ID序列，所以需要有个Embeddings层。 class Embeddings(nn.Module): def __init__(self, d_model, vocab): super(Embeddings, self).__init__() # lut =&gt; lookup table self.lut = nn.Embedding(vocab, d_model) self.d_model = d_model def forward(self, x): return self.lut(x) * math.sqrt(self.d_model) 需要注意的是，在Embeddings层，所有的权重都扩大了$\\sqrt{d_{model}}$倍。 Positional Encoding其实Transformer是没有考虑词的顺序(位置)关系的。为了解决这个问题引入位置编码(Positional Encoding)，论文中使用的公式如下： $$PE_{(pos,2i)}=sin(pos/10000^{2i/d_{model}}) \\\\PE_{(pos,2i+1)}=cos(pos/10000^{2i/d_{model}})$$ 其中pos代表位置而i代表维度。例如输入的ID序列长度为10，那么经过Embeddings层后Tensor的尺寸就是(10,512)，此时上式中的pos的范围就是0~9；对于不同维度，这里范围是0~511，偶数维使用sin函数，而奇数维使用cos函数。 这种位置编码的好处是：$PE_{pos+k}$可以表示成$PE_{pos}$的线性函数，这样网络就能容易的学到相对位置的关系。 我们来简单验证下，这里$10000^{2i/d_{model}}$是一个常数，我们记为$W_{i}$。 $$PE_{(pos+k,2i)}=sin(\\frac{pos+k}{W_{i}})=sin(\\frac{pos}{W_{i}})cos(\\frac{k}{W_{i}})+cos(\\frac{pos}{W_{i}})sin(\\frac{k}{W_{i}}) \\\\=PE_{(pos,2i)}cos(\\frac{k}{W_{i}})+PE_{(pos,2i+1)}sin(\\frac{k}{W_{i}})$$ $$PE_{(pos+k,2i+1)}=cos(\\frac{pos+k}{W_{i}})=cos(\\frac{pos}{W_{i}})cos(\\frac{k}{W_{i}})-sin(\\frac{pos}{W_{i}})sin(\\frac{k}{W_{i}}) \\\\=PE_{(pos,2i+1)}cos(\\frac{k}{W_{i}})-PE_{(pos,2i)}sin(\\frac{k}{W_{i}})$$ 可以看到$PE_{pos+k}$的确是$PE_{pos}$的线性函数。 位置编码的代码如下： class PositionalEncoding(nn.Module): \"\"\" Implement the PE function. \"\"\" def __init__(self, d_model, dropout, max_len=5000): super(PositionalEncoding, self).__init__() self.dropout = nn.Dropout(p=dropout) # Compute the positional encodings once in log space. pe = torch.zeros(max_len, d_model) position = torch.arange(0, max_len).unsqueeze(1) div_term = torch.exp(torch.arange(0, d_model, 2) * -(math.log(10000.0) / d_model)) pe[:, 0::2] = torch.sin(position * div_term) pe[:, 1::2] = torch.cos(position * div_term) pe = pe.unsqueeze(0) self.register_buffer('pe', pe) def forward(self, x): x = x + self.pe[:, :x.size(1)] return self.dropout(x) 完整模型这里我们定义一个函数，输入是超参，输出是根据超参构建的模型： def make_model(src_vocab, tgt_vocab, N=6, d_model=512, d_ff=2048, h=8, dropout=0.1): \"\"\" Helper: Construct a model from hyperparameters. \"\"\" c = copy.deepcopy attn = MultiHeadedAttention(h, d_model) ff = PositionwiseFeedForward(d_model, d_ff, dropout) position = PositionalEncoding(d_model, dropout) model = EncoderDecoder( Encoder(EncoderLayer(d_model, c(attn), c(ff), dropout), N), Decoder(DecoderLayer(d_model, c(attn), c(attn), c(ff), dropout), N), nn.Sequential(Embeddings(d_model, src_vocab), c(position)), nn.Sequential(Embeddings(d_model, tgt_vocab), c(position)), Generator(d_model, tgt_vocab)) # This was important from their code. # Initialize parameters with Glorot / fan_avg. for p in model.parameters(): if p.dim() &gt; 1: nn.init.xavier_uniform_(p) return model 模型训练首先我们需要一个Batch类，用于提供批次数据，并且构造所需要的掩码： class Batch(object): \"\"\" Object for holding a batch of data with mask during training. \"\"\" def __init__(self, src, trg=None, pad=0): self.src = src self.src_mask = (src != pad).unsqueeze(-2) if trg is not None: self.trg = trg[:, :-1] self.trg_y = trg[:, 1:] self.trg_mask = self.make_std_mask(self.trg, pad) self.ntokens = (self.trg_y != pad).sum().item() @staticmethod def make_std_mask(tgt, pad): \"\"\" Create a mask to hide padding and future words. \"\"\" tgt_mask = (tgt != pad).unsqueeze(-2) tgt_mask = tgt_mask &amp; subsequent_mask(tgt.size(-1)) return tgt_mask 值得注意的是解码阶段的Mask(代码中是trg_mask)需要将未来时刻的输出掩盖掉，这在前面已经实现了相应的函数(即subsequent_mask函数)。 接下来再写出运行一个epoch的训练代码，非常的简单： def run_epoch(data_iter, model, loss_compute): \"\"\" Standard Training and Logging Function \"\"\" start = time.time() total_tokens = 0 total_loss = 0 tokens = 0 for i, batch in enumerate(data_iter): out = model.forward(batch.src, batch.trg, batch.src_mask, batch.trg_mask) loss = loss_compute(out, batch.trg_y, batch.ntokens) total_loss += loss total_tokens += batch.ntokens tokens += batch.ntokens if i % 50 == 1: elapsed = time.time() - start print(\"Epoch Step: %d Loss: %f Tokens per Sec: %f\" % (i, loss / batch.ntokens, tokens / elapsed)) start = time.time() tokens = 0 return total_loss / total_tokens 对于优化器(optimizer)，论文选用了常见的 Adam optimizer ，相应的优化器参数是$\\beta_1=0.9,\\beta_2=0.98,\\epsilon=10^{-9}$。特别的，对于比较重要的学习率参数，是随着训练的进行动态变化的，具体公式如下： $$lrate=d_{model}^{-0.5} \\cdot min(step\\_num^{−0.5},step\\_num \\cdot warmup\\_steps^{−1.5})$$ 也就是在最开始的$warmup\\_steps$步，学习率线性增加；然后再慢慢的非线性降低。论文中$warmup\\_steps=4000$。 class NoamOpt(object): \"\"\" Optim wrapper that implements rate. \"\"\" def __init__(self, model_size, factor, warmup, optimizer): self.optimizer = optimizer self._step = 0 self.warmup = warmup self.factor = factor self.model_size = model_size self._rate = 0 def step(self): \"\"\" Update parameters and rate. \"\"\" self._step += 1 rate = self.rate() for p in self.optimizer.param_groups: p['lr'] = rate self._rate = rate self.optimizer.step() def rate(self, step=None): if step is None: step = self._step return self.factor * (self.model_size ** (-0.5) * min(step ** (-0.5), step * self.warmup ** (-1.5)))def get_std_opt(model): return NoamOpt(model.src_embed[0].d_model, 2, 4000, torch.optim.Adam(model.parameters(), lr=0, betas=(0.9, 0.98), eps=1e-9)) 论文中使用到了3种Regularization，一种是Dropout，一种是残差连接，这两种前面已经做出讲解。最后一种是Label Smoothing，虽然Label Smoothing增加了模型训练的困惑度，但是的确使得最终的指标上升了，具体实现如下： class LabelSmoothing(nn.Module): \"\"\" Implement label smoothing. \"\"\" def __init__(self, size, padding_idx, smoothing=0.0): super(LabelSmoothing, self).__init__() self.criterion = nn.KLDivLoss(reduction='sum') self.padding_idx = padding_idx self.confidence = 1.0 - smoothing self.smoothing = smoothing self.size = size self.true_dist = None def forward(self, x, target): assert x.size(1) == self.size true_dist = x.clone() true_dist.fill_(self.smoothing / (self.size - 2)) true_dist.scatter_(1, target.unsqueeze(1), self.confidence) true_dist[:, self.padding_idx] = 0 mask = torch.nonzero(target == self.padding_idx) if mask.size(0) &gt; 0: true_dist.index_fill_(0, mask.squeeze(), 0.0) self.true_dist = true_dist return self.criterion(x, true_dist) A First Example论文中要完成的是一个机器翻译任务，但是那可能有点麻烦，所以我们就来完成一个简单的复制任务来检验我们的模型，也就是给定来自一个小型词汇表的token序列，我们的目标是通过Encoder-Decoder结构生成相同的token序列，例如输入是[1,2,3,4,5]，那么生成的序列也应该是[1,2,3,4,5]。 任务数据生成代码如下，让src=trg即可。 def data_gen(V, batch, nbatches): \"\"\" Generate random data for a src-tgt copy task. \"\"\" for i in range(nbatches): data = torch.from_numpy(np.random.randint(1, V, size=(batch, 10))) data[:, 0] = 1 yield Batch(src=data, trg=data, pad=0) 然后是一个计算loss的方法： class SimpleLossCompute(object): \"\"\" A simple loss compute and train function. \"\"\" def __init__(self, generator, criterion, opt=None): self.generator = generator self.criterion = criterion self.opt = opt def __call__(self, x, y, norm): x = self.generator(x) loss = self.criterion(x.contiguous().view(-1, x.size(-1)), y.contiguous().view(-1)) / norm loss.backward() if self.opt is not None: self.opt.step() self.opt.optimizer.zero_grad() return loss.item() * norm 在预测阶段是一个自回归模型，为了简单我们直接使用Greedy Search(一般情况下是使用Beam Search)，也就是每一个时刻都取概率最大的词作为输出。 def greedy_decode(model, src, src_mask, max_len, start_symbol): memory = model.encode(src, src_mask) ys = torch.ones(1, 1, dtype=torch.long).fill_(start_symbol) for i in range(max_len - 1): out = model.decode(memory, src_mask, ys, subsequent_mask(ys.size(1))) prob = model.generator(out[:, -1]) _, next_word = torch.max(prob, dim=1) next_word = next_word.item() ys = torch.cat([ys, torch.ones(1, 1, dtype=torch.long).fill_(next_word)], dim=1) return ys 最后，将这个例子运行起来，我们便可以看到，几分钟的时间内Transformer已经能够完美的完成这个复制任务！ # Train the simple copy task.V = 11criterion = LabelSmoothing(size=V, padding_idx=0, smoothing=0.0)model = make_model(V, V, N=2)model_opt = NoamOpt(model.src_embed[0].d_model, 1, 400, torch.optim.Adam(model.parameters(), lr=0, betas=(0.9, 0.98), eps=1e-9))for epoch in range(15): model.train() run_epoch(data_gen(V, 30, 20), model, SimpleLossCompute(model.generator, criterion, model_opt)) model.eval() print(run_epoch(data_gen(V, 30, 5), model, SimpleLossCompute(model.generator, criterion, None)))# This code predicts a translation using greedy decoding for simplicity.print()print(\"&#123;&#125;predict&#123;&#125;\".format('*' * 10, '*' * 10))model.eval()src = torch.tensor([[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]])src_mask = torch.ones(1, 1, 10)print(greedy_decode(model, src, src_mask, max_len=10, start_symbol=1)) 结语本文相对于 原博客 有所扩充也有所删减。扩充主要在对代码的讲解部分；删减则主要是并没有完全复现机器翻译的任务，但是其实机器翻译的任务与上节中的复制任务是非常类似的，所以也没有继续在这上面花费精力，若对机器翻译非常感兴趣的童鞋倒是可以阅读 原博客 了解更多。 总体来说我们完完全全复现了 “Attention is All You Need” 中的结构，论文的思想真的的非常棒的！代码也在PyTroch 1.3的环境中测试通过，许多组件具有很好复用性，完整代码可见 Transformer Code ，可以方便以后对铺天盖地的基于Transformer的预训练模型的学习。","categories":[{"name":"NLP","slug":"NLP","permalink":"http://www.yingzq.com/categories/NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://www.yingzq.com/tags/NLP/"},{"name":"Transformer","slug":"Transformer","permalink":"http://www.yingzq.com/tags/Transformer/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://www.yingzq.com/tags/Deep-Learning/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://www.yingzq.com/tags/PyTorch/"},{"name":"BERT","slug":"BERT","permalink":"http://www.yingzq.com/tags/BERT/"}]},{"title":"Transformer图解","slug":"the-illustrated-transformer","date":"2019-10-29T16:23:45.000Z","updated":"2020-03-03T05:27:13.700Z","comments":true,"path":"2019/10/30/the-illustrated-transformer/","link":"","permalink":"http://www.yingzq.com/2019/10/30/the-illustrated-transformer/","excerpt":"Transformer模型来自论文 Attention Is All You Need 。这个模型最初是为了提高机器翻译的效率，它的Self-Attention机制和Position Encoding可以替代RNN。因为RNN是顺序执行的，t时刻没有完成就不能处理t+1时刻，因此很难并行。但是后来发现Self-Attention效果很好，在很多其它的地方也可以使用Transformer模型。这包括著名的GPT和BERT模型，都是以Transformer为基础的。 本文我们将通过图解的方式来直观的理解Transformer模型的基本原理，内容主要参考了文章 The Illustrated Transformer 。","text":"Transformer模型来自论文 Attention Is All You Need 。这个模型最初是为了提高机器翻译的效率，它的Self-Attention机制和Position Encoding可以替代RNN。因为RNN是顺序执行的，t时刻没有完成就不能处理t+1时刻，因此很难并行。但是后来发现Self-Attention效果很好，在很多其它的地方也可以使用Transformer模型。这包括著名的GPT和BERT模型，都是以Transformer为基础的。 本文我们将通过图解的方式来直观的理解Transformer模型的基本原理，内容主要参考了文章 The Illustrated Transformer 。 模型概述我们首先把模型看成一个黑盒子，如下图所示，对于机器翻译来说，它的输入是源语言(法语)的句子，输出是目标语言(英语)的句子。 图：Transformer的输入和输出 把黑盒子稍微打开一点，我们可以看到Transformer(或者任何的NMT系统)由2个部分组成：Encoders和Decoders，如下图所示： 图：典型的Encoder-Decoder结构 注：这里Encoder/Decoder使用复数形式是为了强调编码/解码阶段可能由多个组件堆叠而成，下文会讲到 其中Encoders是由多个(论文中是6个)Encoder堆叠而成，Decoders也同样是由多个(论文中是6个)Decoder堆叠而成，如下图所示： 图：Stacked Encoder and Decoder 对于Encoders中的每一个Encoder，它们结构都是相同的，但是并不会共享权值。每个Encoder由两个子网络层组成，分别是一个Self-Attention层和一个Feed-Forward层(全连接层)，如下图所示： 图：Transformer的一个Encoder层 对于Decoders中的每一个Decoder，它们的结构也都是相同的并且权值不共享。相比于Encoder，每一个Decoder除了Self-Attention层和全连接层之外还多了一个普通的Attention层，这个Attention层使得Decoder在解码时会考虑最后一层Encoder所有时刻的输出。 它的结构如下图所示： 图：Transformer的一个Decoder层 画出Tensor进行分析现在我们已经了解了模型的主要组件，让我们开始研究对应的Tensor如何在这些组件之间流动。 由于输入的句子是一个词的序列，利用NLP的常规做法，我们先通过Embedding把它变成一个连续稠密的向量，如下图所示： 图：Emebdding层 注：每一个词都编码成了512维度的向量，为了便于展示我们将用上面这些简单的小方块来表示这些向量 虽然Emebdding层只发生在最底层的Encoder中，但是对于所有的Encoder层，你都可以按照同一种思维模式来理解，那就是它们都接收一个512维度的向量列表作为输入，只不过最底层的Encoder接收的是单词嵌入，其它Encoder则接收的是前一层Encoder的输出。 Embedding之后的序列会输入到最底层的Encoder，首先经过Self-Attention层然后再经过全连接层，如下图所示： 图：Transformer Encoder层 开始编码接下来，我们将以一个较短的句子为例，看看在编码器中每个子层中具体都发生了什么，首先最底层的Encoder结构如下图所示： 图：Transformer Encoder层 可以看出这张图与上一张图内容基本相同，但是其实本张图展示了更多的细节：图中Self-Attention层是一个大的方框，表示它的输入是所有的$x_1,x_2,\\ldots,x_n$，输出是$z_1,z_2,\\ldots,z_n$，也就是说在计算$z_i$时需要依赖所有时刻的输入$x_1,x_2,\\ldots,x_n$，不过我们可以用矩阵运算一下子把所有的$z_i$计算出来(后面介绍)；而全连接层是每个时刻是一个方框(但不同时刻的参数是共享的)，表示计算$r_i$只需要$z_i$，因此全连接网络的计算是完全是独立的，很容易并行计算；此外，前一层的输出$r_1,r_2,\\ldots,r_n$直接输入到下一层。 Self-Attention概述再把黑盒子打开一点，我们来了解一下Tensor如何在Self-Attention层中流动。 Self-Attention是Trandformer中最重要的组件，我们先来提炼一下它是如何工作的。假如我们想要翻译下面的句子： &quot;The animal didn&#39;t cross the street because it was too tired&quot; 句子的意思大概是“这个动物无法穿越马路，因为它太累了”，这里的it到底指代什么呢，是animal还是street？要知道具体的指代，我们需要在理解it的时候同时关注所有的单词，重点是animal、street和tired，然后根据知识(常识)我们知道只有animal才能tired，而street是不能tired的。Self-Attention用Encoder在编码一个词的时候会考虑句子中所有其它的词，从而确定怎么编码当前词。 但是如果把tired换成narrow，那么it就指代的是street了。 而LSTM(即使是双向的)是无法实现上面的逻辑的。 为什么呢？比如前向的LSTM，我们在编码it的时候根本没有看到后面是tired还是narrow，所有它无法把it编码成哪个词。而后向的LSTM呢？当然它看到了tired，但是到it的时候它还没有看到animal和street这两个单词，当然就更无法编码it的内容了。 当然多层的LSTM理论上是可以编码这个语义的，它需要下层的LSTM同时编码了animal和street以及tired三个词的语义，然后由更高层的LSTM来把it编码成animal的语义。但是这样模型更加复杂。 下图是模型的最上一层(下标0是第一层，5是第六层)Encoder的Attention可视化图，这是 Tensor2Tensor notebook 输出的内容： 图：Self-Attention的可视化 我们可以看到，在编码it这个单词的时候，Self-Attention让模型更多地关注到“The animal”，因此编码后的it有了Animal的语义。 Self-Attention详细介绍下面我们详细的介绍Self-Attention是怎么计算的，首先介绍向量的形式逐个时刻计算，这便于理解，接下来我们把它写出矩阵的形式一次计算所有时刻的结果。 对于输入的每一个向量(第一层是词的Embedding，其它层是前一层的输出)，我们首先需要生成3个新的向量Q、K和V，分别代表Query向量、Key向量和Value向量。Query向量表示为了编码当前词，需要去注意(attend to)其它(其实也包括它自己)的词；而Key向量可以认为是这个词用于被检索的关键信息；Value向量则是真正的内容。 我们对比一下普通的Attention(Luong 2015)，使用内积计算energy的情况。如下图所示，在这里，Key和Value向量都是它本身，而Query向量是当前隐状态$h_t$。计算energy $e_{tj}$的时候我们计算Q($h_t$)和K($\\overline{h}_j$)的内积，然后用softmax进行归一化，最后把所有的$\\overline{h}_j$加权平均得到context向量。 图：普通的Attention机制 而Self-Attention里的Query不是隐状态，并且来自当前输入向量本身，因此叫作Self-Attention。 另外Key和Value都不是输入向量，而是输入向量做了一下线性变换，这样做的好处是模型可以根据数据从输入向量中提取最适合作为Key和Value的部分。类似的，Query也是对输入向量做一下线性变换，它让系统可以根据任务学习出最适合的Query，从而可以注意到特定的内容。 K、V和Q的具体的计算过程如下如所示： 图：K、V和Q的计算过程 图中输入的是两个词“thinking”和“machines”，我们对它们进行Embedding(这是第一层，如果是后面的层，直接输入就是向量了)，得到向量$x_1$,$x_2$。接着我们用3个矩阵分别对它们进行变换，得到向量$q_1,k_1,v_1$和$q_2,k_2,v_2$。比如$q_1=x_1W^Q$，图中$x_1$的shape是1x4，$W^Q$是4x3，得到的$q_1$便是1x3。其它的计算也是类似的。 值得注意的是，为了能够使得Key和Query可以内积，我们要求$W^K$和$W^Q$的shape是一样的，但是并不要求$W^V$和它们一定一样(虽然实际论文实现是一样的)。 每个时刻t都计算出$q_t,k_t,v_t$后，我们就可以来计算Self-Attention了。以第一个时刻为例，我们首先计算$q_1$和$k_1,k_2$的内积，得到score，过程如下图所示： 图：Self-Attention的向量计算步骤一 接下来使用softmax把score归一化，注意这里把score除以$\\sqrt{d_k}$($d_k$表示Key向量的维度)之后再计算的softmax，根据论文的说法，这样计算梯度时会更加稳定(stable)。计算过程如下图所示： 图：Self-Attention的向量计算步骤二 简单阐述下为什么这里要除以$\\sqrt{d_k}$。假设q、k向量中的每一个元素是独立的随机变量并且它们的均值是0方差是1，此时将q、k向量做点乘运算$q \\cdot k=\\sum_{i=1}^{d_k} q_i k_i$，点乘的结果是一个均值为0，方差为$d_k$的随机变量。 接下来用softmax得到的归一化分数对所有时刻的V求加权平均，这样就可以认为得到的向量在Self-Attention的帮助下综合考虑了所有时刻的输入信息，计算过程如下图所示： 图：Self-Attention的向量计算步骤三 这里只是演示了计算第一个时刻的过程，计算其它时刻的过程是完全一样的。 Self-Attention的矩阵计算前面介绍的方法需要一个循环遍历所有的时刻t计算得到$z_t$，我们可以把上面的向量计算变成矩阵的形式，从而一次计算出所有时刻的输出，这样的矩阵运算可以充分利用硬件资源(包括一些软件的优化)，从而效率更高。 首先还是计算Q、K和V，不过不是计算某个时刻的$q_t,k_t,v_t$了，而是一次计算所有时刻的Q、K和V。计算过程如下图所示。这里的输入是一个矩阵，矩阵的第i行表示第i个时刻的输入$x_i$。 图：Self-Attention的矩阵计算步骤一 接下来就是计算Q和K得到score，然后除以$\\sqrt{d_k}$，然后再softmax，最后加权平均得到输出。全过程如下图所示： 图：Self-Attention的矩阵计算步骤二 Multi-Head Attention这篇论文还提出了Multi-Head Attention的概念。其实很简单，前面定义的一组Q、K和V可以让一个词attend to相关的词，我们可以定义多组Q、K和V，它们分别可以关注不同的上下文。计算Q、K和V的过程还是一样，这不过现在变换矩阵从一组$(W^Q,W^K,W^V)$变成了多组$(W_0^Q,W_0^K,W_0^V)$ ，$(W_1^Q,W_1^K,W_1^V)$，…。如下图所示： 图：Multi-Head计算多组Q、K和V 论文中使用了8组不同的Q、K和V。对于输入矩阵X，每一组Q、K和V都可以得到一个输出矩阵Z，如下图所示： 图：Multi-Head计算输出多个Z 但是后面的全连接网络需要的输入是一个矩阵而不是多个矩阵，因此我们可以把每个head输出的$Z_i$拼接起来，然后再经过一个线性变换(矩阵$W^O$)得到最终的输出矩阵Z。这个过程如下图所示： 图：Multi-Head生成最终的矩阵Z 上面的步骤涉及很多步骤和矩阵运算，我们用一张大图把整个过程表示出来，如下图所示： 图：Multi-Head计算完整过程 让我们回顾一下之前的例子，当我们在例句“The animal didn’t cross the street because it was too tired”中编码单词“it”时，不同的head把焦点放到了哪里： 图：Multi-Head Attention的焦点 可以看到，有的head(橘黄色部分)计算的结果认为其与“the animal”关系比较密切，而另一个head(绿色部分)则认为和“tired”关系更近。换句话说，使用Multi-Head Attention对“it”进行编码时，可以同时注意到“animal”和“tired”，这使得对“it”的编码更加全面而准确。 位置编码(Positional Encoding) 注意：这是Transformer原始论文使用的位置编码方法，而在BERT模型里，使用的是简单的可以学习的Embedding，和Word Embedding一样，只不过输入是位置而不是词而已。 我们的目的是用Self-Attention替代RNN，RNN能够记住过去的信息，这可以通过Self-Attention“实时”的注意相关的任何词来实现等价(甚至更好)的效果。RNN还有一个特点就是能考虑词的顺序(位置)关系，一个句子即使词完全是相同的但是语义可能完全不同，比如“北京到上海的机票”与“上海到北京的机票”，它们的语义就有很大的差别。我们上面的介绍的Self-Attention是不考虑词的顺序的，如果模型参数固定了，上面两个句子的北京都会被编码成相同的向量。但是实际上我们可以期望这两个北京编码的结果不同，前者可能需要编码出发城市的语义，而后者需要包含目的城市的语义。而RNN是可以(至少是可能)学到这一点的。当然RNN为了实现这一点的代价就是顺序处理，很难并行。 为了解决这个问题，我们需要引入位置编码，也就是t时刻的输入，除了Embedding之外(这是与位置无关的)，我们还引入一个向量，这个向量是与t有关的，我们把Embedding和位置编码向量加起来作为模型的输入。这样的话如果两个词在不同的位置出现了，虽然它们的Embedding是相同的，但是由于位置编码不同，最终得到的向量也是不同的。 位置编码有很多方法，其中需要考虑的一个重要因素就是需要它编码的是相对位置的关系。比如两个句子：“北京到上海的机票”和“你好，我们要一张北京到上海的机票”。显然加入位置编码之后，两个北京的向量是不同的了，两个上海的向量也是不同的了，但是我们期望$Q_{北京1} K_{上海1}=Q_{北京2} K_{上海2}$。具体的位置编码算法不是这里关注的重点，我们以后再介绍。位置编码加入后的模型如下图所示： 图：位置编码 举一个简单的例子，假设Embedding的维度是4，那么实际的位置编码应该是这样的： 图：位置编码例子 残差连接在继续之前，我们需要说说编码器架构中的一个细节：每个Encoder中的每个子层(Self-Attention层和全连接层)在其周围都有一个残差连接，然后紧接着是一个 Layer Normalization 层。如下图所示： 图：残差和Layer Normalization 下图则展示了更多细节：输入$x_1,x_2$经Self-Attention层之后变成$z_1,z_2$，然后和残差连接的输入$x_1,x_2$加起来，然后经过Layer Normalization层输出给全连接层；全连接层正如上文提到的也是有一个残差连接和一个Layer Normalization层，最后再输出给上一层。 图：残差和Layer Normalization细节 Decoder和Encoder是类似的，区别在于它多了一个Encoder-Decoder Attention层，这个层的输入除了来自Self-Attention之外还有Encoder最后一层的所有时刻的输出。Encoder-Decoder Attention层的Query来自下一层，而Key和Value则来自Encoder的输出。 如果我们仅考虑一个由两个编码器和两个解码器组成的Transformer，它看起来是这样的: 图：两层Encoder、Decoder堆叠的Transformer 省略部分到这里，Transformer的主体部分已经全部介绍完，关于机器翻译任务解码的细节、最后输出层的设计、损失函数的选取等并不是本文关注的重点，我们会在 Transformer代码实现 中完完全全的实现一遍，在这里便不做多余的介绍。","categories":[{"name":"NLP","slug":"NLP","permalink":"http://www.yingzq.com/categories/NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://www.yingzq.com/tags/NLP/"},{"name":"Transformer","slug":"Transformer","permalink":"http://www.yingzq.com/tags/Transformer/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://www.yingzq.com/tags/Deep-Learning/"},{"name":"BERT","slug":"BERT","permalink":"http://www.yingzq.com/tags/BERT/"}]},{"title":"贪心算法","slug":"greedy-algorithm","date":"2019-10-22T14:04:30.000Z","updated":"2020-02-20T12:28:31.229Z","comments":true,"path":"2019/10/22/greedy-algorithm/","link":"","permalink":"http://www.yingzq.com/2019/10/22/greedy-algorithm/","excerpt":"","text":"贪心算法，又名贪婪算法，是在寻找最优解问题时的常用方法。贪心算法分阶段地工作，在每一个阶段，选取当前状态下最好或最优的的选择，而不考虑将来的后果。通常，这意味着选择的是某个局部最优。这种 “眼下能够拿到的就拿” 的策略也正是贪心算法名称的由来，就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。 当算法终止时，我们希望局部最优等于全局最优。如果是这样的话，那么算法就是正确的；否则，算法得到的就是一个次最优解（suboptimal solution）。如果不要求绝对最佳答案，有时候也可以使用简单的贪心算法生成近似的答案，而无需使用产生准确答案所需要的复杂算法。 注：本文我们主要考虑第一种情况，也就是贪心算法能得到最优解的情况 贪心算法的应用实例也非常广泛，例如最短路径中的Dijkstra算法，最小生成树中的Prim算法和Kruskal算法。所以贪心算法是值得我们深入了解的。 基本思路首先要明确一个问题可以使用贪心算法的两个基本要素： 贪心选择性质：所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到 最优子结构性质：一个问题的最优解包含其子问题的最优解 贪心算法的基本过程如下： 建立数学模型来描述问题 把求解的问题分成若干个子问题 对每一子问题求解，得到子问题的局部最优解 把子问题的解局部最优解合成原来解问题的一个解 其实上面的两段话大致有个印象就好，具体的做法我们接下来通过一些例子学习。 例题分析分发饼干（LeetCode455 easy）题目：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意： 你可以假设胃口值为正。 一个小朋友最多只能拥有一块饼干。 示例： 输入: [1,2,3], [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 分析咋一看似乎有点麻烦，回溯、动态规划什么的已经开始酝酿了！但是再一想，本题的目标是尽可能满足多数量的孩子，那么很显然有如下结论：无论饼干情况如何，肯定是先满足胃口小的孩子是最优的；反之对于某个特定孩子而言，饼干肯定要选择最小的但是能满足该孩子的是最优的。 所以这题可以使用贪心算法，优先使用最小的饼干满足最小的胃口，如果不可以，则丢弃这个饼干，采用次小的，依次类推，直到没有饼干或者没有小朋友。具体代码思路如下： 对g和s升序排序 初始化两个指针i和j分别指向g和s初始位置 对比g[i]和s[j] g[i] &lt;= s[j]： 饼干满足胃口，把能满足的孩子数量加 1，并移动指针i = i + 1，j = j + 1 g[i] &gt; s[j]：无法满足胃口，j右移，继续查看下一块饼干是否可以满足胃口 Java代码 class Solution &#123; public int findContentChildren(int[] g, int[] s) &#123; Arrays.sort(g); Arrays.sort(s); int i = 0; for(int j=0;i&lt;g.length &amp;&amp; j&lt;s.length;j++) &#123; if(g[i]&lt;=s[j]) i++; &#125; return i; &#125;&#125; 柠檬水找零（LeetCode 860 easy）题目在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，按账单 bills 支付的顺序一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例 输入：[5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。 分析顾客付款有三种可能：5、10、20。 如果收到5美元，直接把5元放进口袋，什么也不用做 如果收到的10美元，则需要翻一翻自己的口袋里是否有5美元的零钱，没有则交易失败，可以关门回家了（返回false） 如果收到20美元，这时可以找零10美元+5美元或者三张5美元，这个时候如何抉择呢？我们使用贪心策略，尽可能地多留5元在手上，防止后面付款10元的顾客无法找零，也就是优先使用10美元+5美元，如果没有则使用5美元+5美元+5美元的组合，都不成立的话则交易失败，可以关门回家了（返回false） 可以很显然的看出，当算法终止时局部最优是等于全局最优的，这一题的贪心策略是完全正确的。 Java代码 class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; int five = 0, ten = 0; for (int i : bills) &#123; if (i == 5) five++; else if (i == 10) &#123;five--; ten++;&#125; else if (ten &gt; 0) &#123;ten--; five--;&#125; else five -= 3; if (five &lt; 0) return false; &#125; return true; &#125;&#125; 跳跃游戏（LeetCode 55 medium）给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 示例 输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 分析这题粗略一看是可以用动态规划完成的，但是仔细研读后，其实我们很容易有这种想法： 如果某一个作为起跳点的格子可以跳跃的距离是3，那么表示后面3个格子都可以作为起跳点 那么我们选择这3个起跳点中的哪一个呢？其实在这里，我们是希望选择的新的起跳点可以让后续的跳跃尽可能的远，这样的局部最优很显然是全局最优。所以可以对每一个能作为起跳点的格子都尝试跳一次，把能跳到的最远距离不断更新 如果可以一直跳到最后就成功了，反之则失败 那什么是能跳到的最远距离呢？在代码中便是i+nums[i]，也就是此时数组的下标加上该位置数组元素对应的数值。 Java代码 class Solution &#123; public boolean canJump(int[] nums) &#123; int max = 0; for(int i = 0;i &lt; nums.length;i++) &#123; if(max &lt; i) return false; max = Math.max(i + nums[i], max); &#125; return true; &#125;&#125; 参考文献 小白带你学—贪心算法 LeetCode Algorithms","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.yingzq.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://www.yingzq.com/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.yingzq.com/tags/LeetCode/"},{"name":"算法设计技巧","slug":"算法设计技巧","permalink":"http://www.yingzq.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/"}]},{"title":"Git的杀手锏：分支模型（下）","slug":"git-branching-part-two","date":"2019-10-16T05:12:25.000Z","updated":"2020-02-19T17:40:19.606Z","comments":true,"path":"2019/10/16/git-branching-part-two/","link":"","permalink":"http://www.yingzq.com/2019/10/16/git-branching-part-two/","excerpt":"在 Git的杀手锏：分支模型（上）中，我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作。在本章我们继续来学习Git分支的工作流、远程分支和变基等内容。","text":"在 Git的杀手锏：分支模型（上）中，我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作。在本章我们继续来学习Git分支的工作流、远程分支和变基等内容。 Git分支开发工作流现在我们已经学会新建和合并分支，那么可以或者应该用它来做些什么呢？本节会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出这些典型的工作模式。 长期分支因为Git使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。 许多使用Git的开发者都喜欢使用这种方式来工作，比如只在master分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。他们还有一些名为develop或者next的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入master分支了。这样，在确保这些已完成的特性分支（短期分支，比如之前的iss53分支）能够通过所有测试，并且不会引入更多bug之后，就可以合并入主干分支中，等待下一次的发布。 事实上我们刚才讨论的，是随着你的提交而不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。 图1：渐进稳定分支的线性图 通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。 图2：渐进稳定分支的流水线视图 你可以用这种方法维护不同层次的稳定性。一些大型项目还有一个proposed（建议）或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入next或者master分支。这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。 特性分支特性分支对任何规模的项目都适用。特性分支是一种短期分支，它被用来实现单一特性或其相关工作。也许你从来没有在其他的版本控制系统上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。然而，在Git中一天之内多次创建、使用、合并、删除分支都很常见。 你已经在前文中创建的iss53和hotfix特性分支中看到过这种用法。你在特性分支（iss53和hotfix分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。 考虑这样一个例子，你在master分支上工作到C1，这时为了解决一个问题而新建iss91分支，在iss91分支上工作到C4，然而对于那个问题你又有了新的想法，于是你再新建一个iss91v2分支试图用另一种方法解决那个问题，接着你回到master分支工作了一会儿，你又冒出了一个不太确定的想法，你便在C10的时候新建一个dumbidea分支，并在上面做些实验。你的提交历史看起来像下面这个样子： 图3：拥有多个特性分支的提交历史 现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在iss91v2分支中方案；另外，你将dumbidea分支拿给你的同事看过之后，结果发现这是个惊人之举。这时你可以抛弃iss91分支（即丢弃C5和C6提交），然后把另外两个分支合并入主干分支。最终你的提交历史看起来像下面这个样子： 图4：合并了dumbidea和iss91v2分支之后的提交历史 更多有关分支工作流的细节可以参考 Distributed Workflows 最后请牢记，当你做这么多操作的时候，这些分支全部都存于本地。当你新建和合并分支的时候，所有这一切都只发生在你本地的Git版本库中，没有与服务器发生交互。 Git远程分支远程引用是对远程仓库的引用（指针），包括分支、标签等等。你可以通过git ls-remote [remote]来显式地获得远程引用的完整列表，或者通过git remote show [remote]获得远程分支的更多信息。然而，一个更常见的做法是利用远程跟踪分支。 远程跟踪分支是远程分支状态的引用。它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。 它们以&lt;remote&gt;/&lt;branch&gt;形式命名。例如，如果你想要看你最后一次与远程仓库origin通信时master分支的状态，你可以查看origin/master分支。你与同事合作解决一个问题并且他们推送了一个iss53分支，你可能有自己的本地iss53分支；但是在服务器上的分支会指向origin/iss53的提交。 这可能有一点儿难以理解，让我们来看一个例子。假设你的网络里有一个在git.ourcompany.com的Git服务器。如果你从这里克隆，Git的clone命令会为你自动将其命名为origin，拉取它的所有数据，创建一个指向它的master分支的指针，并且在本地将其命名为origin/master。Git也会给你一个与origin的master分支在指向同一个地方的本地master分支，这样你就有工作的基础。 注意：“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在Git中并没有任何特别的含义一样。同时 “master” 是当你运行git init时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行git clone时默认的远程仓库名字。如果你运行git clone -o booyah，那么你默认的远程分支名字将会是booyah/master。 图5：克隆之后的服务器与本地仓库 如果你在本地的master分支做了一些工作，与此同时，其他人推送提交到git.ourcompany.com并更新了它的master分支，那么你的提交历史将向不同的方向前进。另外，只要你不与origin服务器连接，你的origin/master指针就不会移动。 图6：本地与远程的工作可以分叉 如果要同步你的工作，运行git fetch &lt;remote&gt;命令（在本例中是git fetch origin）。这个命令查找 “origin” 是哪一个服务器（在本例中是git.ourcompany.com），从中抓取本地没有的数据，并且更新本地数据库，移动origin/master指针指向更新后的位置。 图7：git fetch更新远程仓库引用 为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部Git服务器，仅用于你小组的开发工作。这个服务器位于git.team1.ourcompany.com。你可以运行git remote add命令添加一个新的远程仓库引用到当前的项目。将这个远程仓库命名为teamone，将其作为整个URL的缩写。 图8：添加另一个远程仓库 现在，可以运行git fetch teamone来抓取远程仓库teamone有而本地没有的数据。因为那台服务器上现有的数据是origin服务器上的一个子集，所以Git并不会抓取数据而是会设置远程跟踪分支teamone/master指向teamone的master分支。 图9：远程跟踪分支teamone/master 推送当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。 如果希望和别人一起在名为serverfix的分支上工作，你可以像推送第一个分支那样推送它。运行git push &lt;remote&gt; &lt;branch&gt;: $ git push origin serverfixCounting objects: 24, done.Delta compression using up to 8 threads.Compressing objects: 100% (15&#x2F;15), done.Writing objects: 100% (24&#x2F;24), 1.91 KiB | 0 bytes&#x2F;s, done.Total 24 (delta 2), reused 0 (delta 0)To https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit * [new branch] serverfix -&gt; serverfix 这里有些工作被简化了。Git自动将serverfix分支名字展开为refs/heads/serverfix:refs/heads/serverfix，那意味着，“推送本地的serverfix分支来更新远程仓库上的serverfix分支。” 你也可以运行git push origin serverfix:serverfix，它会做同样的事——也就是说 “推送本地的serverfix分支，将其作为远程仓库的serverfix分支”。你也可以通过这种格式来推送本地分支到一个命名不相同的远程分支，例如你并不想让远程仓库上的分支叫做serverfix，可以运行git push origin serverfix:awesomebranch来将本地的serverfix分支推送到远程仓库上的awesomebranch分支。 下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支origin/serverfix，指向服务器的serverfix分支的引用： $ git fetch originremote: Counting objects: 7, done.remote: Compressing objects: 100% (2&#x2F;2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3&#x2F;3), done.From https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit * [new branch] serverfix -&gt; origin&#x2F;serverfix 要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本。换句话说，这种情况下，不会有一个新的serverfix分支，只有一个不可以修改的origin/serverfix指针。 可以运行git merge origin/serverfix将这些工作合并到当前所在的分支。如果想要在自己的serverfix分支上工作，可以将其建立在远程跟踪分支之上： $ git checkout -b serverfix origin&#x2F;serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch &#39;serverfix&#39; 这会给你一个用于工作的本地分支，并且起点位于origin/serverfix。 跟踪分支从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。跟踪分支是与远程分支有直接关系的本地分支。如果在一个跟踪分支上输入git pull，Git能自动地识别去哪个服务器上抓取、合并到哪个分支。 当克隆一个仓库时，它通常会自动地创建一个跟踪origin/master的master分支。然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪master分支。最简单的实例就是像之前看到的那样，运行git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;。这是一个十分常用的操作所以Git提供了--track快捷方式： $ git checkout --track origin&#x2F;serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch &#39;serverfix&#39; 事实上，这个命令实在是太常用了，所以有一个快捷方式中的快捷方式。如果您试图检出的分支满足(a)名称不存在(b)有且仅有一个远程分支名称和它完全匹配，Git将为您创建跟踪分支： $ git checkout serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch &#39;serverfix&#39; 如果想要将本地分支与远程分支设置为不同名字，你可以轻松地使用原始版本的命令增加一个不同名字的本地分支： $ git checkout -b sf origin&#x2F;serverfixBranch sf set up to track remote branch serverfix from origin.Switched to a new branch &#39;sf&#39; 现在，本地分支sf会自动从origin/serverfix拉取。 设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用-u或--set-upstream-to选项运行git branch来显式地设置。 $ git branch -u origin&#x2F;serverfixBranch serverfix set up to track remote branch serverfix from origin. 注意：上游快捷方式当设置好跟踪分支后，可以通过@{upstream}或@{u}快捷方式来引用它。所以在master分支时并且它正在跟踪origin/master时，如果愿意的话可以使用git merge @{u}来取代git merge origin/master。 如果想要查看设置的所有跟踪分支，可以使用git branch的-vv选项。这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。 $ git branch -vv iss53 7e424c3 [origin&#x2F;iss53: ahead 2] forgot the brackets master 1ae2a45 [origin&#x2F;master] deploying index fix* serverfix f8674d9 [teamone&#x2F;server-fix-good: ahead 3, behind 1] this should do it testing 5ea463a trying something new 这里可以看到iss53分支正在跟踪origin/iss53并且 “ahead” 是2，意味着本地有两个提交还没有推送到服务器上。也能看到master分支正在跟踪origin/master分支并且是最新的。接下来可以看到serverfix分支正在跟踪teamone服务器上的server-fix-good分支并且领先3落后1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。最后看到testing分支并没有跟踪任何远程分支。 需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。可以像这样做： $ git fetch --all; git branch -vv 拉取当git fetch命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。它只会获取数据然后让你自己合并。然而，有一个命令叫作git pull在大多数情况下它的含义是一个git fetch紧接着一个git merge命令。如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过clone或checkout命令为你创建的，git pull都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。 由于git pull的魔法经常令人困惑所以通常单独显式地使用fetch与merge命令会更好一些。 删除远程分支假设你已经通过远程分支做完所有的工作了，也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的master分支（或任何其他稳定代码分支）。可以运行带有--delete选项的git push命令来删除一个远程分支。例如想要从服务器上删除serverfix分支，运行下面的命令： $ git push origin --delete serverfixTo https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit - [deleted] serverfix 基本上这个命令做的只是从服务器上移除这个指针。Git服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。 变基在Git中整合来自不同分支的修改主要有两种方法：merge以及rebase。在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。 变基的基本操作考虑之前遇到的情况，开发任务分叉到了两个不同分支，又各自提交了更新。 图10：分叉的提交历史 之前介绍过，整合分支最容易的方法是merge命令。它会把两个分支的最新快照（C3和C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交），如下图所示： 图11：通过合并操作来整合分叉了的历史 其实，还有一种方法：你可以提取在C4中引入的补丁和修改，然后在C3的基础上应用一次。在Git中，这种操作就叫做 变基。 你可以使用rebase命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。 在上面这个例子中，运行： $ git checkout experiment$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged command 它的原理是首先找到这两个分支（即当前分支experiment、变基操作的目标基底分支master）的最近共同祖先C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底C3，最后以此将之前另存为临时文件的修改依序应用。 图12：将C4中的修改变基到C3上 现在回到master分支，进行一次快进合并。 $ git checkout master$ git merge experiment 图13：master分支的快进合并 此时，C4&#39;指向的快照就和上面使用merge命令的例子中C5指向的快照一模一样了。这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。 一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁，例如向某个其他人维护的项目贡献代码时。在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到origin/master上，然后再向主项目提交修改。这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。 请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 更有趣的变基例子在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像下图的例子： 图14：从一个特性分支里再分出一个特性分支的提交历史 你创建了一个特性分支server，为服务端添加了一些功能，提交了C3和C4。然后从C3上创建了特性分支client，为客户端添加了一些功能，提交了C8和C9。最后，你回到server分支，又提交了C10。 假设你希望将client中的修改合并到主分支并发布，但暂时并不想合并server中的修改，因为它们还需要经过更全面的测试。这时，你就可以使用git rebase命令的--onto选项，选中在client分支里但不在server分支里的修改（即C8和C9），将它们在master分支上重放： $ git rebase --onto master server client 以上命令的意思是：“取出client分支，找出处于client分支和server分支的共同祖先之后的修改，然后把它们在master分支上重放一遍”。这理解起来有一点复杂，不过效果非常酷。 图15：截取特性分支上的另一个特性分支，然后变基到其他分支 现在可以快进合并master分支了。 $ git checkout master$ git merge client 图16：快进合并master分支，使之包含来自client分支的修改 接下来你决定将server分支中的修改也整合进来。使用git rebase &lt;basebranch&gt; &lt;topicbranch&gt;命令可以直接将特性分支（即本例中的server）变基到目标分支（即master）上。这样做能省去你先切换到server分支，再对其执行变基命令的多个步骤： $ git rebase master server 这样，server中的代码便被“续”到了master后面，如下图所示： 图17：将server中的修改变基到master上 然后就可以快进合并主分支master了： $ git checkout master$ git merge server 至此，client和server分支中的修改都已经整合到主分支里了，你可以删除这两个分支 $ git branch -d client$ git branch -d server 最终提交历史会变成下图中的样子： 图18：最终的提交历史 变基的风险奇妙的变基也并非完美无缺，要用它得遵守一条准则： 不要对在你的仓库外有副本的分支执行变基。 变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用git rebase命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。 变基 vs. 合并至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。 有一种观点认为，仓库的提交历史即是 记录实际发生过什么。它是针对历史的文档，本身就有价值，不能乱改。从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。如果由合并产生的提交历史是一团糟怎么办？既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。 另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。持这一观点的人会使用rebase及filter-branch等工具来编写故事，怎么方便后来的读者就怎么写。 现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。Git是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。 总结我们已经讲完了Git分支与合并的基础知识。你现在应该能自如地创建并切换至新分支、在不同分支之间切换以及合并本地分支。你现在应该也能通过推送你的分支至共享服务以分享它们、使用共享分支与他人协作以及在共享之前使用变基操作合并你的分支。同时通过这些例子，我们也能真真切切的感受到Git分支模型的强大，说分支模型是Git的杀手锏一点也不为过！ 参考文献 Pro Git Book","categories":[{"name":"Git","slug":"Git","permalink":"http://www.yingzq.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.yingzq.com/tags/Git/"}]},{"title":"Git的杀手锏：分支模型（上）","slug":"git-branching","date":"2019-10-13T04:11:55.000Z","updated":"2020-02-19T17:40:13.456Z","comments":true,"path":"2019/10/13/git-branching/","link":"","permalink":"http://www.yingzq.com/2019/10/13/git-branching/","excerpt":"几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。与许多其它版本控制系统不同，Git鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。理解和精通这一特性，你便会意识到Git是如此的强大而又独特，并且从此真正改变你的开发方式。","text":"几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。与许多其它版本控制系统不同，Git鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。理解和精通这一特性，你便会意识到Git是如此的强大而又独特，并且从此真正改变你的开发方式。 正如文章题目，这也是Git能在众多版本控制系统脱颖而出的“杀手锏” 初识Git分支Git分支简介在 What is Git 中，我们了解到Git保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照，这和其他版本控制系统很是不同，那么为什么Git要这样做呢？ 在进行提交操作时，Git会保存一个提交对象（commit object）。知道了Git保存数据的方式，我们可以很自然的想到该提交对象会包含一个指向暂存内容快照的指针。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象 为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和（使用SHA-1哈希算法），然后会把当前版本的文件快照保存到Git仓库中（Git使用blob对象来保存它们），最终将校验和加入到暂存区域等待提交： $ git add README test.rb LICENSE$ git commit -m &#39;The initial commit of my project&#39; 当使用git commit进行提交操作时，Git会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在Git仓库中这些校验和保存为树对象。随后，Git便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git就可以在需要的时候重现此次保存的快照。 现在，Git仓库中有五个对象：三个blob对象（保存着文件快照）、一个树对象（记录着目录结构和blob对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。 图1：首次提交对象及其树结构 如果做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。 图2：提交对象及其父对象 Git的分支，其实本质上仅仅是指向提交对象的轻量级可移动指针。Git的默认分支名字是master。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的master分支。它会在每次的提交操作中自动向前移动。 Git的master分支并不是一个特殊分支。它就跟其它分支完全没有区别。之所以几乎每一个仓库都有master分支，是因为git init命令默认创建它，并且大多数人都懒得去改动它。 图3：分支及其提交历史 Git分支创建Git创建新分支很简单，因为Git只是为你创建了一个可以移动的新的指针。例如创建一个testing分支，你需要使用git branch命令： $ git branch testing 这会在当前所在的提交对象上创建一个指针。 图4：两个指向相同提交历史的分支 那么，Git又是怎么知道当前在哪一个分支上呢？也很简单，它有一个名为HEAD的特殊指针。请注意它和许多其它版本控制系统（如Subversion或CVS）里的HEAD概念完全不同。在Git中，它是一个指针，指向当前所在的本地分支。在本例中，你仍然在master分支上。 因为git branch命令仅仅创建一个新分支，并不会自动切换到新分支中去。 图5：HEAD指向当前所在的分支 你可以简单地使用git log命令查看各个分支当前所指的对象。提供这一功能的参数是--decorate。 $ git log --oneline --decoratef30ab (HEAD -&gt; master, testing) add feature #32 - ability to add new34ac2 fixed bug #1328 - stack overflow under certain conditions98ca9 initial commit of my project 可以看到，当前 “master” 和 “testing” 分支均指向校验和以f30ab开头的提交对象。 Git分支切换要切换到一个已存在的分支，你需要使用git checkout命令。我们现在切换到新创建的testing分支去： $ git checkout testing 这样HEAD就指向testing分支了。 图6：HEAD指向当前所在的分支 那么，这样的实现方式会给我们带来什么好处呢？现在不妨再提交一次： $ vim test.rb$ git commit -a -m &#39;made a change&#39; 图7：HEAD分支随着提交操作自动向前移动 这就有意思了，你的testing分支向前移动了，但是master分支却没有，它仍然指向运行git checkout时所指的对象。现在我们切换回 master 分支看看： $ git checkout master 图8：检出时HEAD随之移动 这条命令做了两件事。一是使HEAD指回master分支，二是将工作目录恢复成master分支所指向的快照内容。也就是说，你现在做修改的话，项目将始于一个较旧的版本。本质上来讲，这就是忽略testing分支所做的修改，以便于向另一个方向进行开发。 注意：分支切换会改变你工作目录中的文件在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果Git不能干净利落地完成这个任务，它将禁止切换分支。 我们不妨再稍微做些修改并提交： $ vim test.rb$ git commit -a -m &#39;made other changes&#39; 现在，这个项目的提交历史已经产生了分叉。因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回master分支进行了另外一些工作。上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。而所有这些工作，你需要的命令只有branch、checkout和commit。 图9：项目分叉历史 你可以简单地使用git log命令查看分叉历史。运行git log --oneline --decorate --graph --all，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。 $ git log --oneline --decorate --graph --all* c2b9e (HEAD -&gt; master) made other changes| * 87ab2 (testing) made a change|&#x2F;* f30ab add feature #32 - ability to add new formats to the* 34ac2 fixed bug #1328 - stack overflow under certain conditions* 98ca9 initial commit of my project 由于Git的分支实质上仅是包含所指对象校验和（长度为40的SHA-1值字符串）的文件，所以它的创建和销毁都异常高效。创建一个新分支就相当于往一个文件中写入41个字节（40个字符和1个换行符），如此的简单能不快吗？ 这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在Git中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（即共同祖先）也是同样的简单和高效。这些高效的特性使得Git鼓励开发人员频繁地创建和使用分支。 接下来，让我们看看你为什么应该这样做。 注意：Git可以创建分支并同时切换到该分支创建一个分支并希望同时切换到该分支是很常见的，这可以通过git checkout -b &lt;newbranchname&gt;一条命令即可完成！ Git分支新建与合并让我们来看一个简单的Git分支新建与合并的例子，实际工作中你可能会用到类似的工作流。你将经历如下步骤： 开发某个网站。 为实现某个新的需求，创建一个分支。 在这个分支上开展工作。 正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。你将按照如下方式来处理： 切换到你的线上分支（production branch）。 为这个紧急任务新建一个分支，并在其中修复它。 在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。 切换回你最初工作的分支上，继续工作。 分支新建首先，我们假设你正在你的项目上工作，并且已经有一些提交。 图10：一个简单提交历史 现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。想要新建一个分支并同时切换到那个分支上，你可以运行一个带有-b参数的git checkou命令： $ git checkout -b iss53Switched to a new branch &quot;iss53&quot; 它是下面两条命令的简写： $ git branch iss53$ git checkout iss53 图11：创建一个新分支指针 你继续在 #53 问题上工作，并且做了一些提交。在此过程中，iss53分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的HEAD指针指向了iss53分支） $ vim index.html$ git commit -a -m &#39;added a new footer [issue 53]&#39; 图12：iss53分支随着工作的进展向前推进 现在你接到那个电话，有个紧急问题等待你来解决。有了Git的帮助，你不必把这个紧急问题和iss53的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。你所要做的仅仅是切换回master分支！ 但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止Git切换到该分支。最好的方法是，在你切换分支之前，保持好一个干净的状态。有一些方法可以绕过这个问题，即保存进度（stashing）和修补提交（commit amending）。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回master分支了： $ git checkout masterSwitched to branch &#39;master&#39; 这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。请牢记：当你切换分支的时候，Git会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。Git会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。 接下来，你要修复这个紧急问题。让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决： $ git checkout -b hotfixSwitched to a new branch &#39;hotfix&#39;$ vim index.html$ git commit -a -m &#39;fixed the broken email address&#39;[hotfix 1fb7853] fixed the broken email address 1 file changed, 2 insertions(+) 图13：基于master分支的紧急问题分支hotfix branch 你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的master分支来部署到线上。你可以使用git merge命令来达到上述目的： $ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) 在合并的时候，你应该注意到了“快进（fast-forward）”这个词。由于当前master分支所指向的提交是你当前提交（有关hotfix的提交）的直接上游，所以Git只是简单的将指针向前移动。换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么Git在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做“快进（fast-forward）”。 图14：master被快进到hotfix 关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。然而，你应该先删除hotfix分支，因为master分支已经指向了同一个位置，所以你已经不再需要它了。你可以使用带-d选项的git branch命令来删除分支： $ git branch -d hotfixDeleted branch hotfix (3a0874c). 现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53分支）。 $ git checkout iss53Switched to branch &quot;iss53&quot;$ vim index.html$ git commit -a -m &#39;finished the new footer [issue 53]&#39;[iss53 ad82d7a] finished the new footer [issue 53]1 file changed, 1 insertion(+) 图15：继续在iss53分支上的工作 注意到你在hotfix分支上所做的工作并没有包含到iss53分支中。如果你需要拉取hotfix所做的修改，你可以使用git merge master命令将master分支合并入iss53分支，或者你也可以等到iss53分支完成其使命，再将其合并回master分支。 分支合并假设你已经修正了 #53 问题，并且打算将你的工作合并入master分支。为此，你需要合并iss53分支到master分支，这和之前你合并hotfix分支所做的工作差不多。你只需要检出到你想合并入的分支，然后运行git merge命令： $ git checkout masterSwitched to branch &#39;master&#39;$ git merge iss53Merge made by the &#39;recursive&#39; strategy.index.html | 1 +1 file changed, 1 insertion(+) 这和你之前合并hotfix分支的时候看起来有一点不一样。在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。因为master分支所在提交并不是iss53分支所在提交的直接祖先，Git不得不做一些额外的工作。出现这种情况的时候，Git会使用两个分支的末端所指的快照（C4和C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。 图16：一次典型合并中所用到的三个快照 和之前将分支指针向前推进所不同的是，Git将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。 图17：一个合并提交 需要指出的是，Git会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的CVS系统或者Subversion（1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。Git的这个优势使其在合并操作上比其他系统要简单很多。 既然你的修改已经合并进来了，你已经不再需要iss53分支了。现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。 $ git branch -d iss53 遇到冲突时的分支合并有时候合并操作不会如此顺利。如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git就没法干净的合并它们。如果你对 #53 问题的修改和有关hotfix的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突： $ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result. 此时Git做了合并，但是没有自动地创建一个新的合并提交。Git会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用git status命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件： $ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: index.htmlno changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;) 任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。Git会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。出现冲突的文件会包含一些特殊区段，看起来像下面这个样子： &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id&#x3D;&quot;footer&quot;&gt;contact : email.support@github.com&lt;&#x2F;div&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;div id&#x3D;&quot;footer&quot;&gt; please contact us at support@github.com&lt;&#x2F;div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html 这表示HEAD所指示的版本（也就是你的master分支所在的位置，因为你在运行merge命令的时候已经检出到了这个分支）在这个区段的上半部分（=======的上半部分），而iss53分支所指示的版本在=======的下半部分。为了解决冲突，你必须选择使用由=======分割的两部分中的一个，或者你也可以自行合并这些内容。例如，你可以通过把这段内容换成下面的样子来解决冲突： &lt;div id&#x3D;&quot;footer&quot;&gt;please contact us at email.support@github.com&lt;&#x2F;div&gt; 上述的冲突解决方案仅保留了其中一个分支的修改，并且&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======和&gt;&gt;&gt;&gt;&gt;&gt;&gt;这些行被完全删除了。在你解决了所有文件里的冲突之后，对每个文件使用git add命令来将其标记为冲突已解决。一旦暂存这些原本有冲突的文件，Git就会将它们标记为冲突已解决。 如果你想使用图形化工具来解决冲突，你可以运行git mergetool，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突： $ git mergetoolThis message is displayed because &#39;merge.tool&#39; is not configured.See &#39;git mergetool --tool-help&#39; or &#39;git help config&#39; for more details.&#39;git mergetool&#39; will now attempt to use one of the following tools:tortoisemerge emerge vimdiffMerging:READMENormal merge conflict for &#39;README&#39;: &#123;local&#125;: modified file &#123;remote&#125;: modified fileHit return to start merge resolution tool (vimdiff): 如果你想使用除默认工具（在这里Git使用vimdiff做为默认的合并工具）外的其他合并工具，你可以在“下列工具中（one of the following tools）”这句后面看到所有支持的合并工具。然后输入你喜欢的工具名字就可以了。 如果你需要更加高级的工具来解决复杂的合并冲突，可以参考 Git Tools - Advanced Merging 等你退出合并工具之后，Git会询问刚才的合并是否成功。如果你回答是，Git会暂存那些文件以表明冲突已解决：你可以再次运行git status来确认所有的合并冲突都已被解决： $ git statusOn branch masterAll conflicts fixed but you are still merging. (use &quot;git commit&quot; to conclude merge)Changes to be committed: modified: index.html 如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入git commit来完成合并提交。默认情况下提交信息看起来像下面这个样子： Merge branch &#39;iss53&#39;Conflicts: index.html## It looks like you may be committing a merge.# If this is not correct, please remove the file# .git&#x2F;MERGE_HEAD# and try again.# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.# On branch master# All conflicts fixed but you are still merging.## Changes to be committed:# modified: index.html# 如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。 Git分支管理现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。 git branch命令不只是可以创建与删除分支。如果不加任何参数运行它，会得到当前所有分支的一个列表： $ git branch iss53* master testing 注意master分支前的*字符：它代表现在检出的那一个分支（也就是说，当前HEAD指针所指向的分支）。这意味着如果在这时候提交，master分支将会随着新的工作向前移动。如果需要查看每一个分支的最后一次提交，可以运行git branch -v命令： $ git branch -v iss53 93b412c fix javascript issue* master 7a98805 Merge branch &#39;iss53&#39; testing 782fd34 add scott to the author list in the readmes --merged与--no-merged这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。如果要查看哪些分支已经合并到当前分支，可以运行git branch --merged： $ git branch --merged iss53* master 因为之前已经合并了iss53分支，所以现在看到它在列表中。在这个列表中分支名字前没有*号的分支通常可以使用git branch -d删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。 查看所有包含未合并工作的分支，可以运行git branch --no-merged： $ git branch --no-merged testing 这里显示了其他分支。因为它包含了还未合并的工作，尝试使用git branch -d命令删除它时会失败： $ git branch -d testingerror: The branch &#39;testing&#39; is not fully merged.If you are sure you want to delete it, run &#39;git branch -D testing&#39;. 如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用-D选项强制删除它。 总结到这里我们已经初步了解了Git分支的基本原理和优良特征，同时也学会了Git分支新建和合并的基本操作，难以置信的轻量分支模型也正是Git在众多版本控制系统中脱颖而出的杀手锏！ 但是至此关于Git分支的内容还未结束，我们还没充分了解到Git分支的工作流、Git远程分支等内容，限于篇幅将在 Git的杀手锏：分支模型（下）继续讲解。 参考文献 Pro Git Book","categories":[{"name":"Git","slug":"Git","permalink":"http://www.yingzq.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.yingzq.com/tags/Git/"}]},{"title":"请务必掌握的Git基础","slug":"git-basics","date":"2019-10-01T05:03:38.000Z","updated":"2020-02-19T17:40:18.378Z","comments":true,"path":"2019/10/01/git-basics/","link":"","permalink":"http://www.yingzq.com/2019/10/01/git-basics/","excerpt":"Git是目前最流行的分布式版本控制系统，值得我们去学会使用并深入了解。本文将会介绍几个最基本的，也是最常用的命令，以后绝大多数时间里用到的可能也就是这几个命令，主要涉及Git的配置、Git仓库的获取、如何记录每次更新到Git仓库、提交历史的查看、Git的撤销操作、Git标签和Git别名等基础知识点，这些是你务必掌握的Git基础！","text":"Git是目前最流行的分布式版本控制系统，值得我们去学会使用并深入了解。本文将会介绍几个最基本的，也是最常用的命令，以后绝大多数时间里用到的可能也就是这几个命令，主要涉及Git的配置、Git仓库的获取、如何记录每次更新到Git仓库、提交历史的查看、Git的撤销操作、Git标签和Git别名等基础知识点，这些是你务必掌握的Git基础！ 前奏在开始阅读前，有几个需要注意的点： 如果你没听说过Git或者还不了解Git是什么，请参阅文章 What is Git 。 Git有多种使用方式，包括原生的和GUI模式，在这里推荐先使用并熟悉命令行模式，因为如果你学会了在命令行下如何操作，那么你在操作GUI软件时应该也不会遇到什么困难，但是，反之则不成立。 Git的安装在不同平台上Git安装的方式有一定差异，在这里不详细介绍。值得注意的是，虽然Git具有很好的向后兼容性，但是还是建议大家最好将它升级到最新的版本。 例如在Ubuntu系统中，可通过如下指令来安装最新稳定版本的Git： $ sudo apt-get install git 在mac系统中则可通过Homebrew来安装最新版本的Git： $ brew install git 更多的安装指导可查看 Installing Git 和 官方下载界面 。 安装完成后，输入指令git --version，返回正常的版本信息则证明已成功安装Git： $ git --versiongit version 2.21.0 注：因为Git的安装是非常方便快捷的，官网也有清晰的指导，所以这一章节讲的非常简略。 初次使用Git前的配置在第一次使用一个新编辑器的时候，你会倾向于把字体大小、界面还有需要的插件等统一配置一下，这样在你以后使用这个编辑器的时候，编辑器便会默认载入这些配置，非常的方便。 Git中也有类似的机制。Git自带一个git config的工具来帮助设置控制Git外观和行为的配置变量，这些变量存储在三个不同的位置： etc/gitconfig文件: 包含系统上每一个用户及他们仓库的通用配置。如果使用带有--system选项的git config时，它会从此文件读写配置变量。 ~/.gitconfig或~/.config/git/config文件：只针对当前用户。可以传递--global选项让Git读写此文件。 当前使用仓库的Git目录中的config文件（也就是.git/config）：针对该仓库。可以传递--local选项让Git读写此文件，但是其实这个选项是默认的，因此可以省略。 每一个级别覆盖上一级别的配置，例如.git/config的配置变量会覆盖/etc/gitconfig中的配置变量。 在Windows系统中，Git会查找$HOME目录下（一般情况下是 C:\\Users\\$USER）的.gitconfig文件。Git同样也会寻找/etc/gitconfig文件，但只限于MSys的根目录下，即安装Git时所选的目标位置。 用户信息首先你需要设置自己的用户名称和邮箱，这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改（换句话说，不设置用户信息无法进行git commit操作）： $ git config --global user.name &quot;YingZiqiang&quot;$ git config --global user.email yingzq0116@163.com 再次强调，如果使用了--global选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有--global选项的命令来配置。 文本编辑器当Git需要你输入信息时会调用默认的文本编辑器。如果未配置，Git会使用操作系统默认的文本编辑器，通常是Vim。如果你想使用不同的文本编辑器，例如Emacs，可以这样做： $ git config --global core.editor emacs 检查配置信息如果想要检查你的配置，可以使用git config --list命令来列出所有Git当时能找到的配置。 $ git config --listuser.name&#x3D;YingZiqianguser.email&#x3D;88629850@qq.compush.default&#x3D;simple... 有时候会看到重复的变量名，因为Git可能会从多个配置文件中读取同一个配置变量。这种情况下，Git会使用它找到的每一个变量的最后一个配置。 可以通过输入git config &lt;key&gt;来检查Git的某一项配置： $ git config user.nameYingZiqiang 如果你想确认某配置变量的最终决定权的来源，可以输入git config --show-origin &lt;key&gt;查询： $ git config --show-origin user.namefile:&#x2F;Users&#x2F;yingzq&#x2F;.gitconfig YingZiqiang Git帮助若你使用Git时需要获取帮助，有三种方法可以找到Git命令的使用手册： $ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; 例如，要想获得config命令的手册，执行 $ git help config 另外，如果你不想查看一个Git命令完整的使用手册，仅仅是想要快速查看某些参数的用法，可以通过-h选项来获得一个更加简洁的帮助界面，例如查看git add命令的参数信息： $ git add -h 注：你可以随时随地可以使用这些命令而无需联网 获取Git仓库有两种取得Git项目仓库的方法。第一种是在现有项目或目录下导入所有文件到Git中；第二种是从一个服务器克隆一个现有的Git仓库。 在现有目录中初始化仓库如果你打算使用Git来对现有的项目进行管理，你只需要进入该项目目录并输入： $ git init 该命令将创建一个名为.git的子目录，这个子目录含有你初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化Git仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。你可通过git add命令来实现对指定文件的跟踪，然后执行git commit提交： $ git add *.py$ git add LICENSE$ git commit -m &#39;initial project version&#39; 稍后会逐一解释每一条指令的意思。现在，你已经得到了一个实际维护（或者说是跟踪）着若干个文件的Git仓库。 克隆现有的仓库如果你想获得一份已经存在了的Git仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到git clone命令。 克隆仓库的命令格式是git clone [url]。比如，要克隆一个叫“TensorFlow-Examples”的库，可以用下面的命令： $ git clone https:&#x2F;&#x2F;github.com&#x2F;aymericdamien&#x2F;TensorFlow-Examples 这会在当前目录下创建一个名为“TensorFlow-Examples”的目录，并在这个目录下初始化一个.git文件夹，并从远程仓库拉取下所有数据放入.git文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的“TensorFlow-Examples”文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令： $ git clone https:&#x2F;&#x2F;github.com&#x2F;aymericdamien&#x2F;TensorFlow-Examples my-tf-examples 这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为“my-tf-examples”。 Git支持多种数据传输协议。上面的例子使用的是https://协议，不过你也可以使用git://协议或者使用例如user@server:path/to/repo.git的SSH传输协议。 注：Git克隆的是该Git仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。当你执行git clone命令的时候，默认配置下远程Git仓库中的每一个文件的每一个版本都将被拉取下来。 记录每次更新到仓库现在我们手上有了一个真实项目的Git仓库，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。 工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。 图1：文件的状态变化周期 检查当前文件状态要查看哪些文件处于什么状态，可以用git status命令。如果在克隆仓库后立即使用此命令，会看到类似这样的输出： $ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.nothing to commit, working tree clean 这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则Git会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。现在，分支名是“master”，这是默认的分支名。在这里不用担心不明白分支是什么，这一部分会在 Git的杀手锏：分支模型（上） 单独讲解。 如果在项目中创建一个新的README文件，如果之前并不存在这个文件，使用git status命令，你将看到一个新的未跟踪文件： $ echo &#39;My Project&#39; &gt; README$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) READMEnothing added to commit but untracked files present (use &quot;git add&quot; to track) 在状态报告中可以看到新建的README文件出现在“Untracked files”下面。未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。不过现在的例子中，我们确实想要跟踪管理README这个文件。 跟踪新文件使用命令git add开始跟踪一个文件。所以如果要跟踪README文件，运行： $ git add README 此时再运行git status命令，会看到README文件已被跟踪，并处于暂存状态： $ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README 只要在“Changes to be committed”这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用git init后就运行了git add &lt;files&gt;命令，开始跟踪当前目录下的文件。git add命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 暂存已修改文件现在我们来修改一个已被跟踪的文件。如果你修改了一个名为TINY.md的已被跟踪的文件，然后运行git status命令，会看到下面内容： $ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.md 文件TINY.md出现在“Changes not staged for commit”这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行git add命令。git add是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行git add将TINY.md放到暂存区，然后再看看git status的输出： $ git add TINY.md$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: TINY.md 现在两个文件都已暂存，下次提交时就会一并记录到仓库。 这里再追加一个小问题，假设此时，你的TINY.md文件存在一些小瑕疵，于是你重新编辑该文件并存盘了，此时运行git status会发生什么呢？ $ vim TINY.md$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: TINY.mdChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.md 怎么回事？现在TINY.md文件同时出现在暂存区和非暂存区。这怎么可能呢？实际上Git只不过暂存了你运行git add命令时的版本，如果你现在提交，TINY.md的版本是你最后一次运行git add命令时的那个版本，而不是你运行git commit时，在工作目录中的当前版本。 所以，运行了git add之后又作了修订的文件，需要重新运行git add把最新版本重新暂存起来： $ git add TINY.md$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: TINY.md 状态简览git status命令的输出十分详细，但其用语有些繁琐。如果你使用git status -s命令或git status --short命令，你将得到一种更为紧凑的格式输出。运行git status -s，状态报告输出如下： $ git status -sA READMEM TINY.md 新添加的未跟踪文件前面有??标记，新添加到暂存区中的文件前面有A标记，修改过的文件前面有M标记。其中M有两个可以出现的位置，出现在右边的M表示该文件被修改了但是还没放入暂存区，出现在靠左边的M表示该文件被修改了并放入了暂存区。 忽略文件一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为.gitignore的文件，列出要忽略的文件模式。来看一个实际的例子： $ cat .gitignore*.[oa]*~ 第一行告诉Git忽略所有以“.o”或“.a”结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。第二行告诉Git忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略log，tmp或者pid目录，以及自动生成的文档等等。要养成一开始就设置好.gitignore文件的习惯，以免将来误提交这类无用的文件。 文件.gitignore的格式规范如下： 所有空行或者以#开头的行都会被Git忽略。 可以使用标准的glob模式匹配，并且会在整个工作目录中递归的应用。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上感叹号（!）取反。 所谓的glob模式是指所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个a，要么匹配一个b，要么匹配一个c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9]表示匹配所有0到9的数字）。使用两个星号表示匹配任意中间目录，比如a/**/z可以匹配a/z,a/b/z或a/b/c/z等。 我们再看一个.gitignore文件的例子： # no .a files *.a # but do track lib.a, even though you&apos;re ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in the build/ directory build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory doc/**/*.pdf GitHub有一个十分详细的针对数十种项目及语言的.gitignore文件列表，你可以在 https://github.com/github/gitignore 找到它。 查看已暂存和未暂存的修改如果git status命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用git diff命令。 你可能通常会用git diff命令来回答这两个问题：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？尽管git status已经通过在相应栏下列出文件名的方式回答了这个问题，git diff将通过文件补丁的格式显示具体哪些行发生了改变。 假如此时你再次编辑TINY.md后不暂存，运行git status会看到： $ git statusYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: README modified: TINY.mdChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.md 要查看尚未暂存的文件更新了哪些部分，不加参数直接输入git diff，此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容： $ git diffdiff --git a&#x2F;TINY.md b&#x2F;TINY.mdindex 5818529..f0bfc69 100644--- a&#x2F;TINY.md+++ b&#x2F;TINY.md@@ -1,3 +1,3 @@ tiny data modify this file, we add one new line-fix something+add one line for test 若要查看已暂存的将要添加到下次提交里的内容，可以用git diff --cached命令（Git 1.6.1及更高版本还允许使用git diff --staged，效果是相同的，但更好记些），此命令是将目前已暂存的更改和上次提交的内容进行比较： $ git diff --stageddiff --git a&#x2F;README b&#x2F;READMEnew file mode 100644index 0000000..e69de29diff --git a&#x2F;TINY.md b&#x2F;TINY.mdindex f8f5ae1..5818529 100644--- a&#x2F;TINY.md+++ b&#x2F;TINY.md@@ -1 +1,3 @@ tiny data+modify this file, we add one new line+fix something 请注意，git diff本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。所以有时候你一下子暂存了所有更新过的文件后，运行git diff后却什么也没有，就是这个原因。 提交更新当你的暂存区域已经准备妥当便可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有git add过，否则提交的时候不会记录这些还没暂存起来的变化。这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用git status看下，是不是都已暂存起来了，然后再运行提交命令git commit： $ git commit 这种方式会启动默认的文本编辑器以便输入本次提交的说明，需要注意的是，如果输入的提交说明为空你的本次提交将会被中止。 更常用的方式是在commit命令后添加-m选项，将提交信息与命令放在同一行，如下所示： $ git commit -m &#39;add README file and fix some bugs in TINY.md&#39;[master 10114de] add README file and fix some bugs in TINY.md 2 files changed, 2 insertions(+) create mode 100644 README 现在你已经创建了第一个提交！可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整SHA-1校验和是什么（10114de），以及在本次提交中，有多少文件修订过，多少行添加和删改过。 请记住，提交时记录的是放在暂存区域的快照。任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给git commit加上-a选项，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add步骤： $ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.mdno changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)$ git commit -a -m &#39;test the commit -a option&#39;[master 45f06e1] test the commit -a option 1 file changed, 1 insertion(+), 1 deletion(-) 可以看到，提交之前不再需要git add文件TINY.md了。 移除文件要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用git rm命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 如果只是简单地从工作目录中手工删除文件，运行git status时就会在“Changes not staged for commit”部分（也就是未暂存清单）看到： $ rm TINY.md$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes not staged for commit: (use &quot;git add&#x2F;rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: TINY.mdno changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;) 然后再运行git rm记录此次移除文件的操作： $ git rm TINY.md$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: TINY.md 下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项-f（即force的首字母）。这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被Git恢复。 另外一种情况是，我们想把文件从暂存区域移除，但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，但是并不想让Git继续跟踪。当你忘记添加.gitignore文件，不小心把一个很大的日志文件或一堆.a这样的编译生成文件添加到暂存区时，这一做法尤其有用。为达到这一目的，使用--cached选项： $ git rm --cached README git rm命令后面可以列出文件或者目录的名字，也可以使用glob模式。例如： $ git rm log&#x2F;\\*.log 注意到星号*之前的反斜杠\\，这是非常有必要的，因为除了拥有shell的文件模式扩展匹配方式，Git还有它自己的文件模式扩展匹配方式。 此命令会删除log/目录及其子目录下扩展名为.log的所有文件。 移动文件不像其它的VCS系统，Git并不显式跟踪文件移动操作。如果在Git中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过Git非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，可以放到以后再详细了解。 要在Git中对文件改名，可以这么做： $ git mv file_from file_to 此时查看状态信息，可以明白无误地看到关于重命名操作的说明： $ git mv TINY.md MY-TOY.md$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) renamed: TINY.md -&gt; MY-TOY.md 其实，运行git mv就相当于运行了下面三条命令： $ mv TINY.md MY-TOY.md$ git rm TINY.md$ git add MY-TOY.md 如此分开操作，Git也会意识到这是一次改名，所以不管何种方式结果都一样，但是git mv一个命令代替了第二种方式的三个命令，更加的轻便。更进一步，你可以使用任何你熟悉的工具来重命名文件，然后只需要记得在提交前，删除老的文件名并添加新的文件名。 查看提交历史在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。完成这个任务最简单而又有效的工具是git log命令。 首先运行下面的命令获取用于演示的simplegit项目的源代码： $ git clone https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit-progit 然后在此项目中运行git log，应该会看到下面的输出： $ git logcommit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the verison numbercommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test codecommit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Sat Mar 15 10:31:28 2008 -0700 first commit 默认不用任何参数的话，git log会按提交时间列出所有的更新，最近的更新排在最上面。正如你所看到的，这个命令会列出每个提交的SHA-1校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 git log有许多选项可以帮助你搜寻你所要找的提交， 接下来我们先来了解一些最常用的选项。 一个常用的选项是-p或者说是--patch，用来显示每次提交的内容差异（the patch output）。你也可以限制展示的提交条目数，例如可以加上-2来仅显示最近两次提交： $ git log -p -2commit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the verison numberdiff --git a&#x2F;Rakefile b&#x2F;Rakefileindex a874b73..8f94139 100644--- a&#x2F;Rakefile+++ b&#x2F;Rakefile@@ -5,7 +5,7 @@ require &#39;rake&#x2F;gempackagetask&#39; spec &#x3D; Gem::Specification.new do |s| s.platform &#x3D; Gem::Platform::RUBY s.name &#x3D; &quot;simplegit&quot;- s.version &#x3D; &quot;0.1.0&quot;+ s.version &#x3D; &quot;0.1.1&quot; s.author &#x3D; &quot;Scott Chacon&quot; s.email &#x3D; &quot;schacon@gmail.com&quot; s.summary &#x3D; &quot;A simple gem for using Git in Ruby code.&quot;commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test codediff --git a&#x2F;lib&#x2F;simplegit.rb b&#x2F;lib&#x2F;simplegit.rbindex a0a60ae..47c6340 100644--- a&#x2F;lib&#x2F;simplegit.rb+++ b&#x2F;lib&#x2F;simplegit.rb@@ -18,8 +18,3 @@ class SimpleGit end end--if $0 &#x3D;&#x3D; __FILE__- git &#x3D; SimpleGit.new- puts git.show-end\\ No newline at end of file 该选项除了显示基本信息之外，还附带了每次commit的变化。当进行代码审查，或者快速浏览某个搭档提交的commit所带来的变化的时候，这个参数就非常有用了。你也可以为git log附带一系列的总结性选项。比如说，如果你想看到每次提交的简略的统计信息，你可以使用--stat选项： $ git log --statcommit ca82a6dff817ec66f44342007202690a93763949 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the verison number Rakefile | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test code lib&#x2F;simplegit.rb | 5 ----- 1 file changed, 5 deletions(-)commit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &lt;schacon@gmail.com&gt;Date: Sat Mar 15 10:31:28 2008 -0700 first commit README | 6 ++++++ Rakefile | 23 +++++++++++++++++++++++ lib&#x2F;simplegit.rb | 25 +++++++++++++++++++++++++ 3 files changed, 54 insertions(+) 正如你所看到的，--stat选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。在每次提交的最后还有一个总结。 另外一个常用的选项是--pretty。这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用。比如用oneline将每个提交放在一行显示，查看的提交数很大时非常有用。 git log还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。例如之前看到的-2其实是-&lt;n&gt;选项的写法，其中的n可以是任何整数，表示仅显示最近的若干条提交；另外还有按照时间作限制的选项，比如--since和--until也很有用，还可以给出若干搜索条件，列出符合的提交… git log的选项非常多，在这里不再一一介绍。总之，git log是一个功能非常齐全、可定制化程度非常高的、能满足你几乎所有查询方式的查看提交历史的命令。 撤消操作在任何一个阶段，你都有可能想要撤消某些操作。这里，我们将会学习几个撤消你所做修改的基本工具。注意，有些撤消操作是不可逆的，这是在使用Git的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有--amend选项的提交命令尝试重新提交： $ git commit --amend 这个命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。 运行该命令后会启动文本编辑器，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。 例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作： $ git commit -m &#39;initial commit&#39;$ git add forgotten_file$ git commit --amend 最终你只会有一个提交——第二次提交将代替第一次提交的结果。 接下来再来学习一下如何操作暂存区域与工作目录中已修改的文件。这些命令在修改文件状态的同时，也会提示如何撤消操作。 取消暂存的文件如果你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了git add *暂存了它们两个。如何只取消暂存两个中的一个呢？git status命令提示了你： $ git add *$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: README modified: TINY.md 在“Changes to be committed”文字正下方，提示使用git reset HEAD &lt;file&gt;...来取消暂存。所以，我们可以这样来取消暂存TINY.md文件： $ git reset HEAD TINY.mdOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.md 可以看到TINY.md文件已经是修改未暂存的状态了。 撤消对文件的修改如果你并不想保留对TINY.md文件的修改怎么办？你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？幸运的是，git status也告诉了你应该如何做。在最后一个例子中，未暂存区域是这样： Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TINY.md 它非常清楚地告诉了你如何撤消之前所做的修改。让我们来按照提示执行： $ git checkout -- TINY.md$ git statusOn branch masterYour branch is up to date with &#39;origin&#x2F;master&#39;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: README 可以看到关于TINY.md的修改已经被撤消了。 请记住，在Git中任何已提交的东西几乎总是可以恢复的。甚至那些被删除的分支中的提交或使用--amend选项覆盖的提交也可以恢复。然而，任何你未提交的东西丢失后很可能再也找不到了。 远程仓库的使用为了能在任意Git项目上协作，你需要知道如何管理自己的远程仓库。远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。在本章节中，将介绍一部分基础的远程管理技能。 查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行git remote命令。它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到origin，这是Git给你克隆的仓库服务器的默认名字 $ git clone https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgitCloning into &#39;ticgit&#39;...remote: Enumerating objects: 1857, done.remote: Total 1857 (delta 0), reused 0 (delta 0), pack-reused 1857Receiving objects: 100% (1857&#x2F;1857), 334.04 KiB | 36.00 KiB&#x2F;s, done.Resolving deltas: 100% (837&#x2F;837), done.$ cd ticgit$ git remoteorigin 你也可以指定选项-v，会显示需要读写远程仓库使用的Git保存的简写与其对应的URL。 $ git remote -vorigin https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (fetch)origin https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (push) 如果你的远程仓库不止一个，该命令会将它们全部列出。例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样： $ cd grit$ git remote -vbakkdoor https:&#x2F;&#x2F;github.com&#x2F;bakkdoor&#x2F;grit (fetch)bakkdoor https:&#x2F;&#x2F;github.com&#x2F;bakkdoor&#x2F;grit (push)cho45 https:&#x2F;&#x2F;github.com&#x2F;cho45&#x2F;grit (fetch)cho45 https:&#x2F;&#x2F;github.com&#x2F;cho45&#x2F;grit (push)defunkt https:&#x2F;&#x2F;github.com&#x2F;defunkt&#x2F;grit (fetch)defunkt https:&#x2F;&#x2F;github.com&#x2F;defunkt&#x2F;grit (push)koke git:&#x2F;&#x2F;github.com&#x2F;koke&#x2F;grit.git (fetch)koke git:&#x2F;&#x2F;github.com&#x2F;koke&#x2F;grit.git (push)origin git@github.com:mojombo&#x2F;grit.git (fetch)origin git@github.com:mojombo&#x2F;grit.git (push) 这样我们可以轻松拉取其中任何一个用户的贡献。此外，我们有可能还会有某些远程仓库的推送权限，不过暂时不在此介绍。 添加远程仓库运行git remote add &lt;shortname&gt; &lt;url&gt;添加一个新的远程Git仓库，同时指定一个你可以轻松引用的简写： $ git remoteorigin$ git remote add pb https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit$ git remote -vorigin https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (fetch)origin https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit (push)pb https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit (fetch)pb https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit (push) 现在你可以在命令行中使用字符串pb来代替整个URL。例如，如果你想拉取Paul的仓库中有但你没有的信息，可以运行git fetch pb： $ git fetch pbremote: Enumerating objects: 22, done.remote: Counting objects: 100% (22&#x2F;22), done.remote: Total 43 (delta 22), reused 22 (delta 22), pack-reused 21Unpacking objects: 100% (43&#x2F;43), done.From https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit * [new branch] master -&gt; pb&#x2F;master * [new branch] ticgit -&gt; pb&#x2F;ticgit 现在Paul的master分支可以在本地通过pb/master访问到——你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 关于什么是分支以及如何使用分支将会在 Git的杀手锏：分支模型（上） 中详细介绍 从远程仓库中抓取与拉取就如刚才所见，从远程仓库中获得数据，可以执行： $ git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用clone命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以“origin”为简写。所以，git fetch origin会抓取克隆（或上一次抓取）后新推送的所有工作。必须注意git fetch命令会将数据拉取到你的本地仓库，但是它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 如果你有一个分支设置为跟踪一个远程分支，可以使用git pull命令来自动的抓取然后合并远程分支到当前分支。这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone命令会自动设置本地master分支跟踪克隆的远程仓库的master分支（或不管是什么名字的默认分支）。运行git pull通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程仓库当你想分享你的项目时，必须将其推送到上游。这个命令很简单：git push [remote-name] [branch-name]。当你想要将master分支推送到origin服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器： $ git push origin master 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。阅读 Git的杀手锏：分支模型（上） 了解如何推送到远程仓库服务器的详细信息。 查看某个远程仓库如果想要查看某一个远程仓库的更多信息，可以使用git remote show [remote-name]命令。如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息： $ git remote show origin* remote origin Fetch URL: https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit Push URL: https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit HEAD branch: master Remote branches: master tracked ticgit tracked Local branch configured for &#39;git pull&#39;: master merges with remote master Local ref configured for &#39;git push&#39;: master pushes to master (up to date) 它同样会列出远程仓库的URL与跟踪分支的信息。这些信息非常有用，它告诉你正处于master分支，并且如果运行git pull，就会抓取所有的远程引用，然后将远程master分支合并到本地master分支。它也会列出拉取到的所有远程引用。 这是一个经常遇到的简单例子。如果你是Git的重度使用者，那么还可以通过git remote show看到更多的信息： $ git remote show origin* remote origin URL: https:&#x2F;&#x2F;github.com&#x2F;my-org&#x2F;complex-project Fetch URL: https:&#x2F;&#x2F;github.com&#x2F;my-org&#x2F;complex-project Push URL: https:&#x2F;&#x2F;github.com&#x2F;my-org&#x2F;complex-project HEAD branch: master Remote branches: master tracked dev-branch tracked markdown-strip tracked issue-43 new (next fetch will store in remotes&#x2F;origin) issue-45 new (next fetch will store in remotes&#x2F;origin) refs&#x2F;remotes&#x2F;origin&#x2F;issue-11 stale (use &#39;git remote prune&#39; to remove) Local branches configured for &#39;git pull&#39;: dev-branch merges with remote dev-branch master merges with remote master Local refs configured for &#39;git push&#39;: dev-branch pushes to dev-branch (up to date) markdown-strip pushes to markdown-strip (up to date) master pushes to master (up to date) 这个命令列出了当你在特定的分支上执行git push会自动地推送到哪一个远程分支。它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行git pull时哪些分支会自动合并。 远程仓库的移除与重命名如果想要重命名引用的名字可以运行git remote rename去修改一个远程仓库的简写名。例如，想要将pb重命名为paul，可以用git remote rename这样做： $ git remote rename pb paul$ git remoteoriginpaul 值得注意的是这同样也会修改你的远程分支名字。那些过去引用pb/master的现在会引用paul/master。 如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用git remote rm： $ git remote rm paul$ git remoteorigin 打标签像其他版本控制系统（VCS）一样，Git可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。在本章节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。 列出标签在Git中列出已有的标签是非常简单直观的。只需要输入git tag： $ git tagv0.1v1.3 这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。 你也可以使用特定的模式查找标签。例如，Git自身的源代码仓库包含标签的数量超过500个。如果只对1.8.5系列感兴趣，可以运行： $ git tag -l &#39;v1.8.5*&#39;v1.8.5v1.8.5-rc0v1.8.5-rc1v1.8.5-rc2v1.8.5-rc3v1.8.5.1v1.8.5.2v1.8.5.3v1.8.5.4v1.8.5.5 注：如果你只是想要列出全部的标签，-l或者--list选项可以省略；但是如果是希望用特定的模式查找标签，-l或--list选项则是必须的 创建标签Git使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。 一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。 然而，附注标签是存储在Git数据库中的一个完整对象。它们是可以被校验的：其中包含打标签者的名字、电子邮件地址、日期时间，还有一个标签信息，并且可以使用GNU Privacy Guard （GPG）签名与验证。通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。 附注标签在Git中创建一个附注标签是很简单的。最简单的方式是当你在运行tag命令时指定-a选项： $ git tag -a v1.4 -m &quot;my version 1.4&quot;$ git tagv0.1v1.3v1.4 -m选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会运行编辑器要求你输入信息。 通过使用git show命令可以看到标签信息与对应的提交信息： $ git show v1.4tag v1.4Tagger: Ben Straub &lt;ben@straub.cc&gt;Date: Sat May 3 20:19:12 2014 -0700my version 1.4commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。 轻量标签另一种给提交打标签的方式是使用轻量标签。轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用-a、-s或-m选项，只需要提供标签名字： $ git tag v1.4-lw$ git tagv0.1v1.3v1.4v1.4-lwv1.5 这时，如果在标签上运行git show，你不会看到额外的标签信息。命令只会显示出提交信息： $ git show v1.4-lwcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 后期打标签你也可以对过去的提交打标签。假设提交历史是这样的： $ git log --pretty&#x3D;oneline15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#39;experiment&#39;a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support0d52aaab4479697da7686c15f77a3d64d9165190 one more thing6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#39;experiment&#39;0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function4682c3261057305bdd616e23b64b0857d832627b added a todo file166ae0c4d3f420721acbb115cc33848dfcc2121a started write support9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme 现在，假设在v1.2时你忘记给项目打标签，也就是在“updated rakefile”提交。你可以在之后补上标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）： $ git tag -a v1.2 9fceb02 共享标签默认情况下，git push命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样——你可以运行git push origin [tagname]。 $ git push origin v1.5Counting objects: 14, done.Delta compression using up to 8 threads.Compressing objects: 100% (12&#x2F;12), done.Writing objects: 100% (14&#x2F;14), 2.05 KiB | 0 bytes&#x2F;s, done.Total 14 (delta 3), reused 0 (delta 0)To git@github.com:schacon&#x2F;simplegit.git * [new tag] v1.5 -&gt; v1.5 如果想要一次性推送很多标签，也可以使用带有--tags选项的git push命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。 $ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1&#x2F;1), 160 bytes | 0 bytes&#x2F;s, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:schacon&#x2F;simplegit.git * [new tag] v1.4 -&gt; v1.4 * [new tag] v1.4-lw -&gt; v1.4-lw 现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。 删除标签要删除掉你本地仓库上的标签，可以使用命令git tag -d &lt;tagname&gt;。例如，可以使用下面的命令删除掉一个轻量级标签： $ git tag -d v1.4-lwDeleted tag &#39;v1.4-lw&#39; (was e7d5add) 应该注意的是上述命令并不会从任何远程仓库中移除这个标签，有两种方式可以从远程仓库中删除标签。 第一种方式是使用git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;来更新你的远程仓库： $ git push origin :refs&#x2F;tags&#x2F;v1.4-lwTo &#x2F;git@github.com:schacon&#x2F;simplegit.git - [deleted] v1.4-lw 第二种删除远程仓库标签的方式更加直观： $ git push origin --delete &lt;tagname&gt; 检出标签如果你想查看某个标签所指向的文件版本，可以使用git checkout命令。但是这会使你的仓库处于“分离头指针（detacthed HEAD）”状态，这个状态有些不好的副作用：如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。 因此，如果你需要进行更改，比如说你正在修复旧版本的错误，这通常需要创建一个新分支来进行操作。 Git别名有一个小技巧可以使你的Git体验更简单、容易、熟悉：别名 Git并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的Git命令，可以通过git config来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试： $ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status 这意味着，当要输入git commit时，只需要输入git ci。随着你继续不断地使用Git，可能也会经常使用其他命令，此时不要犹豫，为它创建一个别名吧。 在创建你认为应该存在的命令时这个技术也会很有用。例如，为了解决取消暂存文件的易用性问题，可以向Git中添加你自己的取消暂存别名： $ git config --global alias.unstage &#39;reset HEAD --&#39; 这会使下面的两个命令等价： $ git unstage fileA$ git reset HEAD -- fileA 这样看起来更清楚一些。通常也会添加一个last命令，像这样： $ git config --global alias.last &#39;log -1 HEAD&#39; 这样，可以轻松地看到最后一次提交： $ git lastcommit 66938dae3329c7aebe598c2246a8e6af90d04646Author: Josh Goebel &lt;dreamer3@example.com&gt;Date: Tue Aug 26 19:48:51 2008 +0800 test for current head Signed-off-by: Scott Chacon &lt;schacon@example.com&gt; 可以看出，Git只是简单地将别名替换为对应的命令。然而，你可能想要执行外部命令，而不是一个Git子命令。如果是那样的话，可以在命令前面加入!符号。如果你自己要写一些与Git仓库协作的工具的话，那会很有用。例如将git visual定义为gitk的别名： $ git config --global alias.visual &#39;!gitk&#39; 总结本文介绍的Git的内容的确不少，但是这些都是你学习Git务必要掌握的基础。随着你对Git的使用越来越多，你会发现Git的每一个命令都是精简而高效的，他们使得你对文件版本控制变得异常方便快捷。 Just do it! 参考文献 Pro Git Book Git Documents","categories":[{"name":"Git","slug":"Git","permalink":"http://www.yingzq.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.yingzq.com/tags/Git/"}]},{"title":"What is Git","slug":"what-is-git","date":"2019-09-18T14:19:30.000Z","updated":"2020-02-19T17:39:44.802Z","comments":true,"path":"2019/09/18/what-is-git/","link":"","permalink":"http://www.yingzq.com/2019/09/18/what-is-git/","excerpt":"相信写过代码的程序猿们都听说过Git的大名，哪怕是刚刚入门的小白，也在GitHub等代码托管网站git clone过他人的代码。那么什么是Git呢？本文将为你讲述Git的前世往生，看完本文，你应该会对版本控制、Git的诞生、Git基本概念和Git的基本特性有了一个初步的认识。","text":"相信写过代码的程序猿们都听说过Git的大名，哪怕是刚刚入门的小白，也在GitHub等代码托管网站git clone过他人的代码。那么什么是Git呢？本文将为你讲述Git的前世往生，看完本文，你应该会对版本控制、Git的诞生、Git基本概念和Git的基本特性有了一个初步的认识。 注：本文只包含了Git的相关概念，不包含任何命令行代码。 关于版本控制首先来了解一下什么是“版本控制”：版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。一般情况下是针对程序的源代码文件进行版本控制，但实际上你可以对任何类型的文件进行版本控制。 本地版本控制系统许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。 为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异（见图1）。 图1：本地版本控制系统 其中最流行的一种叫做RCS（Revision Control System），现今许多计算机系统上都还看得到它的踪影。甚至在流行的Mac OS X系统上安装了开发者工具包之后，也可以使用rcs命令。它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，便可以重新计算出各个版本的文件内容。 集中化的版本控制系统接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作呢？于是，集中化的版本控制系统（Centralized Version Control Systems，简称CVCS）应运而生。 这类系统，诸如CVS、Subversion以及Perforce等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法（见图2）。 图2：集中化的版本控制系统 这种做法带来了许多好处，特别是相较于老式的本地VCS来说。现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个CVCS要远比在各个客户端上维护本地数据库来得轻松容易。 事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。 分布式版本控制系统为了解决上述版本控制系统存在的问题，分布式版本控制系统（Distributed Version Control System，简称DVCS）诞生了。 在这类系统中，像Git、Mercurial、Bazaar以及Darcs等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份（见图3）。 图3：分布式版本控制系统 更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。 小结：可以看出分布式版本控制系统相比于本地版本控制和集中化的版本控制有着非常明显的优点。Git就是一个典型的分布式版本控制系统（DVCS）。 Git的诞生同生活中的许多伟大事物一样，Git诞生于一个极富纷争大举创新的年代。 1991年，22岁芬兰程序员Linus Torvalds（后文简称Linus）开源了Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 图4：Linus Torvalds Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 小节：Linux的诞生是因为当时还是大学生的Linus觉得好玩编写并开源的；而Git的诞生则是因为Linux社区刚好需要，所以Linus花了两周简单写了一下并开源的，可能这就是大佬吧… Git的基本特性我们已经知道Git是一种分布式版本控制系统，那么Git与其他的版本控制系统的差异是什么？自身的的特性又是什么呢？ Git直接记录快照，而非差异比较Git和其它版本控制系统（包括Subversion和近似工具）的主要差别在于Git对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。这类系统（CVS、Subversion、Perforce、Bazaar等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异（见图5）。 图5：存储每个文件与初始版本的差异 Git不按照以上方式对待或保存数据。反之，Git更像是把数据看作是对小型文件系统的一组快照（snapshot）。每次你提交更新，或在Git中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git不再重新存储该文件，而是只保留一个链接指向之前存储的文件（见图6）。Git对待数据更像是一个快照流。 图6：存储项目随时间改变的快照 这是Git与几乎所有其它版本控制系统的重要区别。Git更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的VCS。如果你刚刚接触VCS和Git，可能对这句话感触并不深，但是随着你对Git的了解越来越深入，例如在研究Git分支的管理时，会发现这种方式对待数据所能获得的巨大益处。 Git近乎所有操作都是本地执行在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git在这方面会让你感到速度之神赐给了Git超凡的能量。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。 举个例子，要浏览项目的历史，Git不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改，Git会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。 这也意味着你离线或者没有VPN时，几乎可以进行任何操作。如你在飞机或火车上想做些工作，你能愉快地提交，直到有网络连接时再上传。如你回家后VPN客户端不正常，你仍能工作。使用其它系统，做到如此是不可能或很费力的。比如，用Perforce，你没有连接服务器时几乎不能做什么事；用Subversion和CVS，你能修改文件，但不能向数据库提交修改（因为你的本地数据库离线了）。这看起来不是大问题，但是你可能会惊喜地发现它带来的巨大的不同。 Git保证完整性Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。这个功能建构在Git底层，是构成Git哲学不可或缺的部分。若你在传送过程中丢失信息或损坏文件，Git就能发现。 Git用以计算校验和的机制叫做SHA-1散列。这是一个由40个十六进制字符（0-9和a-f）组成的字符串，基于Git中文件的内容或目录结构计算出来。SHA-1哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373Git一般只添加数据你执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。同别的VCS一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到Git中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。 Git文件有三种状态请注意，如果你希望后面的学习过程更加顺利，这里将是关于Git你最需要记住的一点——对于任何一个文件，在Git内都只有三种状态：已修改（modified），已暂存（staged）和已提交（committed）。 已修改表示修改了文件，但还没保存到数据库中 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 已提交表示数据已经安全的保存在本地数据库中 由此引入Git项目的三个工作区域的概念：工作目录、暂存区域以及Git仓库。 图7：工作目录、暂存区域以及Git仓库 工作目录是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。 Git仓库目录是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 基本的Git工作流程如下： 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录 如果Git目录中保存着特定版本的文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 总结你应该已经对Git是什么、Git与你可能正在使用的集中式版本控制系统有何区别等问题有了基本的了解。对于Git的特性，本文也只是简单提及，它的分支管理、代码合并等功能更让人欲罢不能。如今Git已经成为了最流行的开源分布式版本控制系统，它值得你去深入探索研究! 参考文献 Pro Git Book 廖雪峰 Git教程","categories":[{"name":"Git","slug":"Git","permalink":"http://www.yingzq.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.yingzq.com/tags/Git/"}]}]}